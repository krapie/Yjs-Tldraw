var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a7, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp.call(b7, prop))
      __defNormalProp(a7, prop, b7[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b7)) {
      if (__propIsEnum.call(b7, prop))
        __defNormalProp(a7, prop, b7[prop]);
    }
  return a7;
};
var __spreadProps = (a7, b7) => __defProps(a7, __getOwnPropDescs(b7));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject2) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject2(e11);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e11) {
        reject2(e11);
      }
    };
    var step = (x6) => x6.done ? resolve(x6.value) : Promise.resolve(x6.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i8 = 0; i8 < 10; i8++) {
          test2["_" + String.fromCharCode(i8)] = i8;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n6) {
          return test2[n6];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s9 = 1; s9 < arguments.length; s9++) {
        from2 = Object(arguments[s9]);
        for (var key in from2) {
          if (hasOwnProperty.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i8 = 0; i8 < symbols.length; i8++) {
            if (propIsEnumerable.call(from2, symbols[i8])) {
              to[symbols[i8]] = from2[symbols[i8]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "../../node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l9 = require_object_assign();
    var n6 = 60103;
    var p7 = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var q3 = 60109;
    var r12 = 60110;
    var t12 = 60112;
    exports.Suspense = 60113;
    var u4 = 60115;
    var v6 = 60116;
    if (typeof Symbol === "function" && Symbol.for) {
      w6 = Symbol.for;
      n6 = w6("react.element");
      p7 = w6("react.portal");
      exports.Fragment = w6("react.fragment");
      exports.StrictMode = w6("react.strict_mode");
      exports.Profiler = w6("react.profiler");
      q3 = w6("react.provider");
      r12 = w6("react.context");
      t12 = w6("react.forward_ref");
      exports.Suspense = w6("react.suspense");
      u4 = w6("react.memo");
      v6 = w6("react.lazy");
    }
    var w6;
    var x6 = typeof Symbol === "function" && Symbol.iterator;
    function y5(a7) {
      if (a7 === null || typeof a7 !== "object")
        return null;
      a7 = x6 && a7[x6] || a7["@@iterator"];
      return typeof a7 === "function" ? a7 : null;
    }
    function z3(a7) {
      for (var b7 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a7, c8 = 1; c8 < arguments.length; c8++)
        b7 += "&args[]=" + encodeURIComponent(arguments[c8]);
      return "Minified React error #" + a7 + "; visit " + b7 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A3 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var B4 = {};
    function C6(a7, b7, c8) {
      this.props = a7;
      this.context = b7;
      this.refs = B4;
      this.updater = c8 || A3;
    }
    C6.prototype.isReactComponent = {};
    C6.prototype.setState = function(a7, b7) {
      if (typeof a7 !== "object" && typeof a7 !== "function" && a7 != null)
        throw Error(z3(85));
      this.updater.enqueueSetState(this, a7, b7, "setState");
    };
    C6.prototype.forceUpdate = function(a7) {
      this.updater.enqueueForceUpdate(this, a7, "forceUpdate");
    };
    function D5() {
    }
    D5.prototype = C6.prototype;
    function E7(a7, b7, c8) {
      this.props = a7;
      this.context = b7;
      this.refs = B4;
      this.updater = c8 || A3;
    }
    var F5 = E7.prototype = new D5();
    F5.constructor = E7;
    l9(F5, C6.prototype);
    F5.isPureReactComponent = true;
    var G4 = { current: null };
    var H4 = Object.prototype.hasOwnProperty;
    var I4 = { key: true, ref: true, __self: true, __source: true };
    function J4(a7, b7, c8) {
      var e11, d7 = {}, k4 = null, h4 = null;
      if (b7 != null)
        for (e11 in b7.ref !== void 0 && (h4 = b7.ref), b7.key !== void 0 && (k4 = "" + b7.key), b7)
          H4.call(b7, e11) && !I4.hasOwnProperty(e11) && (d7[e11] = b7[e11]);
      var g6 = arguments.length - 2;
      if (g6 === 1)
        d7.children = c8;
      else if (1 < g6) {
        for (var f10 = Array(g6), m8 = 0; m8 < g6; m8++)
          f10[m8] = arguments[m8 + 2];
        d7.children = f10;
      }
      if (a7 && a7.defaultProps)
        for (e11 in g6 = a7.defaultProps, g6)
          d7[e11] === void 0 && (d7[e11] = g6[e11]);
      return { $$typeof: n6, type: a7, key: k4, ref: h4, props: d7, _owner: G4.current };
    }
    function K3(a7, b7) {
      return { $$typeof: n6, type: a7.type, key: b7, ref: a7.ref, props: a7.props, _owner: a7._owner };
    }
    function L4(a7) {
      return typeof a7 === "object" && a7 !== null && a7.$$typeof === n6;
    }
    function escape2(a7) {
      var b7 = { "=": "=0", ":": "=2" };
      return "$" + a7.replace(/[=:]/g, function(a8) {
        return b7[a8];
      });
    }
    var M3 = /\/+/g;
    function N2(a7, b7) {
      return typeof a7 === "object" && a7 !== null && a7.key != null ? escape2("" + a7.key) : b7.toString(36);
    }
    function O4(a7, b7, c8, e11, d7) {
      var k4 = typeof a7;
      if (k4 === "undefined" || k4 === "boolean")
        a7 = null;
      var h4 = false;
      if (a7 === null)
        h4 = true;
      else
        switch (k4) {
          case "string":
          case "number":
            h4 = true;
            break;
          case "object":
            switch (a7.$$typeof) {
              case n6:
              case p7:
                h4 = true;
            }
        }
      if (h4)
        return h4 = a7, d7 = d7(h4), a7 = e11 === "" ? "." + N2(h4, 0) : e11, Array.isArray(d7) ? (c8 = "", a7 != null && (c8 = a7.replace(M3, "$&/") + "/"), O4(d7, b7, c8, "", function(a8) {
          return a8;
        })) : d7 != null && (L4(d7) && (d7 = K3(d7, c8 + (!d7.key || h4 && h4.key === d7.key ? "" : ("" + d7.key).replace(M3, "$&/") + "/") + a7)), b7.push(d7)), 1;
      h4 = 0;
      e11 = e11 === "" ? "." : e11 + ":";
      if (Array.isArray(a7))
        for (var g6 = 0; g6 < a7.length; g6++) {
          k4 = a7[g6];
          var f10 = e11 + N2(k4, g6);
          h4 += O4(k4, b7, c8, f10, d7);
        }
      else if (f10 = y5(a7), typeof f10 === "function")
        for (a7 = f10.call(a7), g6 = 0; !(k4 = a7.next()).done; )
          k4 = k4.value, f10 = e11 + N2(k4, g6++), h4 += O4(k4, b7, c8, f10, d7);
      else if (k4 === "object")
        throw b7 = "" + a7, Error(z3(31, b7 === "[object Object]" ? "object with keys {" + Object.keys(a7).join(", ") + "}" : b7));
      return h4;
    }
    function P3(a7, b7, c8) {
      if (a7 == null)
        return a7;
      var e11 = [], d7 = 0;
      O4(a7, e11, "", "", function(a8) {
        return b7.call(c8, a8, d7++);
      });
      return e11;
    }
    function Q(a7) {
      if (a7._status === -1) {
        var b7 = a7._result;
        b7 = b7();
        a7._status = 0;
        a7._result = b7;
        b7.then(function(b8) {
          a7._status === 0 && (b8 = b8.default, a7._status = 1, a7._result = b8);
        }, function(b8) {
          a7._status === 0 && (a7._status = 2, a7._result = b8);
        });
      }
      if (a7._status === 1)
        return a7._result;
      throw a7._result;
    }
    var R5 = { current: null };
    function S3() {
      var a7 = R5.current;
      if (a7 === null)
        throw Error(z3(321));
      return a7;
    }
    var T5 = { ReactCurrentDispatcher: R5, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G4, IsSomeRendererActing: { current: false }, assign: l9 };
    exports.Children = { map: P3, forEach: function(a7, b7, c8) {
      P3(a7, function() {
        b7.apply(this, arguments);
      }, c8);
    }, count: function(a7) {
      var b7 = 0;
      P3(a7, function() {
        b7++;
      });
      return b7;
    }, toArray: function(a7) {
      return P3(a7, function(a8) {
        return a8;
      }) || [];
    }, only: function(a7) {
      if (!L4(a7))
        throw Error(z3(143));
      return a7;
    } };
    exports.Component = C6;
    exports.PureComponent = E7;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T5;
    exports.cloneElement = function(a7, b7, c8) {
      if (a7 === null || a7 === void 0)
        throw Error(z3(267, a7));
      var e11 = l9({}, a7.props), d7 = a7.key, k4 = a7.ref, h4 = a7._owner;
      if (b7 != null) {
        b7.ref !== void 0 && (k4 = b7.ref, h4 = G4.current);
        b7.key !== void 0 && (d7 = "" + b7.key);
        if (a7.type && a7.type.defaultProps)
          var g6 = a7.type.defaultProps;
        for (f10 in b7)
          H4.call(b7, f10) && !I4.hasOwnProperty(f10) && (e11[f10] = b7[f10] === void 0 && g6 !== void 0 ? g6[f10] : b7[f10]);
      }
      var f10 = arguments.length - 2;
      if (f10 === 1)
        e11.children = c8;
      else if (1 < f10) {
        g6 = Array(f10);
        for (var m8 = 0; m8 < f10; m8++)
          g6[m8] = arguments[m8 + 2];
        e11.children = g6;
      }
      return {
        $$typeof: n6,
        type: a7.type,
        key: d7,
        ref: k4,
        props: e11,
        _owner: h4
      };
    };
    exports.createContext = function(a7, b7) {
      b7 === void 0 && (b7 = null);
      a7 = { $$typeof: r12, _calculateChangedBits: b7, _currentValue: a7, _currentValue2: a7, _threadCount: 0, Provider: null, Consumer: null };
      a7.Provider = { $$typeof: q3, _context: a7 };
      return a7.Consumer = a7;
    };
    exports.createElement = J4;
    exports.createFactory = function(a7) {
      var b7 = J4.bind(null, a7);
      b7.type = a7;
      return b7;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a7) {
      return { $$typeof: t12, render: a7 };
    };
    exports.isValidElement = L4;
    exports.lazy = function(a7) {
      return { $$typeof: v6, _payload: { _status: -1, _result: a7 }, _init: Q };
    };
    exports.memo = function(a7, b7) {
      return { $$typeof: u4, type: a7, compare: b7 === void 0 ? null : b7 };
    };
    exports.useCallback = function(a7, b7) {
      return S3().useCallback(a7, b7);
    };
    exports.useContext = function(a7, b7) {
      return S3().useContext(a7, b7);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a7, b7) {
      return S3().useEffect(a7, b7);
    };
    exports.useImperativeHandle = function(a7, b7, c8) {
      return S3().useImperativeHandle(a7, b7, c8);
    };
    exports.useLayoutEffect = function(a7, b7) {
      return S3().useLayoutEffect(a7, b7);
    };
    exports.useMemo = function(a7, b7) {
      return S3().useMemo(a7, b7);
    };
    exports.useReducer = function(a7, b7, c8) {
      return S3().useReducer(a7, b7, c8);
    };
    exports.useRef = function(a7) {
      return S3().useRef(a7);
    };
    exports.useState = function(a7) {
      return S3().useState(a7);
    };
    exports.version = "17.0.2";
  }
});

// ../../node_modules/react/index.js
var require_react = __commonJS({
  "../../node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "../../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
    "use strict";
    var f10;
    var g6;
    var h4;
    var k4;
    if (typeof performance === "object" && typeof performance.now === "function") {
      l9 = performance;
      exports.unstable_now = function() {
        return l9.now();
      };
    } else {
      p7 = Date, q3 = p7.now();
      exports.unstable_now = function() {
        return p7.now() - q3;
      };
    }
    var l9;
    var p7;
    var q3;
    if (typeof window === "undefined" || typeof MessageChannel !== "function") {
      t12 = null, u4 = null, w6 = function() {
        if (t12 !== null)
          try {
            var a7 = exports.unstable_now();
            t12(true, a7);
            t12 = null;
          } catch (b7) {
            throw setTimeout(w6, 0), b7;
          }
      };
      f10 = function(a7) {
        t12 !== null ? setTimeout(f10, 0, a7) : (t12 = a7, setTimeout(w6, 0));
      };
      g6 = function(a7, b7) {
        u4 = setTimeout(a7, b7);
      };
      h4 = function() {
        clearTimeout(u4);
      };
      exports.unstable_shouldYield = function() {
        return false;
      };
      k4 = exports.unstable_forceFrameRate = function() {
      };
    } else {
      x6 = window.setTimeout, y5 = window.clearTimeout;
      if (typeof console !== "undefined") {
        z3 = window.cancelAnimationFrame;
        typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        typeof z3 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      }
      A3 = false, B4 = null, C6 = -1, D5 = 5, E7 = 0;
      exports.unstable_shouldYield = function() {
        return exports.unstable_now() >= E7;
      };
      k4 = function() {
      };
      exports.unstable_forceFrameRate = function(a7) {
        0 > a7 || 125 < a7 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D5 = 0 < a7 ? Math.floor(1e3 / a7) : 5;
      };
      F5 = new MessageChannel(), G4 = F5.port2;
      F5.port1.onmessage = function() {
        if (B4 !== null) {
          var a7 = exports.unstable_now();
          E7 = a7 + D5;
          try {
            B4(true, a7) ? G4.postMessage(null) : (A3 = false, B4 = null);
          } catch (b7) {
            throw G4.postMessage(null), b7;
          }
        } else
          A3 = false;
      };
      f10 = function(a7) {
        B4 = a7;
        A3 || (A3 = true, G4.postMessage(null));
      };
      g6 = function(a7, b7) {
        C6 = x6(function() {
          a7(exports.unstable_now());
        }, b7);
      };
      h4 = function() {
        y5(C6);
        C6 = -1;
      };
    }
    var t12;
    var u4;
    var w6;
    var x6;
    var y5;
    var z3;
    var A3;
    var B4;
    var C6;
    var D5;
    var E7;
    var F5;
    var G4;
    function H4(a7, b7) {
      var c8 = a7.length;
      a7.push(b7);
      a:
        for (; ; ) {
          var d7 = c8 - 1 >>> 1, e11 = a7[d7];
          if (e11 !== void 0 && 0 < I4(e11, b7))
            a7[d7] = b7, a7[c8] = e11, c8 = d7;
          else
            break a;
        }
    }
    function J4(a7) {
      a7 = a7[0];
      return a7 === void 0 ? null : a7;
    }
    function K3(a7) {
      var b7 = a7[0];
      if (b7 !== void 0) {
        var c8 = a7.pop();
        if (c8 !== b7) {
          a7[0] = c8;
          a:
            for (var d7 = 0, e11 = a7.length; d7 < e11; ) {
              var m8 = 2 * (d7 + 1) - 1, n6 = a7[m8], v6 = m8 + 1, r12 = a7[v6];
              if (n6 !== void 0 && 0 > I4(n6, c8))
                r12 !== void 0 && 0 > I4(r12, n6) ? (a7[d7] = r12, a7[v6] = c8, d7 = v6) : (a7[d7] = n6, a7[m8] = c8, d7 = m8);
              else if (r12 !== void 0 && 0 > I4(r12, c8))
                a7[d7] = r12, a7[v6] = c8, d7 = v6;
              else
                break a;
            }
        }
        return b7;
      }
      return null;
    }
    function I4(a7, b7) {
      var c8 = a7.sortIndex - b7.sortIndex;
      return c8 !== 0 ? c8 : a7.id - b7.id;
    }
    var L4 = [];
    var M3 = [];
    var N2 = 1;
    var O4 = null;
    var P3 = 3;
    var Q = false;
    var R5 = false;
    var S3 = false;
    function T5(a7) {
      for (var b7 = J4(M3); b7 !== null; ) {
        if (b7.callback === null)
          K3(M3);
        else if (b7.startTime <= a7)
          K3(M3), b7.sortIndex = b7.expirationTime, H4(L4, b7);
        else
          break;
        b7 = J4(M3);
      }
    }
    function U3(a7) {
      S3 = false;
      T5(a7);
      if (!R5)
        if (J4(L4) !== null)
          R5 = true, f10(V5);
        else {
          var b7 = J4(M3);
          b7 !== null && g6(U3, b7.startTime - a7);
        }
    }
    function V5(a7, b7) {
      R5 = false;
      S3 && (S3 = false, h4());
      Q = true;
      var c8 = P3;
      try {
        T5(b7);
        for (O4 = J4(L4); O4 !== null && (!(O4.expirationTime > b7) || a7 && !exports.unstable_shouldYield()); ) {
          var d7 = O4.callback;
          if (typeof d7 === "function") {
            O4.callback = null;
            P3 = O4.priorityLevel;
            var e11 = d7(O4.expirationTime <= b7);
            b7 = exports.unstable_now();
            typeof e11 === "function" ? O4.callback = e11 : O4 === J4(L4) && K3(L4);
            T5(b7);
          } else
            K3(L4);
          O4 = J4(L4);
        }
        if (O4 !== null)
          var m8 = true;
        else {
          var n6 = J4(M3);
          n6 !== null && g6(U3, n6.startTime - b7);
          m8 = false;
        }
        return m8;
      } finally {
        O4 = null, P3 = c8, Q = false;
      }
    }
    var W4 = k4;
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a7) {
      a7.callback = null;
    };
    exports.unstable_continueExecution = function() {
      R5 || Q || (R5 = true, f10(V5));
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return P3;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return J4(L4);
    };
    exports.unstable_next = function(a7) {
      switch (P3) {
        case 1:
        case 2:
        case 3:
          var b7 = 3;
          break;
        default:
          b7 = P3;
      }
      var c8 = P3;
      P3 = b7;
      try {
        return a7();
      } finally {
        P3 = c8;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = W4;
    exports.unstable_runWithPriority = function(a7, b7) {
      switch (a7) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a7 = 3;
      }
      var c8 = P3;
      P3 = a7;
      try {
        return b7();
      } finally {
        P3 = c8;
      }
    };
    exports.unstable_scheduleCallback = function(a7, b7, c8) {
      var d7 = exports.unstable_now();
      typeof c8 === "object" && c8 !== null ? (c8 = c8.delay, c8 = typeof c8 === "number" && 0 < c8 ? d7 + c8 : d7) : c8 = d7;
      switch (a7) {
        case 1:
          var e11 = -1;
          break;
        case 2:
          e11 = 250;
          break;
        case 5:
          e11 = 1073741823;
          break;
        case 4:
          e11 = 1e4;
          break;
        default:
          e11 = 5e3;
      }
      e11 = c8 + e11;
      a7 = { id: N2++, callback: b7, priorityLevel: a7, startTime: c8, expirationTime: e11, sortIndex: -1 };
      c8 > d7 ? (a7.sortIndex = c8, H4(M3, a7), J4(L4) === null && a7 === J4(M3) && (S3 ? h4() : S3 = true, g6(U3, c8 - d7))) : (a7.sortIndex = e11, H4(L4, a7), R5 || Q || (R5 = true, f10(V5)));
      return a7;
    };
    exports.unstable_wrapCallback = function(a7) {
      var b7 = P3;
      return function() {
        var c8 = P3;
        P3 = b7;
        try {
          return a7.apply(this, arguments);
        } finally {
          P3 = c8;
        }
      };
    };
  }
});

// ../../node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../../node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_scheduler_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "../../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
    "use strict";
    var aa = require_react();
    var m8 = require_object_assign();
    var r12 = require_scheduler();
    function y5(a7) {
      for (var b7 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a7, c8 = 1; c8 < arguments.length; c8++)
        b7 += "&args[]=" + encodeURIComponent(arguments[c8]);
      return "Minified React error #" + a7 + "; visit " + b7 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(y5(227));
    var ba = /* @__PURE__ */ new Set();
    var ca = {};
    function da(a7, b7) {
      ea(a7, b7);
      ea(a7 + "Capture", b7);
    }
    function ea(a7, b7) {
      ca[a7] = b7;
      for (a7 = 0; a7 < b7.length; a7++)
        ba.add(b7[a7]);
    }
    var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
    var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var ia = Object.prototype.hasOwnProperty;
    var ja = {};
    var ka = {};
    function la(a7) {
      if (ia.call(ka, a7))
        return true;
      if (ia.call(ja, a7))
        return false;
      if (ha.test(a7))
        return ka[a7] = true;
      ja[a7] = true;
      return false;
    }
    function ma(a7, b7, c8, d7) {
      if (c8 !== null && c8.type === 0)
        return false;
      switch (typeof b7) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d7)
            return false;
          if (c8 !== null)
            return !c8.acceptsBooleans;
          a7 = a7.toLowerCase().slice(0, 5);
          return a7 !== "data-" && a7 !== "aria-";
        default:
          return false;
      }
    }
    function na(a7, b7, c8, d7) {
      if (b7 === null || typeof b7 === "undefined" || ma(a7, b7, c8, d7))
        return true;
      if (d7)
        return false;
      if (c8 !== null)
        switch (c8.type) {
          case 3:
            return !b7;
          case 4:
            return b7 === false;
          case 5:
            return isNaN(b7);
          case 6:
            return isNaN(b7) || 1 > b7;
        }
      return false;
    }
    function B4(a7, b7, c8, d7, e11, f10, g6) {
      this.acceptsBooleans = b7 === 2 || b7 === 3 || b7 === 4;
      this.attributeName = d7;
      this.attributeNamespace = e11;
      this.mustUseProperty = c8;
      this.propertyName = a7;
      this.type = b7;
      this.sanitizeURL = f10;
      this.removeEmptyString = g6;
    }
    var D5 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a7) {
      D5[a7] = new B4(a7, 0, false, a7, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a7) {
      var b7 = a7[0];
      D5[b7] = new B4(b7, 1, false, a7[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a7) {
      D5[a7] = new B4(a7, 2, false, a7.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a7) {
      D5[a7] = new B4(a7, 2, false, a7, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a7) {
      D5[a7] = new B4(a7, 3, false, a7.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a7) {
      D5[a7] = new B4(a7, 3, true, a7, null, false, false);
    });
    ["capture", "download"].forEach(function(a7) {
      D5[a7] = new B4(a7, 4, false, a7, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a7) {
      D5[a7] = new B4(a7, 6, false, a7, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a7) {
      D5[a7] = new B4(a7, 5, false, a7.toLowerCase(), null, false, false);
    });
    var oa = /[\-:]([a-z])/g;
    function pa(a7) {
      return a7[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a7) {
      var b7 = a7.replace(oa, pa);
      D5[b7] = new B4(b7, 1, false, a7, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a7) {
      var b7 = a7.replace(oa, pa);
      D5[b7] = new B4(b7, 1, false, a7, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a7) {
      var b7 = a7.replace(oa, pa);
      D5[b7] = new B4(b7, 1, false, a7, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a7) {
      D5[a7] = new B4(a7, 1, false, a7.toLowerCase(), null, false, false);
    });
    D5.xlinkHref = new B4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a7) {
      D5[a7] = new B4(a7, 1, false, a7.toLowerCase(), null, true, true);
    });
    function qa(a7, b7, c8, d7) {
      var e11 = D5.hasOwnProperty(b7) ? D5[b7] : null;
      var f10 = e11 !== null ? e11.type === 0 : d7 ? false : !(2 < b7.length) || b7[0] !== "o" && b7[0] !== "O" || b7[1] !== "n" && b7[1] !== "N" ? false : true;
      f10 || (na(b7, c8, e11, d7) && (c8 = null), d7 || e11 === null ? la(b7) && (c8 === null ? a7.removeAttribute(b7) : a7.setAttribute(b7, "" + c8)) : e11.mustUseProperty ? a7[e11.propertyName] = c8 === null ? e11.type === 3 ? false : "" : c8 : (b7 = e11.attributeName, d7 = e11.attributeNamespace, c8 === null ? a7.removeAttribute(b7) : (e11 = e11.type, c8 = e11 === 3 || e11 === 4 && c8 === true ? "" : "" + c8, d7 ? a7.setAttributeNS(d7, b7, c8) : a7.setAttribute(b7, c8))));
    }
    var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var sa = 60103;
    var ta = 60106;
    var ua = 60107;
    var wa = 60108;
    var xa = 60114;
    var ya = 60109;
    var za = 60110;
    var Aa = 60112;
    var Ba = 60113;
    var Ca = 60120;
    var Da = 60115;
    var Ea = 60116;
    var Fa = 60121;
    var Ga = 60128;
    var Ha = 60129;
    var Ia = 60130;
    var Ja = 60131;
    if (typeof Symbol === "function" && Symbol.for) {
      E7 = Symbol.for;
      sa = E7("react.element");
      ta = E7("react.portal");
      ua = E7("react.fragment");
      wa = E7("react.strict_mode");
      xa = E7("react.profiler");
      ya = E7("react.provider");
      za = E7("react.context");
      Aa = E7("react.forward_ref");
      Ba = E7("react.suspense");
      Ca = E7("react.suspense_list");
      Da = E7("react.memo");
      Ea = E7("react.lazy");
      Fa = E7("react.block");
      E7("react.scope");
      Ga = E7("react.opaque.id");
      Ha = E7("react.debug_trace_mode");
      Ia = E7("react.offscreen");
      Ja = E7("react.legacy_hidden");
    }
    var E7;
    var Ka = typeof Symbol === "function" && Symbol.iterator;
    function La(a7) {
      if (a7 === null || typeof a7 !== "object")
        return null;
      a7 = Ka && a7[Ka] || a7["@@iterator"];
      return typeof a7 === "function" ? a7 : null;
    }
    var Ma;
    function Na(a7) {
      if (Ma === void 0)
        try {
          throw Error();
        } catch (c8) {
          var b7 = c8.stack.trim().match(/\n( *(at )?)/);
          Ma = b7 && b7[1] || "";
        }
      return "\n" + Ma + a7;
    }
    var Oa = false;
    function Pa(a7, b7) {
      if (!a7 || Oa)
        return "";
      Oa = true;
      var c8 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b7)
          if (b7 = function() {
            throw Error();
          }, Object.defineProperty(b7.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(b7, []);
            } catch (k4) {
              var d7 = k4;
            }
            Reflect.construct(a7, [], b7);
          } else {
            try {
              b7.call();
            } catch (k4) {
              d7 = k4;
            }
            a7.call(b7.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k4) {
            d7 = k4;
          }
          a7();
        }
      } catch (k4) {
        if (k4 && d7 && typeof k4.stack === "string") {
          for (var e11 = k4.stack.split("\n"), f10 = d7.stack.split("\n"), g6 = e11.length - 1, h4 = f10.length - 1; 1 <= g6 && 0 <= h4 && e11[g6] !== f10[h4]; )
            h4--;
          for (; 1 <= g6 && 0 <= h4; g6--, h4--)
            if (e11[g6] !== f10[h4]) {
              if (g6 !== 1 || h4 !== 1) {
                do
                  if (g6--, h4--, 0 > h4 || e11[g6] !== f10[h4])
                    return "\n" + e11[g6].replace(" at new ", " at ");
                while (1 <= g6 && 0 <= h4);
              }
              break;
            }
        }
      } finally {
        Oa = false, Error.prepareStackTrace = c8;
      }
      return (a7 = a7 ? a7.displayName || a7.name : "") ? Na(a7) : "";
    }
    function Qa(a7) {
      switch (a7.tag) {
        case 5:
          return Na(a7.type);
        case 16:
          return Na("Lazy");
        case 13:
          return Na("Suspense");
        case 19:
          return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a7 = Pa(a7.type, false), a7;
        case 11:
          return a7 = Pa(a7.type.render, false), a7;
        case 22:
          return a7 = Pa(a7.type._render, false), a7;
        case 1:
          return a7 = Pa(a7.type, true), a7;
        default:
          return "";
      }
    }
    function Ra(a7) {
      if (a7 == null)
        return null;
      if (typeof a7 === "function")
        return a7.displayName || a7.name || null;
      if (typeof a7 === "string")
        return a7;
      switch (a7) {
        case ua:
          return "Fragment";
        case ta:
          return "Portal";
        case xa:
          return "Profiler";
        case wa:
          return "StrictMode";
        case Ba:
          return "Suspense";
        case Ca:
          return "SuspenseList";
      }
      if (typeof a7 === "object")
        switch (a7.$$typeof) {
          case za:
            return (a7.displayName || "Context") + ".Consumer";
          case ya:
            return (a7._context.displayName || "Context") + ".Provider";
          case Aa:
            var b7 = a7.render;
            b7 = b7.displayName || b7.name || "";
            return a7.displayName || (b7 !== "" ? "ForwardRef(" + b7 + ")" : "ForwardRef");
          case Da:
            return Ra(a7.type);
          case Fa:
            return Ra(a7._render);
          case Ea:
            b7 = a7._payload;
            a7 = a7._init;
            try {
              return Ra(a7(b7));
            } catch (c8) {
            }
        }
      return null;
    }
    function Sa(a7) {
      switch (typeof a7) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a7;
        default:
          return "";
      }
    }
    function Ta(a7) {
      var b7 = a7.type;
      return (a7 = a7.nodeName) && a7.toLowerCase() === "input" && (b7 === "checkbox" || b7 === "radio");
    }
    function Ua(a7) {
      var b7 = Ta(a7) ? "checked" : "value", c8 = Object.getOwnPropertyDescriptor(a7.constructor.prototype, b7), d7 = "" + a7[b7];
      if (!a7.hasOwnProperty(b7) && typeof c8 !== "undefined" && typeof c8.get === "function" && typeof c8.set === "function") {
        var e11 = c8.get, f10 = c8.set;
        Object.defineProperty(a7, b7, { configurable: true, get: function() {
          return e11.call(this);
        }, set: function(a8) {
          d7 = "" + a8;
          f10.call(this, a8);
        } });
        Object.defineProperty(a7, b7, { enumerable: c8.enumerable });
        return { getValue: function() {
          return d7;
        }, setValue: function(a8) {
          d7 = "" + a8;
        }, stopTracking: function() {
          a7._valueTracker = null;
          delete a7[b7];
        } };
      }
    }
    function Va(a7) {
      a7._valueTracker || (a7._valueTracker = Ua(a7));
    }
    function Wa(a7) {
      if (!a7)
        return false;
      var b7 = a7._valueTracker;
      if (!b7)
        return true;
      var c8 = b7.getValue();
      var d7 = "";
      a7 && (d7 = Ta(a7) ? a7.checked ? "true" : "false" : a7.value);
      a7 = d7;
      return a7 !== c8 ? (b7.setValue(a7), true) : false;
    }
    function Xa(a7) {
      a7 = a7 || (typeof document !== "undefined" ? document : void 0);
      if (typeof a7 === "undefined")
        return null;
      try {
        return a7.activeElement || a7.body;
      } catch (b7) {
        return a7.body;
      }
    }
    function Ya(a7, b7) {
      var c8 = b7.checked;
      return m8({}, b7, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c8 != null ? c8 : a7._wrapperState.initialChecked });
    }
    function Za(a7, b7) {
      var c8 = b7.defaultValue == null ? "" : b7.defaultValue, d7 = b7.checked != null ? b7.checked : b7.defaultChecked;
      c8 = Sa(b7.value != null ? b7.value : c8);
      a7._wrapperState = { initialChecked: d7, initialValue: c8, controlled: b7.type === "checkbox" || b7.type === "radio" ? b7.checked != null : b7.value != null };
    }
    function $a(a7, b7) {
      b7 = b7.checked;
      b7 != null && qa(a7, "checked", b7, false);
    }
    function ab(a7, b7) {
      $a(a7, b7);
      var c8 = Sa(b7.value), d7 = b7.type;
      if (c8 != null)
        if (d7 === "number") {
          if (c8 === 0 && a7.value === "" || a7.value != c8)
            a7.value = "" + c8;
        } else
          a7.value !== "" + c8 && (a7.value = "" + c8);
      else if (d7 === "submit" || d7 === "reset") {
        a7.removeAttribute("value");
        return;
      }
      b7.hasOwnProperty("value") ? bb(a7, b7.type, c8) : b7.hasOwnProperty("defaultValue") && bb(a7, b7.type, Sa(b7.defaultValue));
      b7.checked == null && b7.defaultChecked != null && (a7.defaultChecked = !!b7.defaultChecked);
    }
    function cb(a7, b7, c8) {
      if (b7.hasOwnProperty("value") || b7.hasOwnProperty("defaultValue")) {
        var d7 = b7.type;
        if (!(d7 !== "submit" && d7 !== "reset" || b7.value !== void 0 && b7.value !== null))
          return;
        b7 = "" + a7._wrapperState.initialValue;
        c8 || b7 === a7.value || (a7.value = b7);
        a7.defaultValue = b7;
      }
      c8 = a7.name;
      c8 !== "" && (a7.name = "");
      a7.defaultChecked = !!a7._wrapperState.initialChecked;
      c8 !== "" && (a7.name = c8);
    }
    function bb(a7, b7, c8) {
      if (b7 !== "number" || Xa(a7.ownerDocument) !== a7)
        c8 == null ? a7.defaultValue = "" + a7._wrapperState.initialValue : a7.defaultValue !== "" + c8 && (a7.defaultValue = "" + c8);
    }
    function db(a7) {
      var b7 = "";
      aa.Children.forEach(a7, function(a8) {
        a8 != null && (b7 += a8);
      });
      return b7;
    }
    function eb(a7, b7) {
      a7 = m8({ children: void 0 }, b7);
      if (b7 = db(b7.children))
        a7.children = b7;
      return a7;
    }
    function fb(a7, b7, c8, d7) {
      a7 = a7.options;
      if (b7) {
        b7 = {};
        for (var e11 = 0; e11 < c8.length; e11++)
          b7["$" + c8[e11]] = true;
        for (c8 = 0; c8 < a7.length; c8++)
          e11 = b7.hasOwnProperty("$" + a7[c8].value), a7[c8].selected !== e11 && (a7[c8].selected = e11), e11 && d7 && (a7[c8].defaultSelected = true);
      } else {
        c8 = "" + Sa(c8);
        b7 = null;
        for (e11 = 0; e11 < a7.length; e11++) {
          if (a7[e11].value === c8) {
            a7[e11].selected = true;
            d7 && (a7[e11].defaultSelected = true);
            return;
          }
          b7 !== null || a7[e11].disabled || (b7 = a7[e11]);
        }
        b7 !== null && (b7.selected = true);
      }
    }
    function gb(a7, b7) {
      if (b7.dangerouslySetInnerHTML != null)
        throw Error(y5(91));
      return m8({}, b7, { value: void 0, defaultValue: void 0, children: "" + a7._wrapperState.initialValue });
    }
    function hb(a7, b7) {
      var c8 = b7.value;
      if (c8 == null) {
        c8 = b7.children;
        b7 = b7.defaultValue;
        if (c8 != null) {
          if (b7 != null)
            throw Error(y5(92));
          if (Array.isArray(c8)) {
            if (!(1 >= c8.length))
              throw Error(y5(93));
            c8 = c8[0];
          }
          b7 = c8;
        }
        b7 == null && (b7 = "");
        c8 = b7;
      }
      a7._wrapperState = { initialValue: Sa(c8) };
    }
    function ib(a7, b7) {
      var c8 = Sa(b7.value), d7 = Sa(b7.defaultValue);
      c8 != null && (c8 = "" + c8, c8 !== a7.value && (a7.value = c8), b7.defaultValue == null && a7.defaultValue !== c8 && (a7.defaultValue = c8));
      d7 != null && (a7.defaultValue = "" + d7);
    }
    function jb(a7) {
      var b7 = a7.textContent;
      b7 === a7._wrapperState.initialValue && b7 !== "" && b7 !== null && (a7.value = b7);
    }
    var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
    function lb(a7) {
      switch (a7) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function mb(a7, b7) {
      return a7 == null || a7 === "http://www.w3.org/1999/xhtml" ? lb(b7) : a7 === "http://www.w3.org/2000/svg" && b7 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a7;
    }
    var nb;
    var ob = function(a7) {
      return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b7, c8, d7, e11) {
        MSApp.execUnsafeLocalFunction(function() {
          return a7(b7, c8, d7, e11);
        });
      } : a7;
    }(function(a7, b7) {
      if (a7.namespaceURI !== kb.svg || "innerHTML" in a7)
        a7.innerHTML = b7;
      else {
        nb = nb || document.createElement("div");
        nb.innerHTML = "<svg>" + b7.valueOf().toString() + "</svg>";
        for (b7 = nb.firstChild; a7.firstChild; )
          a7.removeChild(a7.firstChild);
        for (; b7.firstChild; )
          a7.appendChild(b7.firstChild);
      }
    });
    function pb(a7, b7) {
      if (b7) {
        var c8 = a7.firstChild;
        if (c8 && c8 === a7.lastChild && c8.nodeType === 3) {
          c8.nodeValue = b7;
          return;
        }
      }
      a7.textContent = b7;
    }
    var qb = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var rb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qb).forEach(function(a7) {
      rb.forEach(function(b7) {
        b7 = b7 + a7.charAt(0).toUpperCase() + a7.substring(1);
        qb[b7] = qb[a7];
      });
    });
    function sb(a7, b7, c8) {
      return b7 == null || typeof b7 === "boolean" || b7 === "" ? "" : c8 || typeof b7 !== "number" || b7 === 0 || qb.hasOwnProperty(a7) && qb[a7] ? ("" + b7).trim() : b7 + "px";
    }
    function tb(a7, b7) {
      a7 = a7.style;
      for (var c8 in b7)
        if (b7.hasOwnProperty(c8)) {
          var d7 = c8.indexOf("--") === 0, e11 = sb(c8, b7[c8], d7);
          c8 === "float" && (c8 = "cssFloat");
          d7 ? a7.setProperty(c8, e11) : a7[c8] = e11;
        }
    }
    var ub = m8({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function vb(a7, b7) {
      if (b7) {
        if (ub[a7] && (b7.children != null || b7.dangerouslySetInnerHTML != null))
          throw Error(y5(137, a7));
        if (b7.dangerouslySetInnerHTML != null) {
          if (b7.children != null)
            throw Error(y5(60));
          if (!(typeof b7.dangerouslySetInnerHTML === "object" && "__html" in b7.dangerouslySetInnerHTML))
            throw Error(y5(61));
        }
        if (b7.style != null && typeof b7.style !== "object")
          throw Error(y5(62));
      }
    }
    function wb(a7, b7) {
      if (a7.indexOf("-") === -1)
        return typeof b7.is === "string";
      switch (a7) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function xb(a7) {
      a7 = a7.target || a7.srcElement || window;
      a7.correspondingUseElement && (a7 = a7.correspondingUseElement);
      return a7.nodeType === 3 ? a7.parentNode : a7;
    }
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a7) {
      if (a7 = Cb(a7)) {
        if (typeof yb !== "function")
          throw Error(y5(280));
        var b7 = a7.stateNode;
        b7 && (b7 = Db(b7), yb(a7.stateNode, a7.type, b7));
      }
    }
    function Eb(a7) {
      zb ? Ab ? Ab.push(a7) : Ab = [a7] : zb = a7;
    }
    function Fb() {
      if (zb) {
        var a7 = zb, b7 = Ab;
        Ab = zb = null;
        Bb(a7);
        if (b7)
          for (a7 = 0; a7 < b7.length; a7++)
            Bb(b7[a7]);
      }
    }
    function Gb(a7, b7) {
      return a7(b7);
    }
    function Hb(a7, b7, c8, d7, e11) {
      return a7(b7, c8, d7, e11);
    }
    function Ib() {
    }
    var Jb = Gb;
    var Kb = false;
    var Lb = false;
    function Mb() {
      if (zb !== null || Ab !== null)
        Ib(), Fb();
    }
    function Nb(a7, b7, c8) {
      if (Lb)
        return a7(b7, c8);
      Lb = true;
      try {
        return Jb(a7, b7, c8);
      } finally {
        Lb = false, Mb();
      }
    }
    function Ob(a7, b7) {
      var c8 = a7.stateNode;
      if (c8 === null)
        return null;
      var d7 = Db(c8);
      if (d7 === null)
        return null;
      c8 = d7[b7];
      a:
        switch (b7) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d7 = !d7.disabled) || (a7 = a7.type, d7 = !(a7 === "button" || a7 === "input" || a7 === "select" || a7 === "textarea"));
            a7 = !d7;
            break a;
          default:
            a7 = false;
        }
      if (a7)
        return null;
      if (c8 && typeof c8 !== "function")
        throw Error(y5(231, b7, typeof c8));
      return c8;
    }
    var Pb = false;
    if (fa)
      try {
        Qb = {};
        Object.defineProperty(Qb, "passive", { get: function() {
          Pb = true;
        } });
        window.addEventListener("test", Qb, Qb);
        window.removeEventListener("test", Qb, Qb);
      } catch (a7) {
        Pb = false;
      }
    var Qb;
    function Rb(a7, b7, c8, d7, e11, f10, g6, h4, k4) {
      var l9 = Array.prototype.slice.call(arguments, 3);
      try {
        b7.apply(c8, l9);
      } catch (n6) {
        this.onError(n6);
      }
    }
    var Sb = false;
    var Tb = null;
    var Ub = false;
    var Vb = null;
    var Wb = { onError: function(a7) {
      Sb = true;
      Tb = a7;
    } };
    function Xb(a7, b7, c8, d7, e11, f10, g6, h4, k4) {
      Sb = false;
      Tb = null;
      Rb.apply(Wb, arguments);
    }
    function Yb(a7, b7, c8, d7, e11, f10, g6, h4, k4) {
      Xb.apply(this, arguments);
      if (Sb) {
        if (Sb) {
          var l9 = Tb;
          Sb = false;
          Tb = null;
        } else
          throw Error(y5(198));
        Ub || (Ub = true, Vb = l9);
      }
    }
    function Zb(a7) {
      var b7 = a7, c8 = a7;
      if (a7.alternate)
        for (; b7.return; )
          b7 = b7.return;
      else {
        a7 = b7;
        do
          b7 = a7, (b7.flags & 1026) !== 0 && (c8 = b7.return), a7 = b7.return;
        while (a7);
      }
      return b7.tag === 3 ? c8 : null;
    }
    function $b(a7) {
      if (a7.tag === 13) {
        var b7 = a7.memoizedState;
        b7 === null && (a7 = a7.alternate, a7 !== null && (b7 = a7.memoizedState));
        if (b7 !== null)
          return b7.dehydrated;
      }
      return null;
    }
    function ac(a7) {
      if (Zb(a7) !== a7)
        throw Error(y5(188));
    }
    function bc(a7) {
      var b7 = a7.alternate;
      if (!b7) {
        b7 = Zb(a7);
        if (b7 === null)
          throw Error(y5(188));
        return b7 !== a7 ? null : a7;
      }
      for (var c8 = a7, d7 = b7; ; ) {
        var e11 = c8.return;
        if (e11 === null)
          break;
        var f10 = e11.alternate;
        if (f10 === null) {
          d7 = e11.return;
          if (d7 !== null) {
            c8 = d7;
            continue;
          }
          break;
        }
        if (e11.child === f10.child) {
          for (f10 = e11.child; f10; ) {
            if (f10 === c8)
              return ac(e11), a7;
            if (f10 === d7)
              return ac(e11), b7;
            f10 = f10.sibling;
          }
          throw Error(y5(188));
        }
        if (c8.return !== d7.return)
          c8 = e11, d7 = f10;
        else {
          for (var g6 = false, h4 = e11.child; h4; ) {
            if (h4 === c8) {
              g6 = true;
              c8 = e11;
              d7 = f10;
              break;
            }
            if (h4 === d7) {
              g6 = true;
              d7 = e11;
              c8 = f10;
              break;
            }
            h4 = h4.sibling;
          }
          if (!g6) {
            for (h4 = f10.child; h4; ) {
              if (h4 === c8) {
                g6 = true;
                c8 = f10;
                d7 = e11;
                break;
              }
              if (h4 === d7) {
                g6 = true;
                d7 = f10;
                c8 = e11;
                break;
              }
              h4 = h4.sibling;
            }
            if (!g6)
              throw Error(y5(189));
          }
        }
        if (c8.alternate !== d7)
          throw Error(y5(190));
      }
      if (c8.tag !== 3)
        throw Error(y5(188));
      return c8.stateNode.current === c8 ? a7 : b7;
    }
    function cc(a7) {
      a7 = bc(a7);
      if (!a7)
        return null;
      for (var b7 = a7; ; ) {
        if (b7.tag === 5 || b7.tag === 6)
          return b7;
        if (b7.child)
          b7.child.return = b7, b7 = b7.child;
        else {
          if (b7 === a7)
            break;
          for (; !b7.sibling; ) {
            if (!b7.return || b7.return === a7)
              return null;
            b7 = b7.return;
          }
          b7.sibling.return = b7.return;
          b7 = b7.sibling;
        }
      }
      return null;
    }
    function dc(a7, b7) {
      for (var c8 = a7.alternate; b7 !== null; ) {
        if (b7 === a7 || b7 === c8)
          return true;
        b7 = b7.return;
      }
      return false;
    }
    var ec;
    var fc;
    var gc;
    var hc;
    var ic = false;
    var jc = [];
    var kc = null;
    var lc = null;
    var mc = null;
    var nc = /* @__PURE__ */ new Map();
    var oc = /* @__PURE__ */ new Map();
    var pc = [];
    var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function rc(a7, b7, c8, d7, e11) {
      return { blockedOn: a7, domEventName: b7, eventSystemFlags: c8 | 16, nativeEvent: e11, targetContainers: [d7] };
    }
    function sc(a7, b7) {
      switch (a7) {
        case "focusin":
        case "focusout":
          kc = null;
          break;
        case "dragenter":
        case "dragleave":
          lc = null;
          break;
        case "mouseover":
        case "mouseout":
          mc = null;
          break;
        case "pointerover":
        case "pointerout":
          nc.delete(b7.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          oc.delete(b7.pointerId);
      }
    }
    function tc(a7, b7, c8, d7, e11, f10) {
      if (a7 === null || a7.nativeEvent !== f10)
        return a7 = rc(b7, c8, d7, e11, f10), b7 !== null && (b7 = Cb(b7), b7 !== null && fc(b7)), a7;
      a7.eventSystemFlags |= d7;
      b7 = a7.targetContainers;
      e11 !== null && b7.indexOf(e11) === -1 && b7.push(e11);
      return a7;
    }
    function uc(a7, b7, c8, d7, e11) {
      switch (b7) {
        case "focusin":
          return kc = tc(kc, a7, b7, c8, d7, e11), true;
        case "dragenter":
          return lc = tc(lc, a7, b7, c8, d7, e11), true;
        case "mouseover":
          return mc = tc(mc, a7, b7, c8, d7, e11), true;
        case "pointerover":
          var f10 = e11.pointerId;
          nc.set(f10, tc(nc.get(f10) || null, a7, b7, c8, d7, e11));
          return true;
        case "gotpointercapture":
          return f10 = e11.pointerId, oc.set(f10, tc(oc.get(f10) || null, a7, b7, c8, d7, e11)), true;
      }
      return false;
    }
    function vc(a7) {
      var b7 = wc(a7.target);
      if (b7 !== null) {
        var c8 = Zb(b7);
        if (c8 !== null) {
          if (b7 = c8.tag, b7 === 13) {
            if (b7 = $b(c8), b7 !== null) {
              a7.blockedOn = b7;
              hc(a7.lanePriority, function() {
                r12.unstable_runWithPriority(a7.priority, function() {
                  gc(c8);
                });
              });
              return;
            }
          } else if (b7 === 3 && c8.stateNode.hydrate) {
            a7.blockedOn = c8.tag === 3 ? c8.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a7.blockedOn = null;
    }
    function xc(a7) {
      if (a7.blockedOn !== null)
        return false;
      for (var b7 = a7.targetContainers; 0 < b7.length; ) {
        var c8 = yc(a7.domEventName, a7.eventSystemFlags, b7[0], a7.nativeEvent);
        if (c8 !== null)
          return b7 = Cb(c8), b7 !== null && fc(b7), a7.blockedOn = c8, false;
        b7.shift();
      }
      return true;
    }
    function zc(a7, b7, c8) {
      xc(a7) && c8.delete(b7);
    }
    function Ac() {
      for (ic = false; 0 < jc.length; ) {
        var a7 = jc[0];
        if (a7.blockedOn !== null) {
          a7 = Cb(a7.blockedOn);
          a7 !== null && ec(a7);
          break;
        }
        for (var b7 = a7.targetContainers; 0 < b7.length; ) {
          var c8 = yc(a7.domEventName, a7.eventSystemFlags, b7[0], a7.nativeEvent);
          if (c8 !== null) {
            a7.blockedOn = c8;
            break;
          }
          b7.shift();
        }
        a7.blockedOn === null && jc.shift();
      }
      kc !== null && xc(kc) && (kc = null);
      lc !== null && xc(lc) && (lc = null);
      mc !== null && xc(mc) && (mc = null);
      nc.forEach(zc);
      oc.forEach(zc);
    }
    function Bc(a7, b7) {
      a7.blockedOn === b7 && (a7.blockedOn = null, ic || (ic = true, r12.unstable_scheduleCallback(r12.unstable_NormalPriority, Ac)));
    }
    function Cc(a7) {
      function b7(b8) {
        return Bc(b8, a7);
      }
      if (0 < jc.length) {
        Bc(jc[0], a7);
        for (var c8 = 1; c8 < jc.length; c8++) {
          var d7 = jc[c8];
          d7.blockedOn === a7 && (d7.blockedOn = null);
        }
      }
      kc !== null && Bc(kc, a7);
      lc !== null && Bc(lc, a7);
      mc !== null && Bc(mc, a7);
      nc.forEach(b7);
      oc.forEach(b7);
      for (c8 = 0; c8 < pc.length; c8++)
        d7 = pc[c8], d7.blockedOn === a7 && (d7.blockedOn = null);
      for (; 0 < pc.length && (c8 = pc[0], c8.blockedOn === null); )
        vc(c8), c8.blockedOn === null && pc.shift();
    }
    function Dc(a7, b7) {
      var c8 = {};
      c8[a7.toLowerCase()] = b7.toLowerCase();
      c8["Webkit" + a7] = "webkit" + b7;
      c8["Moz" + a7] = "moz" + b7;
      return c8;
    }
    var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") };
    var Fc = {};
    var Gc = {};
    fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
    function Hc(a7) {
      if (Fc[a7])
        return Fc[a7];
      if (!Ec[a7])
        return a7;
      var b7 = Ec[a7], c8;
      for (c8 in b7)
        if (b7.hasOwnProperty(c8) && c8 in Gc)
          return Fc[a7] = b7[c8];
      return a7;
    }
    var Ic = Hc("animationend");
    var Jc = Hc("animationiteration");
    var Kc = Hc("animationstart");
    var Lc = Hc("transitionend");
    var Mc = /* @__PURE__ */ new Map();
    var Nc = /* @__PURE__ */ new Map();
    var Oc = [
      "abort",
      "abort",
      Ic,
      "animationEnd",
      Jc,
      "animationIteration",
      Kc,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      Lc,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function Pc(a7, b7) {
      for (var c8 = 0; c8 < a7.length; c8 += 2) {
        var d7 = a7[c8], e11 = a7[c8 + 1];
        e11 = "on" + (e11[0].toUpperCase() + e11.slice(1));
        Nc.set(d7, b7);
        Mc.set(d7, e11);
        da(e11, [d7]);
      }
    }
    var Qc = r12.unstable_now;
    Qc();
    var F5 = 8;
    function Rc(a7) {
      if ((1 & a7) !== 0)
        return F5 = 15, 1;
      if ((2 & a7) !== 0)
        return F5 = 14, 2;
      if ((4 & a7) !== 0)
        return F5 = 13, 4;
      var b7 = 24 & a7;
      if (b7 !== 0)
        return F5 = 12, b7;
      if ((a7 & 32) !== 0)
        return F5 = 11, 32;
      b7 = 192 & a7;
      if (b7 !== 0)
        return F5 = 10, b7;
      if ((a7 & 256) !== 0)
        return F5 = 9, 256;
      b7 = 3584 & a7;
      if (b7 !== 0)
        return F5 = 8, b7;
      if ((a7 & 4096) !== 0)
        return F5 = 7, 4096;
      b7 = 4186112 & a7;
      if (b7 !== 0)
        return F5 = 6, b7;
      b7 = 62914560 & a7;
      if (b7 !== 0)
        return F5 = 5, b7;
      if (a7 & 67108864)
        return F5 = 4, 67108864;
      if ((a7 & 134217728) !== 0)
        return F5 = 3, 134217728;
      b7 = 805306368 & a7;
      if (b7 !== 0)
        return F5 = 2, b7;
      if ((1073741824 & a7) !== 0)
        return F5 = 1, 1073741824;
      F5 = 8;
      return a7;
    }
    function Sc(a7) {
      switch (a7) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function Tc(a7) {
      switch (a7) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(y5(358, a7));
      }
    }
    function Uc(a7, b7) {
      var c8 = a7.pendingLanes;
      if (c8 === 0)
        return F5 = 0;
      var d7 = 0, e11 = 0, f10 = a7.expiredLanes, g6 = a7.suspendedLanes, h4 = a7.pingedLanes;
      if (f10 !== 0)
        d7 = f10, e11 = F5 = 15;
      else if (f10 = c8 & 134217727, f10 !== 0) {
        var k4 = f10 & ~g6;
        k4 !== 0 ? (d7 = Rc(k4), e11 = F5) : (h4 &= f10, h4 !== 0 && (d7 = Rc(h4), e11 = F5));
      } else
        f10 = c8 & ~g6, f10 !== 0 ? (d7 = Rc(f10), e11 = F5) : h4 !== 0 && (d7 = Rc(h4), e11 = F5);
      if (d7 === 0)
        return 0;
      d7 = 31 - Vc(d7);
      d7 = c8 & ((0 > d7 ? 0 : 1 << d7) << 1) - 1;
      if (b7 !== 0 && b7 !== d7 && (b7 & g6) === 0) {
        Rc(b7);
        if (e11 <= F5)
          return b7;
        F5 = e11;
      }
      b7 = a7.entangledLanes;
      if (b7 !== 0)
        for (a7 = a7.entanglements, b7 &= d7; 0 < b7; )
          c8 = 31 - Vc(b7), e11 = 1 << c8, d7 |= a7[c8], b7 &= ~e11;
      return d7;
    }
    function Wc(a7) {
      a7 = a7.pendingLanes & -1073741825;
      return a7 !== 0 ? a7 : a7 & 1073741824 ? 1073741824 : 0;
    }
    function Xc(a7, b7) {
      switch (a7) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a7 = Yc(24 & ~b7), a7 === 0 ? Xc(10, b7) : a7;
        case 10:
          return a7 = Yc(192 & ~b7), a7 === 0 ? Xc(8, b7) : a7;
        case 8:
          return a7 = Yc(3584 & ~b7), a7 === 0 && (a7 = Yc(4186112 & ~b7), a7 === 0 && (a7 = 512)), a7;
        case 2:
          return b7 = Yc(805306368 & ~b7), b7 === 0 && (b7 = 268435456), b7;
      }
      throw Error(y5(358, a7));
    }
    function Yc(a7) {
      return a7 & -a7;
    }
    function Zc(a7) {
      for (var b7 = [], c8 = 0; 31 > c8; c8++)
        b7.push(a7);
      return b7;
    }
    function $c(a7, b7, c8) {
      a7.pendingLanes |= b7;
      var d7 = b7 - 1;
      a7.suspendedLanes &= d7;
      a7.pingedLanes &= d7;
      a7 = a7.eventTimes;
      b7 = 31 - Vc(b7);
      a7[b7] = c8;
    }
    var Vc = Math.clz32 ? Math.clz32 : ad;
    var bd = Math.log;
    var cd = Math.LN2;
    function ad(a7) {
      return a7 === 0 ? 32 : 31 - (bd(a7) / cd | 0) | 0;
    }
    var dd = r12.unstable_UserBlockingPriority;
    var ed = r12.unstable_runWithPriority;
    var fd = true;
    function gd(a7, b7, c8, d7) {
      Kb || Ib();
      var e11 = hd, f10 = Kb;
      Kb = true;
      try {
        Hb(e11, a7, b7, c8, d7);
      } finally {
        (Kb = f10) || Mb();
      }
    }
    function id(a7, b7, c8, d7) {
      ed(dd, hd.bind(null, a7, b7, c8, d7));
    }
    function hd(a7, b7, c8, d7) {
      if (fd) {
        var e11;
        if ((e11 = (b7 & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a7))
          a7 = rc(null, a7, b7, c8, d7), jc.push(a7);
        else {
          var f10 = yc(a7, b7, c8, d7);
          if (f10 === null)
            e11 && sc(a7, d7);
          else {
            if (e11) {
              if (-1 < qc.indexOf(a7)) {
                a7 = rc(f10, a7, b7, c8, d7);
                jc.push(a7);
                return;
              }
              if (uc(f10, a7, b7, c8, d7))
                return;
              sc(a7, d7);
            }
            jd(a7, b7, d7, null, c8);
          }
        }
      }
    }
    function yc(a7, b7, c8, d7) {
      var e11 = xb(d7);
      e11 = wc(e11);
      if (e11 !== null) {
        var f10 = Zb(e11);
        if (f10 === null)
          e11 = null;
        else {
          var g6 = f10.tag;
          if (g6 === 13) {
            e11 = $b(f10);
            if (e11 !== null)
              return e11;
            e11 = null;
          } else if (g6 === 3) {
            if (f10.stateNode.hydrate)
              return f10.tag === 3 ? f10.stateNode.containerInfo : null;
            e11 = null;
          } else
            f10 !== e11 && (e11 = null);
        }
      }
      jd(a7, b7, d7, e11, c8);
      return null;
    }
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md)
        return md;
      var a7, b7 = ld, c8 = b7.length, d7, e11 = "value" in kd ? kd.value : kd.textContent, f10 = e11.length;
      for (a7 = 0; a7 < c8 && b7[a7] === e11[a7]; a7++)
        ;
      var g6 = c8 - a7;
      for (d7 = 1; d7 <= g6 && b7[c8 - d7] === e11[f10 - d7]; d7++)
        ;
      return md = e11.slice(a7, 1 < d7 ? 1 - d7 : void 0);
    }
    function od(a7) {
      var b7 = a7.keyCode;
      "charCode" in a7 ? (a7 = a7.charCode, a7 === 0 && b7 === 13 && (a7 = 13)) : a7 = b7;
      a7 === 10 && (a7 = 13);
      return 32 <= a7 || a7 === 13 ? a7 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a7) {
      function b7(b8, d7, e11, f10, g6) {
        this._reactName = b8;
        this._targetInst = e11;
        this.type = d7;
        this.nativeEvent = f10;
        this.target = g6;
        this.currentTarget = null;
        for (var c8 in a7)
          a7.hasOwnProperty(c8) && (b8 = a7[c8], this[c8] = b8 ? b8(f10) : f10[c8]);
        this.isDefaultPrevented = (f10.defaultPrevented != null ? f10.defaultPrevented : f10.returnValue === false) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      m8(b7.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a8 = this.nativeEvent;
        a8 && (a8.preventDefault ? a8.preventDefault() : typeof a8.returnValue !== "unknown" && (a8.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a8 = this.nativeEvent;
        a8 && (a8.stopPropagation ? a8.stopPropagation() : typeof a8.cancelBubble !== "unknown" && (a8.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b7;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a7) {
      return a7.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 };
    var td = rd(sd);
    var ud = m8({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = m8({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a7) {
      return a7.relatedTarget === void 0 ? a7.fromElement === a7.srcElement ? a7.toElement : a7.fromElement : a7.relatedTarget;
    }, movementX: function(a7) {
      if ("movementX" in a7)
        return a7.movementX;
      a7 !== yd && (yd && a7.type === "mousemove" ? (wd = a7.screenX - yd.screenX, xd = a7.screenY - yd.screenY) : xd = wd = 0, yd = a7);
      return wd;
    }, movementY: function(a7) {
      return "movementY" in a7 ? a7.movementY : xd;
    } });
    var Bd = rd(Ad);
    var Cd = m8({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = m8({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = m8({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = m8({}, sd, { clipboardData: function(a7) {
      return "clipboardData" in a7 ? a7.clipboardData : window.clipboardData;
    } });
    var Jd = rd(Id);
    var Kd = m8({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a7) {
      var b7 = this.nativeEvent;
      return b7.getModifierState ? b7.getModifierState(a7) : (a7 = Od[a7]) ? !!b7[a7] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = m8({}, ud, { key: function(a7) {
      if (a7.key) {
        var b7 = Md[a7.key] || a7.key;
        if (b7 !== "Unidentified")
          return b7;
      }
      return a7.type === "keypress" ? (a7 = od(a7), a7 === 13 ? "Enter" : String.fromCharCode(a7)) : a7.type === "keydown" || a7.type === "keyup" ? Nd[a7.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a7) {
      return a7.type === "keypress" ? od(a7) : 0;
    }, keyCode: function(a7) {
      return a7.type === "keydown" || a7.type === "keyup" ? a7.keyCode : 0;
    }, which: function(a7) {
      return a7.type === "keypress" ? od(a7) : a7.type === "keydown" || a7.type === "keyup" ? a7.keyCode : 0;
    } });
    var Rd = rd(Qd);
    var Sd = m8({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    var Td = rd(Sd);
    var Ud = m8({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    var Vd = rd(Ud);
    var Wd = m8({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = m8({}, Ad, {
      deltaX: function(a7) {
        return "deltaX" in a7 ? a7.deltaX : "wheelDeltaX" in a7 ? -a7.wheelDeltaX : 0;
      },
      deltaY: function(a7) {
        return "deltaY" in a7 ? a7.deltaY : "wheelDeltaY" in a7 ? -a7.wheelDeltaY : "wheelDelta" in a7 ? -a7.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = fa && "CompositionEvent" in window;
    var be2 = null;
    fa && "documentMode" in document && (be2 = document.documentMode);
    var ce2 = fa && "TextEvent" in window && !be2;
    var de = fa && (!ae || be2 && 8 < be2 && 11 >= be2);
    var ee = String.fromCharCode(32);
    var fe2 = false;
    function ge2(a7, b7) {
      switch (a7) {
        case "keyup":
          return $d.indexOf(b7.keyCode) !== -1;
        case "keydown":
          return b7.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a7) {
      a7 = a7.detail;
      return typeof a7 === "object" && "data" in a7 ? a7.data : null;
    }
    var ie2 = false;
    function je(a7, b7) {
      switch (a7) {
        case "compositionend":
          return he(b7);
        case "keypress":
          if (b7.which !== 32)
            return null;
          fe2 = true;
          return ee;
        case "textInput":
          return a7 = b7.data, a7 === ee && fe2 ? null : a7;
        default:
          return null;
      }
    }
    function ke(a7, b7) {
      if (ie2)
        return a7 === "compositionend" || !ae && ge2(a7, b7) ? (a7 = nd(), md = ld = kd = null, ie2 = false, a7) : null;
      switch (a7) {
        case "paste":
          return null;
        case "keypress":
          if (!(b7.ctrlKey || b7.altKey || b7.metaKey) || b7.ctrlKey && b7.altKey) {
            if (b7.char && 1 < b7.char.length)
              return b7.char;
            if (b7.which)
              return String.fromCharCode(b7.which);
          }
          return null;
        case "compositionend":
          return de && b7.locale !== "ko" ? null : b7.data;
        default:
          return null;
      }
    }
    var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me2(a7) {
      var b7 = a7 && a7.nodeName && a7.nodeName.toLowerCase();
      return b7 === "input" ? !!le2[a7.type] : b7 === "textarea" ? true : false;
    }
    function ne2(a7, b7, c8, d7) {
      Eb(d7);
      b7 = oe2(b7, "onChange");
      0 < b7.length && (c8 = new td("onChange", "change", null, c8, d7), a7.push({ event: c8, listeners: b7 }));
    }
    var pe = null;
    var qe = null;
    function re3(a7) {
      se2(a7, 0);
    }
    function te(a7) {
      var b7 = ue2(a7);
      if (Wa(b7))
        return a7;
    }
    function ve(a7, b7) {
      if (a7 === "change")
        return b7;
    }
    var we = false;
    if (fa) {
      if (fa) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = typeof ze.oninput === "function";
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a7) {
      if (a7.propertyName === "value" && te(qe)) {
        var b7 = [];
        ne2(b7, qe, a7, xb(a7));
        a7 = re3;
        if (Kb)
          a7(b7);
        else {
          Kb = true;
          try {
            Gb(a7, b7);
          } finally {
            Kb = false, Mb();
          }
        }
      }
    }
    function Ce(a7, b7, c8) {
      a7 === "focusin" ? (Ae(), pe = b7, qe = c8, pe.attachEvent("onpropertychange", Be)) : a7 === "focusout" && Ae();
    }
    function De(a7) {
      if (a7 === "selectionchange" || a7 === "keyup" || a7 === "keydown")
        return te(qe);
    }
    function Ee(a7, b7) {
      if (a7 === "click")
        return te(b7);
    }
    function Fe(a7, b7) {
      if (a7 === "input" || a7 === "change")
        return te(b7);
    }
    function Ge(a7, b7) {
      return a7 === b7 && (a7 !== 0 || 1 / a7 === 1 / b7) || a7 !== a7 && b7 !== b7;
    }
    var He = typeof Object.is === "function" ? Object.is : Ge;
    var Ie = Object.prototype.hasOwnProperty;
    function Je(a7, b7) {
      if (He(a7, b7))
        return true;
      if (typeof a7 !== "object" || a7 === null || typeof b7 !== "object" || b7 === null)
        return false;
      var c8 = Object.keys(a7), d7 = Object.keys(b7);
      if (c8.length !== d7.length)
        return false;
      for (d7 = 0; d7 < c8.length; d7++)
        if (!Ie.call(b7, c8[d7]) || !He(a7[c8[d7]], b7[c8[d7]]))
          return false;
      return true;
    }
    function Ke(a7) {
      for (; a7 && a7.firstChild; )
        a7 = a7.firstChild;
      return a7;
    }
    function Le(a7, b7) {
      var c8 = Ke(a7);
      a7 = 0;
      for (var d7; c8; ) {
        if (c8.nodeType === 3) {
          d7 = a7 + c8.textContent.length;
          if (a7 <= b7 && d7 >= b7)
            return { node: c8, offset: b7 - a7 };
          a7 = d7;
        }
        a: {
          for (; c8; ) {
            if (c8.nextSibling) {
              c8 = c8.nextSibling;
              break a;
            }
            c8 = c8.parentNode;
          }
          c8 = void 0;
        }
        c8 = Ke(c8);
      }
    }
    function Me(a7, b7) {
      return a7 && b7 ? a7 === b7 ? true : a7 && a7.nodeType === 3 ? false : b7 && b7.nodeType === 3 ? Me(a7, b7.parentNode) : "contains" in a7 ? a7.contains(b7) : a7.compareDocumentPosition ? !!(a7.compareDocumentPosition(b7) & 16) : false : false;
    }
    function Ne() {
      for (var a7 = window, b7 = Xa(); b7 instanceof a7.HTMLIFrameElement; ) {
        try {
          var c8 = typeof b7.contentWindow.location.href === "string";
        } catch (d7) {
          c8 = false;
        }
        if (c8)
          a7 = b7.contentWindow;
        else
          break;
        b7 = Xa(a7.document);
      }
      return b7;
    }
    function Oe(a7) {
      var b7 = a7 && a7.nodeName && a7.nodeName.toLowerCase();
      return b7 && (b7 === "input" && (a7.type === "text" || a7.type === "search" || a7.type === "tel" || a7.type === "url" || a7.type === "password") || b7 === "textarea" || a7.contentEditable === "true");
    }
    var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te2 = false;
    function Ue(a7, b7, c8) {
      var d7 = c8.window === c8 ? c8.document : c8.nodeType === 9 ? c8 : c8.ownerDocument;
      Te2 || Qe == null || Qe !== Xa(d7) || (d7 = Qe, "selectionStart" in d7 && Oe(d7) ? d7 = { start: d7.selectionStart, end: d7.selectionEnd } : (d7 = (d7.ownerDocument && d7.ownerDocument.defaultView || window).getSelection(), d7 = { anchorNode: d7.anchorNode, anchorOffset: d7.anchorOffset, focusNode: d7.focusNode, focusOffset: d7.focusOffset }), Se && Je(Se, d7) || (Se = d7, d7 = oe2(Re, "onSelect"), 0 < d7.length && (b7 = new td("onSelect", "select", null, b7, c8), a7.push({ event: b7, listeners: d7 }), b7.target = Qe)));
    }
    Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
    Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    Pc(Oc, 2);
    for (Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
      Nc.set(Ve[We], 0);
    var Ve;
    var We;
    ea("onMouseEnter", ["mouseout", "mouseover"]);
    ea("onMouseLeave", ["mouseout", "mouseover"]);
    ea("onPointerEnter", ["pointerout", "pointerover"]);
    ea("onPointerLeave", ["pointerout", "pointerover"]);
    da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
    function Ze(a7, b7, c8) {
      var d7 = a7.type || "unknown-event";
      a7.currentTarget = c8;
      Yb(d7, b7, void 0, a7);
      a7.currentTarget = null;
    }
    function se2(a7, b7) {
      b7 = (b7 & 4) !== 0;
      for (var c8 = 0; c8 < a7.length; c8++) {
        var d7 = a7[c8], e11 = d7.event;
        d7 = d7.listeners;
        a: {
          var f10 = void 0;
          if (b7)
            for (var g6 = d7.length - 1; 0 <= g6; g6--) {
              var h4 = d7[g6], k4 = h4.instance, l9 = h4.currentTarget;
              h4 = h4.listener;
              if (k4 !== f10 && e11.isPropagationStopped())
                break a;
              Ze(e11, h4, l9);
              f10 = k4;
            }
          else
            for (g6 = 0; g6 < d7.length; g6++) {
              h4 = d7[g6];
              k4 = h4.instance;
              l9 = h4.currentTarget;
              h4 = h4.listener;
              if (k4 !== f10 && e11.isPropagationStopped())
                break a;
              Ze(e11, h4, l9);
              f10 = k4;
            }
        }
      }
      if (Ub)
        throw a7 = Vb, Ub = false, Vb = null, a7;
    }
    function G4(a7, b7) {
      var c8 = $e(b7), d7 = a7 + "__bubble";
      c8.has(d7) || (af(b7, a7, 2, false), c8.add(d7));
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function cf(a7) {
      a7[bf] || (a7[bf] = true, ba.forEach(function(b7) {
        Ye.has(b7) || df(b7, false, a7, null);
        df(b7, true, a7, null);
      }));
    }
    function df(a7, b7, c8, d7) {
      var e11 = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f10 = c8;
      a7 === "selectionchange" && c8.nodeType !== 9 && (f10 = c8.ownerDocument);
      if (d7 !== null && !b7 && Ye.has(a7)) {
        if (a7 !== "scroll")
          return;
        e11 |= 2;
        f10 = d7;
      }
      var g6 = $e(f10), h4 = a7 + "__" + (b7 ? "capture" : "bubble");
      g6.has(h4) || (b7 && (e11 |= 4), af(f10, a7, e11, b7), g6.add(h4));
    }
    function af(a7, b7, c8, d7) {
      var e11 = Nc.get(b7);
      switch (e11 === void 0 ? 2 : e11) {
        case 0:
          e11 = gd;
          break;
        case 1:
          e11 = id;
          break;
        default:
          e11 = hd;
      }
      c8 = e11.bind(null, b7, c8, a7);
      e11 = void 0;
      !Pb || b7 !== "touchstart" && b7 !== "touchmove" && b7 !== "wheel" || (e11 = true);
      d7 ? e11 !== void 0 ? a7.addEventListener(b7, c8, { capture: true, passive: e11 }) : a7.addEventListener(b7, c8, true) : e11 !== void 0 ? a7.addEventListener(b7, c8, { passive: e11 }) : a7.addEventListener(b7, c8, false);
    }
    function jd(a7, b7, c8, d7, e11) {
      var f10 = d7;
      if ((b7 & 1) === 0 && (b7 & 2) === 0 && d7 !== null)
        a:
          for (; ; ) {
            if (d7 === null)
              return;
            var g6 = d7.tag;
            if (g6 === 3 || g6 === 4) {
              var h4 = d7.stateNode.containerInfo;
              if (h4 === e11 || h4.nodeType === 8 && h4.parentNode === e11)
                break;
              if (g6 === 4)
                for (g6 = d7.return; g6 !== null; ) {
                  var k4 = g6.tag;
                  if (k4 === 3 || k4 === 4) {
                    if (k4 = g6.stateNode.containerInfo, k4 === e11 || k4.nodeType === 8 && k4.parentNode === e11)
                      return;
                  }
                  g6 = g6.return;
                }
              for (; h4 !== null; ) {
                g6 = wc(h4);
                if (g6 === null)
                  return;
                k4 = g6.tag;
                if (k4 === 5 || k4 === 6) {
                  d7 = f10 = g6;
                  continue a;
                }
                h4 = h4.parentNode;
              }
            }
            d7 = d7.return;
          }
      Nb(function() {
        var d8 = f10, e12 = xb(c8), g7 = [];
        a: {
          var h5 = Mc.get(a7);
          if (h5 !== void 0) {
            var k5 = td, x6 = a7;
            switch (a7) {
              case "keypress":
                if (od(c8) === 0)
                  break a;
              case "keydown":
              case "keyup":
                k5 = Rd;
                break;
              case "focusin":
                x6 = "focus";
                k5 = Fd;
                break;
              case "focusout":
                x6 = "blur";
                k5 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k5 = Fd;
                break;
              case "click":
                if (c8.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k5 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k5 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k5 = Vd;
                break;
              case Ic:
              case Jc:
              case Kc:
                k5 = Hd;
                break;
              case Lc:
                k5 = Xd;
                break;
              case "scroll":
                k5 = vd;
                break;
              case "wheel":
                k5 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k5 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k5 = Td;
            }
            var w6 = (b7 & 4) !== 0, z3 = !w6 && a7 === "scroll", u4 = w6 ? h5 !== null ? h5 + "Capture" : null : h5;
            w6 = [];
            for (var t12 = d8, q3; t12 !== null; ) {
              q3 = t12;
              var v6 = q3.stateNode;
              q3.tag === 5 && v6 !== null && (q3 = v6, u4 !== null && (v6 = Ob(t12, u4), v6 != null && w6.push(ef(t12, v6, q3))));
              if (z3)
                break;
              t12 = t12.return;
            }
            0 < w6.length && (h5 = new k5(h5, x6, null, c8, e12), g7.push({ event: h5, listeners: w6 }));
          }
        }
        if ((b7 & 7) === 0) {
          a: {
            h5 = a7 === "mouseover" || a7 === "pointerover";
            k5 = a7 === "mouseout" || a7 === "pointerout";
            if (h5 && (b7 & 16) === 0 && (x6 = c8.relatedTarget || c8.fromElement) && (wc(x6) || x6[ff]))
              break a;
            if (k5 || h5) {
              h5 = e12.window === e12 ? e12 : (h5 = e12.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
              if (k5) {
                if (x6 = c8.relatedTarget || c8.toElement, k5 = d8, x6 = x6 ? wc(x6) : null, x6 !== null && (z3 = Zb(x6), x6 !== z3 || x6.tag !== 5 && x6.tag !== 6))
                  x6 = null;
              } else
                k5 = null, x6 = d8;
              if (k5 !== x6) {
                w6 = Bd;
                v6 = "onMouseLeave";
                u4 = "onMouseEnter";
                t12 = "mouse";
                if (a7 === "pointerout" || a7 === "pointerover")
                  w6 = Td, v6 = "onPointerLeave", u4 = "onPointerEnter", t12 = "pointer";
                z3 = k5 == null ? h5 : ue2(k5);
                q3 = x6 == null ? h5 : ue2(x6);
                h5 = new w6(v6, t12 + "leave", k5, c8, e12);
                h5.target = z3;
                h5.relatedTarget = q3;
                v6 = null;
                wc(e12) === d8 && (w6 = new w6(u4, t12 + "enter", x6, c8, e12), w6.target = q3, w6.relatedTarget = z3, v6 = w6);
                z3 = v6;
                if (k5 && x6)
                  b: {
                    w6 = k5;
                    u4 = x6;
                    t12 = 0;
                    for (q3 = w6; q3; q3 = gf(q3))
                      t12++;
                    q3 = 0;
                    for (v6 = u4; v6; v6 = gf(v6))
                      q3++;
                    for (; 0 < t12 - q3; )
                      w6 = gf(w6), t12--;
                    for (; 0 < q3 - t12; )
                      u4 = gf(u4), q3--;
                    for (; t12--; ) {
                      if (w6 === u4 || u4 !== null && w6 === u4.alternate)
                        break b;
                      w6 = gf(w6);
                      u4 = gf(u4);
                    }
                    w6 = null;
                  }
                else
                  w6 = null;
                k5 !== null && hf(g7, h5, k5, w6, false);
                x6 !== null && z3 !== null && hf(g7, z3, x6, w6, true);
              }
            }
          }
          a: {
            h5 = d8 ? ue2(d8) : window;
            k5 = h5.nodeName && h5.nodeName.toLowerCase();
            if (k5 === "select" || k5 === "input" && h5.type === "file")
              var J4 = ve;
            else if (me2(h5))
              if (we)
                J4 = Fe;
              else {
                J4 = De;
                var K3 = Ce;
              }
            else
              (k5 = h5.nodeName) && k5.toLowerCase() === "input" && (h5.type === "checkbox" || h5.type === "radio") && (J4 = Ee);
            if (J4 && (J4 = J4(a7, d8))) {
              ne2(g7, J4, c8, e12);
              break a;
            }
            K3 && K3(a7, h5, d8);
            a7 === "focusout" && (K3 = h5._wrapperState) && K3.controlled && h5.type === "number" && bb(h5, "number", h5.value);
          }
          K3 = d8 ? ue2(d8) : window;
          switch (a7) {
            case "focusin":
              if (me2(K3) || K3.contentEditable === "true")
                Qe = K3, Re = d8, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te2 = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te2 = false;
              Ue(g7, c8, e12);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g7, c8, e12);
          }
          var Q;
          if (ae)
            b: {
              switch (a7) {
                case "compositionstart":
                  var L4 = "onCompositionStart";
                  break b;
                case "compositionend":
                  L4 = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  L4 = "onCompositionUpdate";
                  break b;
              }
              L4 = void 0;
            }
          else
            ie2 ? ge2(a7, c8) && (L4 = "onCompositionEnd") : a7 === "keydown" && c8.keyCode === 229 && (L4 = "onCompositionStart");
          L4 && (de && c8.locale !== "ko" && (ie2 || L4 !== "onCompositionStart" ? L4 === "onCompositionEnd" && ie2 && (Q = nd()) : (kd = e12, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), K3 = oe2(d8, L4), 0 < K3.length && (L4 = new Ld(L4, a7, null, c8, e12), g7.push({ event: L4, listeners: K3 }), Q ? L4.data = Q : (Q = he(c8), Q !== null && (L4.data = Q))));
          if (Q = ce2 ? je(a7, c8) : ke(a7, c8))
            d8 = oe2(d8, "onBeforeInput"), 0 < d8.length && (e12 = new Ld("onBeforeInput", "beforeinput", null, c8, e12), g7.push({ event: e12, listeners: d8 }), e12.data = Q);
        }
        se2(g7, b7);
      });
    }
    function ef(a7, b7, c8) {
      return { instance: a7, listener: b7, currentTarget: c8 };
    }
    function oe2(a7, b7) {
      for (var c8 = b7 + "Capture", d7 = []; a7 !== null; ) {
        var e11 = a7, f10 = e11.stateNode;
        e11.tag === 5 && f10 !== null && (e11 = f10, f10 = Ob(a7, c8), f10 != null && d7.unshift(ef(a7, f10, e11)), f10 = Ob(a7, b7), f10 != null && d7.push(ef(a7, f10, e11)));
        a7 = a7.return;
      }
      return d7;
    }
    function gf(a7) {
      if (a7 === null)
        return null;
      do
        a7 = a7.return;
      while (a7 && a7.tag !== 5);
      return a7 ? a7 : null;
    }
    function hf(a7, b7, c8, d7, e11) {
      for (var f10 = b7._reactName, g6 = []; c8 !== null && c8 !== d7; ) {
        var h4 = c8, k4 = h4.alternate, l9 = h4.stateNode;
        if (k4 !== null && k4 === d7)
          break;
        h4.tag === 5 && l9 !== null && (h4 = l9, e11 ? (k4 = Ob(c8, f10), k4 != null && g6.unshift(ef(c8, k4, h4))) : e11 || (k4 = Ob(c8, f10), k4 != null && g6.push(ef(c8, k4, h4))));
        c8 = c8.return;
      }
      g6.length !== 0 && a7.push({ event: b7, listeners: g6 });
    }
    function jf() {
    }
    var kf = null;
    var lf = null;
    function mf(a7, b7) {
      switch (a7) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b7.autoFocus;
      }
      return false;
    }
    function nf(a7, b7) {
      return a7 === "textarea" || a7 === "option" || a7 === "noscript" || typeof b7.children === "string" || typeof b7.children === "number" || typeof b7.dangerouslySetInnerHTML === "object" && b7.dangerouslySetInnerHTML !== null && b7.dangerouslySetInnerHTML.__html != null;
    }
    var of = typeof setTimeout === "function" ? setTimeout : void 0;
    var pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
    function qf(a7) {
      a7.nodeType === 1 ? a7.textContent = "" : a7.nodeType === 9 && (a7 = a7.body, a7 != null && (a7.textContent = ""));
    }
    function rf(a7) {
      for (; a7 != null; a7 = a7.nextSibling) {
        var b7 = a7.nodeType;
        if (b7 === 1 || b7 === 3)
          break;
      }
      return a7;
    }
    function sf(a7) {
      a7 = a7.previousSibling;
      for (var b7 = 0; a7; ) {
        if (a7.nodeType === 8) {
          var c8 = a7.data;
          if (c8 === "$" || c8 === "$!" || c8 === "$?") {
            if (b7 === 0)
              return a7;
            b7--;
          } else
            c8 === "/$" && b7++;
        }
        a7 = a7.previousSibling;
      }
      return null;
    }
    var tf = 0;
    function uf(a7) {
      return { $$typeof: Ga, toString: a7, valueOf: a7 };
    }
    var vf = Math.random().toString(36).slice(2);
    var wf = "__reactFiber$" + vf;
    var xf = "__reactProps$" + vf;
    var ff = "__reactContainer$" + vf;
    var yf = "__reactEvents$" + vf;
    function wc(a7) {
      var b7 = a7[wf];
      if (b7)
        return b7;
      for (var c8 = a7.parentNode; c8; ) {
        if (b7 = c8[ff] || c8[wf]) {
          c8 = b7.alternate;
          if (b7.child !== null || c8 !== null && c8.child !== null)
            for (a7 = sf(a7); a7 !== null; ) {
              if (c8 = a7[wf])
                return c8;
              a7 = sf(a7);
            }
          return b7;
        }
        a7 = c8;
        c8 = a7.parentNode;
      }
      return null;
    }
    function Cb(a7) {
      a7 = a7[wf] || a7[ff];
      return !a7 || a7.tag !== 5 && a7.tag !== 6 && a7.tag !== 13 && a7.tag !== 3 ? null : a7;
    }
    function ue2(a7) {
      if (a7.tag === 5 || a7.tag === 6)
        return a7.stateNode;
      throw Error(y5(33));
    }
    function Db(a7) {
      return a7[xf] || null;
    }
    function $e(a7) {
      var b7 = a7[yf];
      b7 === void 0 && (b7 = a7[yf] = /* @__PURE__ */ new Set());
      return b7;
    }
    var zf = [];
    var Af = -1;
    function Bf(a7) {
      return { current: a7 };
    }
    function H4(a7) {
      0 > Af || (a7.current = zf[Af], zf[Af] = null, Af--);
    }
    function I4(a7, b7) {
      Af++;
      zf[Af] = a7.current;
      a7.current = b7;
    }
    var Cf = {};
    var M3 = Bf(Cf);
    var N2 = Bf(false);
    var Df = Cf;
    function Ef(a7, b7) {
      var c8 = a7.type.contextTypes;
      if (!c8)
        return Cf;
      var d7 = a7.stateNode;
      if (d7 && d7.__reactInternalMemoizedUnmaskedChildContext === b7)
        return d7.__reactInternalMemoizedMaskedChildContext;
      var e11 = {}, f10;
      for (f10 in c8)
        e11[f10] = b7[f10];
      d7 && (a7 = a7.stateNode, a7.__reactInternalMemoizedUnmaskedChildContext = b7, a7.__reactInternalMemoizedMaskedChildContext = e11);
      return e11;
    }
    function Ff(a7) {
      a7 = a7.childContextTypes;
      return a7 !== null && a7 !== void 0;
    }
    function Gf() {
      H4(N2);
      H4(M3);
    }
    function Hf(a7, b7, c8) {
      if (M3.current !== Cf)
        throw Error(y5(168));
      I4(M3, b7);
      I4(N2, c8);
    }
    function If(a7, b7, c8) {
      var d7 = a7.stateNode;
      a7 = b7.childContextTypes;
      if (typeof d7.getChildContext !== "function")
        return c8;
      d7 = d7.getChildContext();
      for (var e11 in d7)
        if (!(e11 in a7))
          throw Error(y5(108, Ra(b7) || "Unknown", e11));
      return m8({}, c8, d7);
    }
    function Jf(a7) {
      a7 = (a7 = a7.stateNode) && a7.__reactInternalMemoizedMergedChildContext || Cf;
      Df = M3.current;
      I4(M3, a7);
      I4(N2, N2.current);
      return true;
    }
    function Kf(a7, b7, c8) {
      var d7 = a7.stateNode;
      if (!d7)
        throw Error(y5(169));
      c8 ? (a7 = If(a7, b7, Df), d7.__reactInternalMemoizedMergedChildContext = a7, H4(N2), H4(M3), I4(M3, a7)) : H4(N2);
      I4(N2, c8);
    }
    var Lf = null;
    var Mf = null;
    var Nf = r12.unstable_runWithPriority;
    var Of = r12.unstable_scheduleCallback;
    var Pf = r12.unstable_cancelCallback;
    var Qf = r12.unstable_shouldYield;
    var Rf = r12.unstable_requestPaint;
    var Sf = r12.unstable_now;
    var Tf = r12.unstable_getCurrentPriorityLevel;
    var Uf = r12.unstable_ImmediatePriority;
    var Vf = r12.unstable_UserBlockingPriority;
    var Wf = r12.unstable_NormalPriority;
    var Xf = r12.unstable_LowPriority;
    var Yf = r12.unstable_IdlePriority;
    var Zf = {};
    var $f = Rf !== void 0 ? Rf : function() {
    };
    var ag = null;
    var bg = null;
    var cg = false;
    var dg = Sf();
    var O4 = 1e4 > dg ? Sf : function() {
      return Sf() - dg;
    };
    function eg() {
      switch (Tf()) {
        case Uf:
          return 99;
        case Vf:
          return 98;
        case Wf:
          return 97;
        case Xf:
          return 96;
        case Yf:
          return 95;
        default:
          throw Error(y5(332));
      }
    }
    function fg(a7) {
      switch (a7) {
        case 99:
          return Uf;
        case 98:
          return Vf;
        case 97:
          return Wf;
        case 96:
          return Xf;
        case 95:
          return Yf;
        default:
          throw Error(y5(332));
      }
    }
    function gg(a7, b7) {
      a7 = fg(a7);
      return Nf(a7, b7);
    }
    function hg(a7, b7, c8) {
      a7 = fg(a7);
      return Of(a7, b7, c8);
    }
    function ig() {
      if (bg !== null) {
        var a7 = bg;
        bg = null;
        Pf(a7);
      }
      jg();
    }
    function jg() {
      if (!cg && ag !== null) {
        cg = true;
        var a7 = 0;
        try {
          var b7 = ag;
          gg(99, function() {
            for (; a7 < b7.length; a7++) {
              var c8 = b7[a7];
              do
                c8 = c8(true);
              while (c8 !== null);
            }
          });
          ag = null;
        } catch (c8) {
          throw ag !== null && (ag = ag.slice(a7 + 1)), Of(Uf, ig), c8;
        } finally {
          cg = false;
        }
      }
    }
    var kg = ra.ReactCurrentBatchConfig;
    function lg(a7, b7) {
      if (a7 && a7.defaultProps) {
        b7 = m8({}, b7);
        a7 = a7.defaultProps;
        for (var c8 in a7)
          b7[c8] === void 0 && (b7[c8] = a7[c8]);
        return b7;
      }
      return b7;
    }
    var mg = Bf(null);
    var ng = null;
    var og = null;
    var pg = null;
    function qg() {
      pg = og = ng = null;
    }
    function rg(a7) {
      var b7 = mg.current;
      H4(mg);
      a7.type._context._currentValue = b7;
    }
    function sg(a7, b7) {
      for (; a7 !== null; ) {
        var c8 = a7.alternate;
        if ((a7.childLanes & b7) === b7)
          if (c8 === null || (c8.childLanes & b7) === b7)
            break;
          else
            c8.childLanes |= b7;
        else
          a7.childLanes |= b7, c8 !== null && (c8.childLanes |= b7);
        a7 = a7.return;
      }
    }
    function tg(a7, b7) {
      ng = a7;
      pg = og = null;
      a7 = a7.dependencies;
      a7 !== null && a7.firstContext !== null && ((a7.lanes & b7) !== 0 && (ug = true), a7.firstContext = null);
    }
    function vg(a7, b7) {
      if (pg !== a7 && b7 !== false && b7 !== 0) {
        if (typeof b7 !== "number" || b7 === 1073741823)
          pg = a7, b7 = 1073741823;
        b7 = { context: a7, observedBits: b7, next: null };
        if (og === null) {
          if (ng === null)
            throw Error(y5(308));
          og = b7;
          ng.dependencies = { lanes: 0, firstContext: b7, responders: null };
        } else
          og = og.next = b7;
      }
      return a7._currentValue;
    }
    var wg = false;
    function xg(a7) {
      a7.updateQueue = { baseState: a7.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
    }
    function yg(a7, b7) {
      a7 = a7.updateQueue;
      b7.updateQueue === a7 && (b7.updateQueue = { baseState: a7.baseState, firstBaseUpdate: a7.firstBaseUpdate, lastBaseUpdate: a7.lastBaseUpdate, shared: a7.shared, effects: a7.effects });
    }
    function zg(a7, b7) {
      return { eventTime: a7, lane: b7, tag: 0, payload: null, callback: null, next: null };
    }
    function Ag(a7, b7) {
      a7 = a7.updateQueue;
      if (a7 !== null) {
        a7 = a7.shared;
        var c8 = a7.pending;
        c8 === null ? b7.next = b7 : (b7.next = c8.next, c8.next = b7);
        a7.pending = b7;
      }
    }
    function Bg(a7, b7) {
      var c8 = a7.updateQueue, d7 = a7.alternate;
      if (d7 !== null && (d7 = d7.updateQueue, c8 === d7)) {
        var e11 = null, f10 = null;
        c8 = c8.firstBaseUpdate;
        if (c8 !== null) {
          do {
            var g6 = { eventTime: c8.eventTime, lane: c8.lane, tag: c8.tag, payload: c8.payload, callback: c8.callback, next: null };
            f10 === null ? e11 = f10 = g6 : f10 = f10.next = g6;
            c8 = c8.next;
          } while (c8 !== null);
          f10 === null ? e11 = f10 = b7 : f10 = f10.next = b7;
        } else
          e11 = f10 = b7;
        c8 = { baseState: d7.baseState, firstBaseUpdate: e11, lastBaseUpdate: f10, shared: d7.shared, effects: d7.effects };
        a7.updateQueue = c8;
        return;
      }
      a7 = c8.lastBaseUpdate;
      a7 === null ? c8.firstBaseUpdate = b7 : a7.next = b7;
      c8.lastBaseUpdate = b7;
    }
    function Cg(a7, b7, c8, d7) {
      var e11 = a7.updateQueue;
      wg = false;
      var f10 = e11.firstBaseUpdate, g6 = e11.lastBaseUpdate, h4 = e11.shared.pending;
      if (h4 !== null) {
        e11.shared.pending = null;
        var k4 = h4, l9 = k4.next;
        k4.next = null;
        g6 === null ? f10 = l9 : g6.next = l9;
        g6 = k4;
        var n6 = a7.alternate;
        if (n6 !== null) {
          n6 = n6.updateQueue;
          var A3 = n6.lastBaseUpdate;
          A3 !== g6 && (A3 === null ? n6.firstBaseUpdate = l9 : A3.next = l9, n6.lastBaseUpdate = k4);
        }
      }
      if (f10 !== null) {
        A3 = e11.baseState;
        g6 = 0;
        n6 = l9 = k4 = null;
        do {
          h4 = f10.lane;
          var p7 = f10.eventTime;
          if ((d7 & h4) === h4) {
            n6 !== null && (n6 = n6.next = {
              eventTime: p7,
              lane: 0,
              tag: f10.tag,
              payload: f10.payload,
              callback: f10.callback,
              next: null
            });
            a: {
              var C6 = a7, x6 = f10;
              h4 = b7;
              p7 = c8;
              switch (x6.tag) {
                case 1:
                  C6 = x6.payload;
                  if (typeof C6 === "function") {
                    A3 = C6.call(p7, A3, h4);
                    break a;
                  }
                  A3 = C6;
                  break a;
                case 3:
                  C6.flags = C6.flags & -4097 | 64;
                case 0:
                  C6 = x6.payload;
                  h4 = typeof C6 === "function" ? C6.call(p7, A3, h4) : C6;
                  if (h4 === null || h4 === void 0)
                    break a;
                  A3 = m8({}, A3, h4);
                  break a;
                case 2:
                  wg = true;
              }
            }
            f10.callback !== null && (a7.flags |= 32, h4 = e11.effects, h4 === null ? e11.effects = [f10] : h4.push(f10));
          } else
            p7 = { eventTime: p7, lane: h4, tag: f10.tag, payload: f10.payload, callback: f10.callback, next: null }, n6 === null ? (l9 = n6 = p7, k4 = A3) : n6 = n6.next = p7, g6 |= h4;
          f10 = f10.next;
          if (f10 === null)
            if (h4 = e11.shared.pending, h4 === null)
              break;
            else
              f10 = h4.next, h4.next = null, e11.lastBaseUpdate = h4, e11.shared.pending = null;
        } while (1);
        n6 === null && (k4 = A3);
        e11.baseState = k4;
        e11.firstBaseUpdate = l9;
        e11.lastBaseUpdate = n6;
        Dg |= g6;
        a7.lanes = g6;
        a7.memoizedState = A3;
      }
    }
    function Eg(a7, b7, c8) {
      a7 = b7.effects;
      b7.effects = null;
      if (a7 !== null)
        for (b7 = 0; b7 < a7.length; b7++) {
          var d7 = a7[b7], e11 = d7.callback;
          if (e11 !== null) {
            d7.callback = null;
            d7 = c8;
            if (typeof e11 !== "function")
              throw Error(y5(191, e11));
            e11.call(d7);
          }
        }
    }
    var Fg = new aa.Component().refs;
    function Gg(a7, b7, c8, d7) {
      b7 = a7.memoizedState;
      c8 = c8(d7, b7);
      c8 = c8 === null || c8 === void 0 ? b7 : m8({}, b7, c8);
      a7.memoizedState = c8;
      a7.lanes === 0 && (a7.updateQueue.baseState = c8);
    }
    var Kg = { isMounted: function(a7) {
      return (a7 = a7._reactInternals) ? Zb(a7) === a7 : false;
    }, enqueueSetState: function(a7, b7, c8) {
      a7 = a7._reactInternals;
      var d7 = Hg(), e11 = Ig(a7), f10 = zg(d7, e11);
      f10.payload = b7;
      c8 !== void 0 && c8 !== null && (f10.callback = c8);
      Ag(a7, f10);
      Jg(a7, e11, d7);
    }, enqueueReplaceState: function(a7, b7, c8) {
      a7 = a7._reactInternals;
      var d7 = Hg(), e11 = Ig(a7), f10 = zg(d7, e11);
      f10.tag = 1;
      f10.payload = b7;
      c8 !== void 0 && c8 !== null && (f10.callback = c8);
      Ag(a7, f10);
      Jg(a7, e11, d7);
    }, enqueueForceUpdate: function(a7, b7) {
      a7 = a7._reactInternals;
      var c8 = Hg(), d7 = Ig(a7), e11 = zg(c8, d7);
      e11.tag = 2;
      b7 !== void 0 && b7 !== null && (e11.callback = b7);
      Ag(a7, e11);
      Jg(a7, d7, c8);
    } };
    function Lg(a7, b7, c8, d7, e11, f10, g6) {
      a7 = a7.stateNode;
      return typeof a7.shouldComponentUpdate === "function" ? a7.shouldComponentUpdate(d7, f10, g6) : b7.prototype && b7.prototype.isPureReactComponent ? !Je(c8, d7) || !Je(e11, f10) : true;
    }
    function Mg(a7, b7, c8) {
      var d7 = false, e11 = Cf;
      var f10 = b7.contextType;
      typeof f10 === "object" && f10 !== null ? f10 = vg(f10) : (e11 = Ff(b7) ? Df : M3.current, d7 = b7.contextTypes, f10 = (d7 = d7 !== null && d7 !== void 0) ? Ef(a7, e11) : Cf);
      b7 = new b7(c8, f10);
      a7.memoizedState = b7.state !== null && b7.state !== void 0 ? b7.state : null;
      b7.updater = Kg;
      a7.stateNode = b7;
      b7._reactInternals = a7;
      d7 && (a7 = a7.stateNode, a7.__reactInternalMemoizedUnmaskedChildContext = e11, a7.__reactInternalMemoizedMaskedChildContext = f10);
      return b7;
    }
    function Ng(a7, b7, c8, d7) {
      a7 = b7.state;
      typeof b7.componentWillReceiveProps === "function" && b7.componentWillReceiveProps(c8, d7);
      typeof b7.UNSAFE_componentWillReceiveProps === "function" && b7.UNSAFE_componentWillReceiveProps(c8, d7);
      b7.state !== a7 && Kg.enqueueReplaceState(b7, b7.state, null);
    }
    function Og(a7, b7, c8, d7) {
      var e11 = a7.stateNode;
      e11.props = c8;
      e11.state = a7.memoizedState;
      e11.refs = Fg;
      xg(a7);
      var f10 = b7.contextType;
      typeof f10 === "object" && f10 !== null ? e11.context = vg(f10) : (f10 = Ff(b7) ? Df : M3.current, e11.context = Ef(a7, f10));
      Cg(a7, c8, e11, d7);
      e11.state = a7.memoizedState;
      f10 = b7.getDerivedStateFromProps;
      typeof f10 === "function" && (Gg(a7, b7, f10, c8), e11.state = a7.memoizedState);
      typeof b7.getDerivedStateFromProps === "function" || typeof e11.getSnapshotBeforeUpdate === "function" || typeof e11.UNSAFE_componentWillMount !== "function" && typeof e11.componentWillMount !== "function" || (b7 = e11.state, typeof e11.componentWillMount === "function" && e11.componentWillMount(), typeof e11.UNSAFE_componentWillMount === "function" && e11.UNSAFE_componentWillMount(), b7 !== e11.state && Kg.enqueueReplaceState(e11, e11.state, null), Cg(a7, c8, e11, d7), e11.state = a7.memoizedState);
      typeof e11.componentDidMount === "function" && (a7.flags |= 4);
    }
    var Pg = Array.isArray;
    function Qg(a7, b7, c8) {
      a7 = c8.ref;
      if (a7 !== null && typeof a7 !== "function" && typeof a7 !== "object") {
        if (c8._owner) {
          c8 = c8._owner;
          if (c8) {
            if (c8.tag !== 1)
              throw Error(y5(309));
            var d7 = c8.stateNode;
          }
          if (!d7)
            throw Error(y5(147, a7));
          var e11 = "" + a7;
          if (b7 !== null && b7.ref !== null && typeof b7.ref === "function" && b7.ref._stringRef === e11)
            return b7.ref;
          b7 = function(a8) {
            var b8 = d7.refs;
            b8 === Fg && (b8 = d7.refs = {});
            a8 === null ? delete b8[e11] : b8[e11] = a8;
          };
          b7._stringRef = e11;
          return b7;
        }
        if (typeof a7 !== "string")
          throw Error(y5(284));
        if (!c8._owner)
          throw Error(y5(290, a7));
      }
      return a7;
    }
    function Rg(a7, b7) {
      if (a7.type !== "textarea")
        throw Error(y5(31, Object.prototype.toString.call(b7) === "[object Object]" ? "object with keys {" + Object.keys(b7).join(", ") + "}" : b7));
    }
    function Sg(a7) {
      function b7(b8, c9) {
        if (a7) {
          var d8 = b8.lastEffect;
          d8 !== null ? (d8.nextEffect = c9, b8.lastEffect = c9) : b8.firstEffect = b8.lastEffect = c9;
          c9.nextEffect = null;
          c9.flags = 8;
        }
      }
      function c8(c9, d8) {
        if (!a7)
          return null;
        for (; d8 !== null; )
          b7(c9, d8), d8 = d8.sibling;
        return null;
      }
      function d7(a8, b8) {
        for (a8 = /* @__PURE__ */ new Map(); b8 !== null; )
          b8.key !== null ? a8.set(b8.key, b8) : a8.set(b8.index, b8), b8 = b8.sibling;
        return a8;
      }
      function e11(a8, b8) {
        a8 = Tg(a8, b8);
        a8.index = 0;
        a8.sibling = null;
        return a8;
      }
      function f10(b8, c9, d8) {
        b8.index = d8;
        if (!a7)
          return c9;
        d8 = b8.alternate;
        if (d8 !== null)
          return d8 = d8.index, d8 < c9 ? (b8.flags = 2, c9) : d8;
        b8.flags = 2;
        return c9;
      }
      function g6(b8) {
        a7 && b8.alternate === null && (b8.flags = 2);
        return b8;
      }
      function h4(a8, b8, c9, d8) {
        if (b8 === null || b8.tag !== 6)
          return b8 = Ug(c9, a8.mode, d8), b8.return = a8, b8;
        b8 = e11(b8, c9);
        b8.return = a8;
        return b8;
      }
      function k4(a8, b8, c9, d8) {
        if (b8 !== null && b8.elementType === c9.type)
          return d8 = e11(b8, c9.props), d8.ref = Qg(a8, b8, c9), d8.return = a8, d8;
        d8 = Vg(c9.type, c9.key, c9.props, null, a8.mode, d8);
        d8.ref = Qg(a8, b8, c9);
        d8.return = a8;
        return d8;
      }
      function l9(a8, b8, c9, d8) {
        if (b8 === null || b8.tag !== 4 || b8.stateNode.containerInfo !== c9.containerInfo || b8.stateNode.implementation !== c9.implementation)
          return b8 = Wg(c9, a8.mode, d8), b8.return = a8, b8;
        b8 = e11(b8, c9.children || []);
        b8.return = a8;
        return b8;
      }
      function n6(a8, b8, c9, d8, f11) {
        if (b8 === null || b8.tag !== 7)
          return b8 = Xg(c9, a8.mode, d8, f11), b8.return = a8, b8;
        b8 = e11(b8, c9);
        b8.return = a8;
        return b8;
      }
      function A3(a8, b8, c9) {
        if (typeof b8 === "string" || typeof b8 === "number")
          return b8 = Ug("" + b8, a8.mode, c9), b8.return = a8, b8;
        if (typeof b8 === "object" && b8 !== null) {
          switch (b8.$$typeof) {
            case sa:
              return c9 = Vg(b8.type, b8.key, b8.props, null, a8.mode, c9), c9.ref = Qg(a8, null, b8), c9.return = a8, c9;
            case ta:
              return b8 = Wg(b8, a8.mode, c9), b8.return = a8, b8;
          }
          if (Pg(b8) || La(b8))
            return b8 = Xg(b8, a8.mode, c9, null), b8.return = a8, b8;
          Rg(a8, b8);
        }
        return null;
      }
      function p7(a8, b8, c9, d8) {
        var e12 = b8 !== null ? b8.key : null;
        if (typeof c9 === "string" || typeof c9 === "number")
          return e12 !== null ? null : h4(a8, b8, "" + c9, d8);
        if (typeof c9 === "object" && c9 !== null) {
          switch (c9.$$typeof) {
            case sa:
              return c9.key === e12 ? c9.type === ua ? n6(a8, b8, c9.props.children, d8, e12) : k4(a8, b8, c9, d8) : null;
            case ta:
              return c9.key === e12 ? l9(a8, b8, c9, d8) : null;
          }
          if (Pg(c9) || La(c9))
            return e12 !== null ? null : n6(a8, b8, c9, d8, null);
          Rg(a8, c9);
        }
        return null;
      }
      function C6(a8, b8, c9, d8, e12) {
        if (typeof d8 === "string" || typeof d8 === "number")
          return a8 = a8.get(c9) || null, h4(b8, a8, "" + d8, e12);
        if (typeof d8 === "object" && d8 !== null) {
          switch (d8.$$typeof) {
            case sa:
              return a8 = a8.get(d8.key === null ? c9 : d8.key) || null, d8.type === ua ? n6(b8, a8, d8.props.children, e12, d8.key) : k4(b8, a8, d8, e12);
            case ta:
              return a8 = a8.get(d8.key === null ? c9 : d8.key) || null, l9(b8, a8, d8, e12);
          }
          if (Pg(d8) || La(d8))
            return a8 = a8.get(c9) || null, n6(b8, a8, d8, e12, null);
          Rg(b8, d8);
        }
        return null;
      }
      function x6(e12, g7, h5, k5) {
        for (var l10 = null, t12 = null, u4 = g7, z3 = g7 = 0, q3 = null; u4 !== null && z3 < h5.length; z3++) {
          u4.index > z3 ? (q3 = u4, u4 = null) : q3 = u4.sibling;
          var n7 = p7(e12, u4, h5[z3], k5);
          if (n7 === null) {
            u4 === null && (u4 = q3);
            break;
          }
          a7 && u4 && n7.alternate === null && b7(e12, u4);
          g7 = f10(n7, g7, z3);
          t12 === null ? l10 = n7 : t12.sibling = n7;
          t12 = n7;
          u4 = q3;
        }
        if (z3 === h5.length)
          return c8(e12, u4), l10;
        if (u4 === null) {
          for (; z3 < h5.length; z3++)
            u4 = A3(e12, h5[z3], k5), u4 !== null && (g7 = f10(u4, g7, z3), t12 === null ? l10 = u4 : t12.sibling = u4, t12 = u4);
          return l10;
        }
        for (u4 = d7(e12, u4); z3 < h5.length; z3++)
          q3 = C6(u4, e12, z3, h5[z3], k5), q3 !== null && (a7 && q3.alternate !== null && u4.delete(q3.key === null ? z3 : q3.key), g7 = f10(q3, g7, z3), t12 === null ? l10 = q3 : t12.sibling = q3, t12 = q3);
        a7 && u4.forEach(function(a8) {
          return b7(e12, a8);
        });
        return l10;
      }
      function w6(e12, g7, h5, k5) {
        var l10 = La(h5);
        if (typeof l10 !== "function")
          throw Error(y5(150));
        h5 = l10.call(h5);
        if (h5 == null)
          throw Error(y5(151));
        for (var t12 = l10 = null, u4 = g7, z3 = g7 = 0, q3 = null, n7 = h5.next(); u4 !== null && !n7.done; z3++, n7 = h5.next()) {
          u4.index > z3 ? (q3 = u4, u4 = null) : q3 = u4.sibling;
          var w7 = p7(e12, u4, n7.value, k5);
          if (w7 === null) {
            u4 === null && (u4 = q3);
            break;
          }
          a7 && u4 && w7.alternate === null && b7(e12, u4);
          g7 = f10(w7, g7, z3);
          t12 === null ? l10 = w7 : t12.sibling = w7;
          t12 = w7;
          u4 = q3;
        }
        if (n7.done)
          return c8(e12, u4), l10;
        if (u4 === null) {
          for (; !n7.done; z3++, n7 = h5.next())
            n7 = A3(e12, n7.value, k5), n7 !== null && (g7 = f10(n7, g7, z3), t12 === null ? l10 = n7 : t12.sibling = n7, t12 = n7);
          return l10;
        }
        for (u4 = d7(e12, u4); !n7.done; z3++, n7 = h5.next())
          n7 = C6(u4, e12, z3, n7.value, k5), n7 !== null && (a7 && n7.alternate !== null && u4.delete(n7.key === null ? z3 : n7.key), g7 = f10(n7, g7, z3), t12 === null ? l10 = n7 : t12.sibling = n7, t12 = n7);
        a7 && u4.forEach(function(a8) {
          return b7(e12, a8);
        });
        return l10;
      }
      return function(a8, d8, f11, h5) {
        var k5 = typeof f11 === "object" && f11 !== null && f11.type === ua && f11.key === null;
        k5 && (f11 = f11.props.children);
        var l10 = typeof f11 === "object" && f11 !== null;
        if (l10)
          switch (f11.$$typeof) {
            case sa:
              a: {
                l10 = f11.key;
                for (k5 = d8; k5 !== null; ) {
                  if (k5.key === l10) {
                    switch (k5.tag) {
                      case 7:
                        if (f11.type === ua) {
                          c8(a8, k5.sibling);
                          d8 = e11(k5, f11.props.children);
                          d8.return = a8;
                          a8 = d8;
                          break a;
                        }
                        break;
                      default:
                        if (k5.elementType === f11.type) {
                          c8(a8, k5.sibling);
                          d8 = e11(k5, f11.props);
                          d8.ref = Qg(a8, k5, f11);
                          d8.return = a8;
                          a8 = d8;
                          break a;
                        }
                    }
                    c8(a8, k5);
                    break;
                  } else
                    b7(a8, k5);
                  k5 = k5.sibling;
                }
                f11.type === ua ? (d8 = Xg(f11.props.children, a8.mode, h5, f11.key), d8.return = a8, a8 = d8) : (h5 = Vg(f11.type, f11.key, f11.props, null, a8.mode, h5), h5.ref = Qg(a8, d8, f11), h5.return = a8, a8 = h5);
              }
              return g6(a8);
            case ta:
              a: {
                for (k5 = f11.key; d8 !== null; ) {
                  if (d8.key === k5)
                    if (d8.tag === 4 && d8.stateNode.containerInfo === f11.containerInfo && d8.stateNode.implementation === f11.implementation) {
                      c8(a8, d8.sibling);
                      d8 = e11(d8, f11.children || []);
                      d8.return = a8;
                      a8 = d8;
                      break a;
                    } else {
                      c8(a8, d8);
                      break;
                    }
                  else
                    b7(a8, d8);
                  d8 = d8.sibling;
                }
                d8 = Wg(f11, a8.mode, h5);
                d8.return = a8;
                a8 = d8;
              }
              return g6(a8);
          }
        if (typeof f11 === "string" || typeof f11 === "number")
          return f11 = "" + f11, d8 !== null && d8.tag === 6 ? (c8(a8, d8.sibling), d8 = e11(d8, f11), d8.return = a8, a8 = d8) : (c8(a8, d8), d8 = Ug(f11, a8.mode, h5), d8.return = a8, a8 = d8), g6(a8);
        if (Pg(f11))
          return x6(a8, d8, f11, h5);
        if (La(f11))
          return w6(a8, d8, f11, h5);
        l10 && Rg(a8, f11);
        if (typeof f11 === "undefined" && !k5)
          switch (a8.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(y5(152, Ra(a8.type) || "Component"));
          }
        return c8(a8, d8);
      };
    }
    var Yg = Sg(true);
    var Zg = Sg(false);
    var $g = {};
    var ah = Bf($g);
    var bh = Bf($g);
    var ch = Bf($g);
    function dh(a7) {
      if (a7 === $g)
        throw Error(y5(174));
      return a7;
    }
    function eh(a7, b7) {
      I4(ch, b7);
      I4(bh, a7);
      I4(ah, $g);
      a7 = b7.nodeType;
      switch (a7) {
        case 9:
        case 11:
          b7 = (b7 = b7.documentElement) ? b7.namespaceURI : mb(null, "");
          break;
        default:
          a7 = a7 === 8 ? b7.parentNode : b7, b7 = a7.namespaceURI || null, a7 = a7.tagName, b7 = mb(b7, a7);
      }
      H4(ah);
      I4(ah, b7);
    }
    function fh() {
      H4(ah);
      H4(bh);
      H4(ch);
    }
    function gh(a7) {
      dh(ch.current);
      var b7 = dh(ah.current);
      var c8 = mb(b7, a7.type);
      b7 !== c8 && (I4(bh, a7), I4(ah, c8));
    }
    function hh(a7) {
      bh.current === a7 && (H4(ah), H4(bh));
    }
    var P3 = Bf(0);
    function ih(a7) {
      for (var b7 = a7; b7 !== null; ) {
        if (b7.tag === 13) {
          var c8 = b7.memoizedState;
          if (c8 !== null && (c8 = c8.dehydrated, c8 === null || c8.data === "$?" || c8.data === "$!"))
            return b7;
        } else if (b7.tag === 19 && b7.memoizedProps.revealOrder !== void 0) {
          if ((b7.flags & 64) !== 0)
            return b7;
        } else if (b7.child !== null) {
          b7.child.return = b7;
          b7 = b7.child;
          continue;
        }
        if (b7 === a7)
          break;
        for (; b7.sibling === null; ) {
          if (b7.return === null || b7.return === a7)
            return null;
          b7 = b7.return;
        }
        b7.sibling.return = b7.return;
        b7 = b7.sibling;
      }
      return null;
    }
    var jh = null;
    var kh = null;
    var lh = false;
    function mh(a7, b7) {
      var c8 = nh(5, null, null, 0);
      c8.elementType = "DELETED";
      c8.type = "DELETED";
      c8.stateNode = b7;
      c8.return = a7;
      c8.flags = 8;
      a7.lastEffect !== null ? (a7.lastEffect.nextEffect = c8, a7.lastEffect = c8) : a7.firstEffect = a7.lastEffect = c8;
    }
    function oh(a7, b7) {
      switch (a7.tag) {
        case 5:
          var c8 = a7.type;
          b7 = b7.nodeType !== 1 || c8.toLowerCase() !== b7.nodeName.toLowerCase() ? null : b7;
          return b7 !== null ? (a7.stateNode = b7, true) : false;
        case 6:
          return b7 = a7.pendingProps === "" || b7.nodeType !== 3 ? null : b7, b7 !== null ? (a7.stateNode = b7, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function ph(a7) {
      if (lh) {
        var b7 = kh;
        if (b7) {
          var c8 = b7;
          if (!oh(a7, b7)) {
            b7 = rf(c8.nextSibling);
            if (!b7 || !oh(a7, b7)) {
              a7.flags = a7.flags & -1025 | 2;
              lh = false;
              jh = a7;
              return;
            }
            mh(jh, c8);
          }
          jh = a7;
          kh = rf(b7.firstChild);
        } else
          a7.flags = a7.flags & -1025 | 2, lh = false, jh = a7;
      }
    }
    function qh(a7) {
      for (a7 = a7.return; a7 !== null && a7.tag !== 5 && a7.tag !== 3 && a7.tag !== 13; )
        a7 = a7.return;
      jh = a7;
    }
    function rh(a7) {
      if (a7 !== jh)
        return false;
      if (!lh)
        return qh(a7), lh = true, false;
      var b7 = a7.type;
      if (a7.tag !== 5 || b7 !== "head" && b7 !== "body" && !nf(b7, a7.memoizedProps))
        for (b7 = kh; b7; )
          mh(a7, b7), b7 = rf(b7.nextSibling);
      qh(a7);
      if (a7.tag === 13) {
        a7 = a7.memoizedState;
        a7 = a7 !== null ? a7.dehydrated : null;
        if (!a7)
          throw Error(y5(317));
        a: {
          a7 = a7.nextSibling;
          for (b7 = 0; a7; ) {
            if (a7.nodeType === 8) {
              var c8 = a7.data;
              if (c8 === "/$") {
                if (b7 === 0) {
                  kh = rf(a7.nextSibling);
                  break a;
                }
                b7--;
              } else
                c8 !== "$" && c8 !== "$!" && c8 !== "$?" || b7++;
            }
            a7 = a7.nextSibling;
          }
          kh = null;
        }
      } else
        kh = jh ? rf(a7.stateNode.nextSibling) : null;
      return true;
    }
    function sh() {
      kh = jh = null;
      lh = false;
    }
    var th = [];
    function uh() {
      for (var a7 = 0; a7 < th.length; a7++)
        th[a7]._workInProgressVersionPrimary = null;
      th.length = 0;
    }
    var vh = ra.ReactCurrentDispatcher;
    var wh = ra.ReactCurrentBatchConfig;
    var xh = 0;
    var R5 = null;
    var S3 = null;
    var T5 = null;
    var yh = false;
    var zh = false;
    function Ah() {
      throw Error(y5(321));
    }
    function Bh(a7, b7) {
      if (b7 === null)
        return false;
      for (var c8 = 0; c8 < b7.length && c8 < a7.length; c8++)
        if (!He(a7[c8], b7[c8]))
          return false;
      return true;
    }
    function Ch(a7, b7, c8, d7, e11, f10) {
      xh = f10;
      R5 = b7;
      b7.memoizedState = null;
      b7.updateQueue = null;
      b7.lanes = 0;
      vh.current = a7 === null || a7.memoizedState === null ? Dh : Eh;
      a7 = c8(d7, e11);
      if (zh) {
        f10 = 0;
        do {
          zh = false;
          if (!(25 > f10))
            throw Error(y5(301));
          f10 += 1;
          T5 = S3 = null;
          b7.updateQueue = null;
          vh.current = Fh;
          a7 = c8(d7, e11);
        } while (zh);
      }
      vh.current = Gh;
      b7 = S3 !== null && S3.next !== null;
      xh = 0;
      T5 = S3 = R5 = null;
      yh = false;
      if (b7)
        throw Error(y5(300));
      return a7;
    }
    function Hh() {
      var a7 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      T5 === null ? R5.memoizedState = T5 = a7 : T5 = T5.next = a7;
      return T5;
    }
    function Ih() {
      if (S3 === null) {
        var a7 = R5.alternate;
        a7 = a7 !== null ? a7.memoizedState : null;
      } else
        a7 = S3.next;
      var b7 = T5 === null ? R5.memoizedState : T5.next;
      if (b7 !== null)
        T5 = b7, S3 = a7;
      else {
        if (a7 === null)
          throw Error(y5(310));
        S3 = a7;
        a7 = { memoizedState: S3.memoizedState, baseState: S3.baseState, baseQueue: S3.baseQueue, queue: S3.queue, next: null };
        T5 === null ? R5.memoizedState = T5 = a7 : T5 = T5.next = a7;
      }
      return T5;
    }
    function Jh(a7, b7) {
      return typeof b7 === "function" ? b7(a7) : b7;
    }
    function Kh(a7) {
      var b7 = Ih(), c8 = b7.queue;
      if (c8 === null)
        throw Error(y5(311));
      c8.lastRenderedReducer = a7;
      var d7 = S3, e11 = d7.baseQueue, f10 = c8.pending;
      if (f10 !== null) {
        if (e11 !== null) {
          var g6 = e11.next;
          e11.next = f10.next;
          f10.next = g6;
        }
        d7.baseQueue = e11 = f10;
        c8.pending = null;
      }
      if (e11 !== null) {
        e11 = e11.next;
        d7 = d7.baseState;
        var h4 = g6 = f10 = null, k4 = e11;
        do {
          var l9 = k4.lane;
          if ((xh & l9) === l9)
            h4 !== null && (h4 = h4.next = { lane: 0, action: k4.action, eagerReducer: k4.eagerReducer, eagerState: k4.eagerState, next: null }), d7 = k4.eagerReducer === a7 ? k4.eagerState : a7(d7, k4.action);
          else {
            var n6 = {
              lane: l9,
              action: k4.action,
              eagerReducer: k4.eagerReducer,
              eagerState: k4.eagerState,
              next: null
            };
            h4 === null ? (g6 = h4 = n6, f10 = d7) : h4 = h4.next = n6;
            R5.lanes |= l9;
            Dg |= l9;
          }
          k4 = k4.next;
        } while (k4 !== null && k4 !== e11);
        h4 === null ? f10 = d7 : h4.next = g6;
        He(d7, b7.memoizedState) || (ug = true);
        b7.memoizedState = d7;
        b7.baseState = f10;
        b7.baseQueue = h4;
        c8.lastRenderedState = d7;
      }
      return [b7.memoizedState, c8.dispatch];
    }
    function Lh(a7) {
      var b7 = Ih(), c8 = b7.queue;
      if (c8 === null)
        throw Error(y5(311));
      c8.lastRenderedReducer = a7;
      var d7 = c8.dispatch, e11 = c8.pending, f10 = b7.memoizedState;
      if (e11 !== null) {
        c8.pending = null;
        var g6 = e11 = e11.next;
        do
          f10 = a7(f10, g6.action), g6 = g6.next;
        while (g6 !== e11);
        He(f10, b7.memoizedState) || (ug = true);
        b7.memoizedState = f10;
        b7.baseQueue === null && (b7.baseState = f10);
        c8.lastRenderedState = f10;
      }
      return [f10, d7];
    }
    function Mh(a7, b7, c8) {
      var d7 = b7._getVersion;
      d7 = d7(b7._source);
      var e11 = b7._workInProgressVersionPrimary;
      if (e11 !== null)
        a7 = e11 === d7;
      else if (a7 = a7.mutableReadLanes, a7 = (xh & a7) === a7)
        b7._workInProgressVersionPrimary = d7, th.push(b7);
      if (a7)
        return c8(b7._source);
      th.push(b7);
      throw Error(y5(350));
    }
    function Nh(a7, b7, c8, d7) {
      var e11 = U3;
      if (e11 === null)
        throw Error(y5(349));
      var f10 = b7._getVersion, g6 = f10(b7._source), h4 = vh.current, k4 = h4.useState(function() {
        return Mh(e11, b7, c8);
      }), l9 = k4[1], n6 = k4[0];
      k4 = T5;
      var A3 = a7.memoizedState, p7 = A3.refs, C6 = p7.getSnapshot, x6 = A3.source;
      A3 = A3.subscribe;
      var w6 = R5;
      a7.memoizedState = { refs: p7, source: b7, subscribe: d7 };
      h4.useEffect(function() {
        p7.getSnapshot = c8;
        p7.setSnapshot = l9;
        var a8 = f10(b7._source);
        if (!He(g6, a8)) {
          a8 = c8(b7._source);
          He(n6, a8) || (l9(a8), a8 = Ig(w6), e11.mutableReadLanes |= a8 & e11.pendingLanes);
          a8 = e11.mutableReadLanes;
          e11.entangledLanes |= a8;
          for (var d8 = e11.entanglements, h5 = a8; 0 < h5; ) {
            var k5 = 31 - Vc(h5), v6 = 1 << k5;
            d8[k5] |= a8;
            h5 &= ~v6;
          }
        }
      }, [c8, b7, d7]);
      h4.useEffect(function() {
        return d7(b7._source, function() {
          var a8 = p7.getSnapshot, c9 = p7.setSnapshot;
          try {
            c9(a8(b7._source));
            var d8 = Ig(w6);
            e11.mutableReadLanes |= d8 & e11.pendingLanes;
          } catch (q3) {
            c9(function() {
              throw q3;
            });
          }
        });
      }, [b7, d7]);
      He(C6, c8) && He(x6, b7) && He(A3, d7) || (a7 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n6 }, a7.dispatch = l9 = Oh.bind(null, R5, a7), k4.queue = a7, k4.baseQueue = null, n6 = Mh(e11, b7, c8), k4.memoizedState = k4.baseState = n6);
      return n6;
    }
    function Ph(a7, b7, c8) {
      var d7 = Ih();
      return Nh(d7, a7, b7, c8);
    }
    function Qh(a7) {
      var b7 = Hh();
      typeof a7 === "function" && (a7 = a7());
      b7.memoizedState = b7.baseState = a7;
      a7 = b7.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a7 };
      a7 = a7.dispatch = Oh.bind(null, R5, a7);
      return [b7.memoizedState, a7];
    }
    function Rh(a7, b7, c8, d7) {
      a7 = { tag: a7, create: b7, destroy: c8, deps: d7, next: null };
      b7 = R5.updateQueue;
      b7 === null ? (b7 = { lastEffect: null }, R5.updateQueue = b7, b7.lastEffect = a7.next = a7) : (c8 = b7.lastEffect, c8 === null ? b7.lastEffect = a7.next = a7 : (d7 = c8.next, c8.next = a7, a7.next = d7, b7.lastEffect = a7));
      return a7;
    }
    function Sh(a7) {
      var b7 = Hh();
      a7 = { current: a7 };
      return b7.memoizedState = a7;
    }
    function Th() {
      return Ih().memoizedState;
    }
    function Uh(a7, b7, c8, d7) {
      var e11 = Hh();
      R5.flags |= a7;
      e11.memoizedState = Rh(1 | b7, c8, void 0, d7 === void 0 ? null : d7);
    }
    function Vh(a7, b7, c8, d7) {
      var e11 = Ih();
      d7 = d7 === void 0 ? null : d7;
      var f10 = void 0;
      if (S3 !== null) {
        var g6 = S3.memoizedState;
        f10 = g6.destroy;
        if (d7 !== null && Bh(d7, g6.deps)) {
          Rh(b7, c8, f10, d7);
          return;
        }
      }
      R5.flags |= a7;
      e11.memoizedState = Rh(1 | b7, c8, f10, d7);
    }
    function Wh(a7, b7) {
      return Uh(516, 4, a7, b7);
    }
    function Xh(a7, b7) {
      return Vh(516, 4, a7, b7);
    }
    function Yh(a7, b7) {
      return Vh(4, 2, a7, b7);
    }
    function Zh(a7, b7) {
      if (typeof b7 === "function")
        return a7 = a7(), b7(a7), function() {
          b7(null);
        };
      if (b7 !== null && b7 !== void 0)
        return a7 = a7(), b7.current = a7, function() {
          b7.current = null;
        };
    }
    function $h(a7, b7, c8) {
      c8 = c8 !== null && c8 !== void 0 ? c8.concat([a7]) : null;
      return Vh(4, 2, Zh.bind(null, b7, a7), c8);
    }
    function ai() {
    }
    function bi(a7, b7) {
      var c8 = Ih();
      b7 = b7 === void 0 ? null : b7;
      var d7 = c8.memoizedState;
      if (d7 !== null && b7 !== null && Bh(b7, d7[1]))
        return d7[0];
      c8.memoizedState = [a7, b7];
      return a7;
    }
    function ci(a7, b7) {
      var c8 = Ih();
      b7 = b7 === void 0 ? null : b7;
      var d7 = c8.memoizedState;
      if (d7 !== null && b7 !== null && Bh(b7, d7[1]))
        return d7[0];
      a7 = a7();
      c8.memoizedState = [a7, b7];
      return a7;
    }
    function di(a7, b7) {
      var c8 = eg();
      gg(98 > c8 ? 98 : c8, function() {
        a7(true);
      });
      gg(97 < c8 ? 97 : c8, function() {
        var c9 = wh.transition;
        wh.transition = 1;
        try {
          a7(false), b7();
        } finally {
          wh.transition = c9;
        }
      });
    }
    function Oh(a7, b7, c8) {
      var d7 = Hg(), e11 = Ig(a7), f10 = { lane: e11, action: c8, eagerReducer: null, eagerState: null, next: null }, g6 = b7.pending;
      g6 === null ? f10.next = f10 : (f10.next = g6.next, g6.next = f10);
      b7.pending = f10;
      g6 = a7.alternate;
      if (a7 === R5 || g6 !== null && g6 === R5)
        zh = yh = true;
      else {
        if (a7.lanes === 0 && (g6 === null || g6.lanes === 0) && (g6 = b7.lastRenderedReducer, g6 !== null))
          try {
            var h4 = b7.lastRenderedState, k4 = g6(h4, c8);
            f10.eagerReducer = g6;
            f10.eagerState = k4;
            if (He(k4, h4))
              return;
          } catch (l9) {
          } finally {
          }
        Jg(a7, e11, d7);
      }
    }
    var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false };
    var Dh = { readContext: vg, useCallback: function(a7, b7) {
      Hh().memoizedState = [a7, b7 === void 0 ? null : b7];
      return a7;
    }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a7, b7, c8) {
      c8 = c8 !== null && c8 !== void 0 ? c8.concat([a7]) : null;
      return Uh(4, 2, Zh.bind(null, b7, a7), c8);
    }, useLayoutEffect: function(a7, b7) {
      return Uh(4, 2, a7, b7);
    }, useMemo: function(a7, b7) {
      var c8 = Hh();
      b7 = b7 === void 0 ? null : b7;
      a7 = a7();
      c8.memoizedState = [a7, b7];
      return a7;
    }, useReducer: function(a7, b7, c8) {
      var d7 = Hh();
      b7 = c8 !== void 0 ? c8(b7) : b7;
      d7.memoizedState = d7.baseState = b7;
      a7 = d7.queue = { pending: null, dispatch: null, lastRenderedReducer: a7, lastRenderedState: b7 };
      a7 = a7.dispatch = Oh.bind(null, R5, a7);
      return [d7.memoizedState, a7];
    }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a7) {
      var b7 = Qh(a7), c8 = b7[0], d7 = b7[1];
      Wh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d7(a7);
        } finally {
          wh.transition = b8;
        }
      }, [a7]);
      return c8;
    }, useTransition: function() {
      var a7 = Qh(false), b7 = a7[0];
      a7 = di.bind(null, a7[1]);
      Sh(a7);
      return [a7, b7];
    }, useMutableSource: function(a7, b7, c8) {
      var d7 = Hh();
      d7.memoizedState = { refs: { getSnapshot: b7, setSnapshot: null }, source: a7, subscribe: c8 };
      return Nh(d7, a7, b7, c8);
    }, useOpaqueIdentifier: function() {
      if (lh) {
        var a7 = false, b7 = uf(function() {
          a7 || (a7 = true, c8("r:" + (tf++).toString(36)));
          throw Error(y5(355));
        }), c8 = Qh(b7)[1];
        (R5.mode & 2) === 0 && (R5.flags |= 516, Rh(5, function() {
          c8("r:" + (tf++).toString(36));
        }, void 0, null));
        return b7;
      }
      b7 = "r:" + (tf++).toString(36);
      Qh(b7);
      return b7;
    }, unstable_isNewReconciler: false };
    var Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
      return Kh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a7) {
      var b7 = Kh(Jh), c8 = b7[0], d7 = b7[1];
      Xh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d7(a7);
        } finally {
          wh.transition = b8;
        }
      }, [a7]);
      return c8;
    }, useTransition: function() {
      var a7 = Kh(Jh)[0];
      return [
        Th().current,
        a7
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Kh(Jh)[0];
    }, unstable_isNewReconciler: false };
    var Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
      return Lh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a7) {
      var b7 = Lh(Jh), c8 = b7[0], d7 = b7[1];
      Xh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d7(a7);
        } finally {
          wh.transition = b8;
        }
      }, [a7]);
      return c8;
    }, useTransition: function() {
      var a7 = Lh(Jh)[0];
      return [
        Th().current,
        a7
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Lh(Jh)[0];
    }, unstable_isNewReconciler: false };
    var ei = ra.ReactCurrentOwner;
    var ug = false;
    function fi(a7, b7, c8, d7) {
      b7.child = a7 === null ? Zg(b7, null, c8, d7) : Yg(b7, a7.child, c8, d7);
    }
    function gi(a7, b7, c8, d7, e11) {
      c8 = c8.render;
      var f10 = b7.ref;
      tg(b7, e11);
      d7 = Ch(a7, b7, c8, d7, f10, e11);
      if (a7 !== null && !ug)
        return b7.updateQueue = a7.updateQueue, b7.flags &= -517, a7.lanes &= ~e11, hi(a7, b7, e11);
      b7.flags |= 1;
      fi(a7, b7, d7, e11);
      return b7.child;
    }
    function ii(a7, b7, c8, d7, e11, f10) {
      if (a7 === null) {
        var g6 = c8.type;
        if (typeof g6 === "function" && !ji(g6) && g6.defaultProps === void 0 && c8.compare === null && c8.defaultProps === void 0)
          return b7.tag = 15, b7.type = g6, ki(a7, b7, g6, d7, e11, f10);
        a7 = Vg(c8.type, null, d7, b7, b7.mode, f10);
        a7.ref = b7.ref;
        a7.return = b7;
        return b7.child = a7;
      }
      g6 = a7.child;
      if ((e11 & f10) === 0 && (e11 = g6.memoizedProps, c8 = c8.compare, c8 = c8 !== null ? c8 : Je, c8(e11, d7) && a7.ref === b7.ref))
        return hi(a7, b7, f10);
      b7.flags |= 1;
      a7 = Tg(g6, d7);
      a7.ref = b7.ref;
      a7.return = b7;
      return b7.child = a7;
    }
    function ki(a7, b7, c8, d7, e11, f10) {
      if (a7 !== null && Je(a7.memoizedProps, d7) && a7.ref === b7.ref)
        if (ug = false, (f10 & e11) !== 0)
          (a7.flags & 16384) !== 0 && (ug = true);
        else
          return b7.lanes = a7.lanes, hi(a7, b7, f10);
      return li(a7, b7, c8, d7, f10);
    }
    function mi(a7, b7, c8) {
      var d7 = b7.pendingProps, e11 = d7.children, f10 = a7 !== null ? a7.memoizedState : null;
      if (d7.mode === "hidden" || d7.mode === "unstable-defer-without-hiding")
        if ((b7.mode & 4) === 0)
          b7.memoizedState = { baseLanes: 0 }, ni(b7, c8);
        else if ((c8 & 1073741824) !== 0)
          b7.memoizedState = { baseLanes: 0 }, ni(b7, f10 !== null ? f10.baseLanes : c8);
        else
          return a7 = f10 !== null ? f10.baseLanes | c8 : c8, b7.lanes = b7.childLanes = 1073741824, b7.memoizedState = { baseLanes: a7 }, ni(b7, a7), null;
      else
        f10 !== null ? (d7 = f10.baseLanes | c8, b7.memoizedState = null) : d7 = c8, ni(b7, d7);
      fi(a7, b7, e11, c8);
      return b7.child;
    }
    function oi(a7, b7) {
      var c8 = b7.ref;
      if (a7 === null && c8 !== null || a7 !== null && a7.ref !== c8)
        b7.flags |= 128;
    }
    function li(a7, b7, c8, d7, e11) {
      var f10 = Ff(c8) ? Df : M3.current;
      f10 = Ef(b7, f10);
      tg(b7, e11);
      c8 = Ch(a7, b7, c8, d7, f10, e11);
      if (a7 !== null && !ug)
        return b7.updateQueue = a7.updateQueue, b7.flags &= -517, a7.lanes &= ~e11, hi(a7, b7, e11);
      b7.flags |= 1;
      fi(a7, b7, c8, e11);
      return b7.child;
    }
    function pi(a7, b7, c8, d7, e11) {
      if (Ff(c8)) {
        var f10 = true;
        Jf(b7);
      } else
        f10 = false;
      tg(b7, e11);
      if (b7.stateNode === null)
        a7 !== null && (a7.alternate = null, b7.alternate = null, b7.flags |= 2), Mg(b7, c8, d7), Og(b7, c8, d7, e11), d7 = true;
      else if (a7 === null) {
        var g6 = b7.stateNode, h4 = b7.memoizedProps;
        g6.props = h4;
        var k4 = g6.context, l9 = c8.contextType;
        typeof l9 === "object" && l9 !== null ? l9 = vg(l9) : (l9 = Ff(c8) ? Df : M3.current, l9 = Ef(b7, l9));
        var n6 = c8.getDerivedStateFromProps, A3 = typeof n6 === "function" || typeof g6.getSnapshotBeforeUpdate === "function";
        A3 || typeof g6.UNSAFE_componentWillReceiveProps !== "function" && typeof g6.componentWillReceiveProps !== "function" || (h4 !== d7 || k4 !== l9) && Ng(b7, g6, d7, l9);
        wg = false;
        var p7 = b7.memoizedState;
        g6.state = p7;
        Cg(b7, d7, g6, e11);
        k4 = b7.memoizedState;
        h4 !== d7 || p7 !== k4 || N2.current || wg ? (typeof n6 === "function" && (Gg(b7, c8, n6, d7), k4 = b7.memoizedState), (h4 = wg || Lg(b7, c8, h4, d7, p7, k4, l9)) ? (A3 || typeof g6.UNSAFE_componentWillMount !== "function" && typeof g6.componentWillMount !== "function" || (typeof g6.componentWillMount === "function" && g6.componentWillMount(), typeof g6.UNSAFE_componentWillMount === "function" && g6.UNSAFE_componentWillMount()), typeof g6.componentDidMount === "function" && (b7.flags |= 4)) : (typeof g6.componentDidMount === "function" && (b7.flags |= 4), b7.memoizedProps = d7, b7.memoizedState = k4), g6.props = d7, g6.state = k4, g6.context = l9, d7 = h4) : (typeof g6.componentDidMount === "function" && (b7.flags |= 4), d7 = false);
      } else {
        g6 = b7.stateNode;
        yg(a7, b7);
        h4 = b7.memoizedProps;
        l9 = b7.type === b7.elementType ? h4 : lg(b7.type, h4);
        g6.props = l9;
        A3 = b7.pendingProps;
        p7 = g6.context;
        k4 = c8.contextType;
        typeof k4 === "object" && k4 !== null ? k4 = vg(k4) : (k4 = Ff(c8) ? Df : M3.current, k4 = Ef(b7, k4));
        var C6 = c8.getDerivedStateFromProps;
        (n6 = typeof C6 === "function" || typeof g6.getSnapshotBeforeUpdate === "function") || typeof g6.UNSAFE_componentWillReceiveProps !== "function" && typeof g6.componentWillReceiveProps !== "function" || (h4 !== A3 || p7 !== k4) && Ng(b7, g6, d7, k4);
        wg = false;
        p7 = b7.memoizedState;
        g6.state = p7;
        Cg(b7, d7, g6, e11);
        var x6 = b7.memoizedState;
        h4 !== A3 || p7 !== x6 || N2.current || wg ? (typeof C6 === "function" && (Gg(b7, c8, C6, d7), x6 = b7.memoizedState), (l9 = wg || Lg(b7, c8, l9, d7, p7, x6, k4)) ? (n6 || typeof g6.UNSAFE_componentWillUpdate !== "function" && typeof g6.componentWillUpdate !== "function" || (typeof g6.componentWillUpdate === "function" && g6.componentWillUpdate(d7, x6, k4), typeof g6.UNSAFE_componentWillUpdate === "function" && g6.UNSAFE_componentWillUpdate(d7, x6, k4)), typeof g6.componentDidUpdate === "function" && (b7.flags |= 4), typeof g6.getSnapshotBeforeUpdate === "function" && (b7.flags |= 256)) : (typeof g6.componentDidUpdate !== "function" || h4 === a7.memoizedProps && p7 === a7.memoizedState || (b7.flags |= 4), typeof g6.getSnapshotBeforeUpdate !== "function" || h4 === a7.memoizedProps && p7 === a7.memoizedState || (b7.flags |= 256), b7.memoizedProps = d7, b7.memoizedState = x6), g6.props = d7, g6.state = x6, g6.context = k4, d7 = l9) : (typeof g6.componentDidUpdate !== "function" || h4 === a7.memoizedProps && p7 === a7.memoizedState || (b7.flags |= 4), typeof g6.getSnapshotBeforeUpdate !== "function" || h4 === a7.memoizedProps && p7 === a7.memoizedState || (b7.flags |= 256), d7 = false);
      }
      return qi(a7, b7, c8, d7, f10, e11);
    }
    function qi(a7, b7, c8, d7, e11, f10) {
      oi(a7, b7);
      var g6 = (b7.flags & 64) !== 0;
      if (!d7 && !g6)
        return e11 && Kf(b7, c8, false), hi(a7, b7, f10);
      d7 = b7.stateNode;
      ei.current = b7;
      var h4 = g6 && typeof c8.getDerivedStateFromError !== "function" ? null : d7.render();
      b7.flags |= 1;
      a7 !== null && g6 ? (b7.child = Yg(b7, a7.child, null, f10), b7.child = Yg(b7, null, h4, f10)) : fi(a7, b7, h4, f10);
      b7.memoizedState = d7.state;
      e11 && Kf(b7, c8, true);
      return b7.child;
    }
    function ri(a7) {
      var b7 = a7.stateNode;
      b7.pendingContext ? Hf(a7, b7.pendingContext, b7.pendingContext !== b7.context) : b7.context && Hf(a7, b7.context, false);
      eh(a7, b7.containerInfo);
    }
    var si = { dehydrated: null, retryLane: 0 };
    function ti(a7, b7, c8) {
      var d7 = b7.pendingProps, e11 = P3.current, f10 = false, g6;
      (g6 = (b7.flags & 64) !== 0) || (g6 = a7 !== null && a7.memoizedState === null ? false : (e11 & 2) !== 0);
      g6 ? (f10 = true, b7.flags &= -65) : a7 !== null && a7.memoizedState === null || d7.fallback === void 0 || d7.unstable_avoidThisFallback === true || (e11 |= 1);
      I4(P3, e11 & 1);
      if (a7 === null) {
        d7.fallback !== void 0 && ph(b7);
        a7 = d7.children;
        e11 = d7.fallback;
        if (f10)
          return a7 = ui(b7, a7, e11, c8), b7.child.memoizedState = { baseLanes: c8 }, b7.memoizedState = si, a7;
        if (typeof d7.unstable_expectedLoadTime === "number")
          return a7 = ui(b7, a7, e11, c8), b7.child.memoizedState = { baseLanes: c8 }, b7.memoizedState = si, b7.lanes = 33554432, a7;
        c8 = vi({ mode: "visible", children: a7 }, b7.mode, c8, null);
        c8.return = b7;
        return b7.child = c8;
      }
      if (a7.memoizedState !== null) {
        if (f10)
          return d7 = wi(a7, b7, d7.children, d7.fallback, c8), f10 = b7.child, e11 = a7.child.memoizedState, f10.memoizedState = e11 === null ? { baseLanes: c8 } : { baseLanes: e11.baseLanes | c8 }, f10.childLanes = a7.childLanes & ~c8, b7.memoizedState = si, d7;
        c8 = xi(a7, b7, d7.children, c8);
        b7.memoizedState = null;
        return c8;
      }
      if (f10)
        return d7 = wi(a7, b7, d7.children, d7.fallback, c8), f10 = b7.child, e11 = a7.child.memoizedState, f10.memoizedState = e11 === null ? { baseLanes: c8 } : { baseLanes: e11.baseLanes | c8 }, f10.childLanes = a7.childLanes & ~c8, b7.memoizedState = si, d7;
      c8 = xi(a7, b7, d7.children, c8);
      b7.memoizedState = null;
      return c8;
    }
    function ui(a7, b7, c8, d7) {
      var e11 = a7.mode, f10 = a7.child;
      b7 = { mode: "hidden", children: b7 };
      (e11 & 2) === 0 && f10 !== null ? (f10.childLanes = 0, f10.pendingProps = b7) : f10 = vi(b7, e11, 0, null);
      c8 = Xg(c8, e11, d7, null);
      f10.return = a7;
      c8.return = a7;
      f10.sibling = c8;
      a7.child = f10;
      return c8;
    }
    function xi(a7, b7, c8, d7) {
      var e11 = a7.child;
      a7 = e11.sibling;
      c8 = Tg(e11, { mode: "visible", children: c8 });
      (b7.mode & 2) === 0 && (c8.lanes = d7);
      c8.return = b7;
      c8.sibling = null;
      a7 !== null && (a7.nextEffect = null, a7.flags = 8, b7.firstEffect = b7.lastEffect = a7);
      return b7.child = c8;
    }
    function wi(a7, b7, c8, d7, e11) {
      var f10 = b7.mode, g6 = a7.child;
      a7 = g6.sibling;
      var h4 = { mode: "hidden", children: c8 };
      (f10 & 2) === 0 && b7.child !== g6 ? (c8 = b7.child, c8.childLanes = 0, c8.pendingProps = h4, g6 = c8.lastEffect, g6 !== null ? (b7.firstEffect = c8.firstEffect, b7.lastEffect = g6, g6.nextEffect = null) : b7.firstEffect = b7.lastEffect = null) : c8 = Tg(g6, h4);
      a7 !== null ? d7 = Tg(a7, d7) : (d7 = Xg(d7, f10, e11, null), d7.flags |= 2);
      d7.return = b7;
      c8.return = b7;
      c8.sibling = d7;
      b7.child = c8;
      return d7;
    }
    function yi(a7, b7) {
      a7.lanes |= b7;
      var c8 = a7.alternate;
      c8 !== null && (c8.lanes |= b7);
      sg(a7.return, b7);
    }
    function zi(a7, b7, c8, d7, e11, f10) {
      var g6 = a7.memoizedState;
      g6 === null ? a7.memoizedState = { isBackwards: b7, rendering: null, renderingStartTime: 0, last: d7, tail: c8, tailMode: e11, lastEffect: f10 } : (g6.isBackwards = b7, g6.rendering = null, g6.renderingStartTime = 0, g6.last = d7, g6.tail = c8, g6.tailMode = e11, g6.lastEffect = f10);
    }
    function Ai(a7, b7, c8) {
      var d7 = b7.pendingProps, e11 = d7.revealOrder, f10 = d7.tail;
      fi(a7, b7, d7.children, c8);
      d7 = P3.current;
      if ((d7 & 2) !== 0)
        d7 = d7 & 1 | 2, b7.flags |= 64;
      else {
        if (a7 !== null && (a7.flags & 64) !== 0)
          a:
            for (a7 = b7.child; a7 !== null; ) {
              if (a7.tag === 13)
                a7.memoizedState !== null && yi(a7, c8);
              else if (a7.tag === 19)
                yi(a7, c8);
              else if (a7.child !== null) {
                a7.child.return = a7;
                a7 = a7.child;
                continue;
              }
              if (a7 === b7)
                break a;
              for (; a7.sibling === null; ) {
                if (a7.return === null || a7.return === b7)
                  break a;
                a7 = a7.return;
              }
              a7.sibling.return = a7.return;
              a7 = a7.sibling;
            }
        d7 &= 1;
      }
      I4(P3, d7);
      if ((b7.mode & 2) === 0)
        b7.memoizedState = null;
      else
        switch (e11) {
          case "forwards":
            c8 = b7.child;
            for (e11 = null; c8 !== null; )
              a7 = c8.alternate, a7 !== null && ih(a7) === null && (e11 = c8), c8 = c8.sibling;
            c8 = e11;
            c8 === null ? (e11 = b7.child, b7.child = null) : (e11 = c8.sibling, c8.sibling = null);
            zi(b7, false, e11, c8, f10, b7.lastEffect);
            break;
          case "backwards":
            c8 = null;
            e11 = b7.child;
            for (b7.child = null; e11 !== null; ) {
              a7 = e11.alternate;
              if (a7 !== null && ih(a7) === null) {
                b7.child = e11;
                break;
              }
              a7 = e11.sibling;
              e11.sibling = c8;
              c8 = e11;
              e11 = a7;
            }
            zi(b7, true, c8, null, f10, b7.lastEffect);
            break;
          case "together":
            zi(b7, false, null, null, void 0, b7.lastEffect);
            break;
          default:
            b7.memoizedState = null;
        }
      return b7.child;
    }
    function hi(a7, b7, c8) {
      a7 !== null && (b7.dependencies = a7.dependencies);
      Dg |= b7.lanes;
      if ((c8 & b7.childLanes) !== 0) {
        if (a7 !== null && b7.child !== a7.child)
          throw Error(y5(153));
        if (b7.child !== null) {
          a7 = b7.child;
          c8 = Tg(a7, a7.pendingProps);
          b7.child = c8;
          for (c8.return = b7; a7.sibling !== null; )
            a7 = a7.sibling, c8 = c8.sibling = Tg(a7, a7.pendingProps), c8.return = b7;
          c8.sibling = null;
        }
        return b7.child;
      }
      return null;
    }
    var Bi;
    var Ci;
    var Di;
    var Ei;
    Bi = function(a7, b7) {
      for (var c8 = b7.child; c8 !== null; ) {
        if (c8.tag === 5 || c8.tag === 6)
          a7.appendChild(c8.stateNode);
        else if (c8.tag !== 4 && c8.child !== null) {
          c8.child.return = c8;
          c8 = c8.child;
          continue;
        }
        if (c8 === b7)
          break;
        for (; c8.sibling === null; ) {
          if (c8.return === null || c8.return === b7)
            return;
          c8 = c8.return;
        }
        c8.sibling.return = c8.return;
        c8 = c8.sibling;
      }
    };
    Ci = function() {
    };
    Di = function(a7, b7, c8, d7) {
      var e11 = a7.memoizedProps;
      if (e11 !== d7) {
        a7 = b7.stateNode;
        dh(ah.current);
        var f10 = null;
        switch (c8) {
          case "input":
            e11 = Ya(a7, e11);
            d7 = Ya(a7, d7);
            f10 = [];
            break;
          case "option":
            e11 = eb(a7, e11);
            d7 = eb(a7, d7);
            f10 = [];
            break;
          case "select":
            e11 = m8({}, e11, { value: void 0 });
            d7 = m8({}, d7, { value: void 0 });
            f10 = [];
            break;
          case "textarea":
            e11 = gb(a7, e11);
            d7 = gb(a7, d7);
            f10 = [];
            break;
          default:
            typeof e11.onClick !== "function" && typeof d7.onClick === "function" && (a7.onclick = jf);
        }
        vb(c8, d7);
        var g6;
        c8 = null;
        for (l9 in e11)
          if (!d7.hasOwnProperty(l9) && e11.hasOwnProperty(l9) && e11[l9] != null)
            if (l9 === "style") {
              var h4 = e11[l9];
              for (g6 in h4)
                h4.hasOwnProperty(g6) && (c8 || (c8 = {}), c8[g6] = "");
            } else
              l9 !== "dangerouslySetInnerHTML" && l9 !== "children" && l9 !== "suppressContentEditableWarning" && l9 !== "suppressHydrationWarning" && l9 !== "autoFocus" && (ca.hasOwnProperty(l9) ? f10 || (f10 = []) : (f10 = f10 || []).push(l9, null));
        for (l9 in d7) {
          var k4 = d7[l9];
          h4 = e11 != null ? e11[l9] : void 0;
          if (d7.hasOwnProperty(l9) && k4 !== h4 && (k4 != null || h4 != null))
            if (l9 === "style")
              if (h4) {
                for (g6 in h4)
                  !h4.hasOwnProperty(g6) || k4 && k4.hasOwnProperty(g6) || (c8 || (c8 = {}), c8[g6] = "");
                for (g6 in k4)
                  k4.hasOwnProperty(g6) && h4[g6] !== k4[g6] && (c8 || (c8 = {}), c8[g6] = k4[g6]);
              } else
                c8 || (f10 || (f10 = []), f10.push(l9, c8)), c8 = k4;
            else
              l9 === "dangerouslySetInnerHTML" ? (k4 = k4 ? k4.__html : void 0, h4 = h4 ? h4.__html : void 0, k4 != null && h4 !== k4 && (f10 = f10 || []).push(l9, k4)) : l9 === "children" ? typeof k4 !== "string" && typeof k4 !== "number" || (f10 = f10 || []).push(l9, "" + k4) : l9 !== "suppressContentEditableWarning" && l9 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l9) ? (k4 != null && l9 === "onScroll" && G4("scroll", a7), f10 || h4 === k4 || (f10 = [])) : typeof k4 === "object" && k4 !== null && k4.$$typeof === Ga ? k4.toString() : (f10 = f10 || []).push(l9, k4));
        }
        c8 && (f10 = f10 || []).push("style", c8);
        var l9 = f10;
        if (b7.updateQueue = l9)
          b7.flags |= 4;
      }
    };
    Ei = function(a7, b7, c8, d7) {
      c8 !== d7 && (b7.flags |= 4);
    };
    function Fi(a7, b7) {
      if (!lh)
        switch (a7.tailMode) {
          case "hidden":
            b7 = a7.tail;
            for (var c8 = null; b7 !== null; )
              b7.alternate !== null && (c8 = b7), b7 = b7.sibling;
            c8 === null ? a7.tail = null : c8.sibling = null;
            break;
          case "collapsed":
            c8 = a7.tail;
            for (var d7 = null; c8 !== null; )
              c8.alternate !== null && (d7 = c8), c8 = c8.sibling;
            d7 === null ? b7 || a7.tail === null ? a7.tail = null : a7.tail.sibling = null : d7.sibling = null;
        }
    }
    function Gi(a7, b7, c8) {
      var d7 = b7.pendingProps;
      switch (b7.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return Ff(b7.type) && Gf(), null;
        case 3:
          fh();
          H4(N2);
          H4(M3);
          uh();
          d7 = b7.stateNode;
          d7.pendingContext && (d7.context = d7.pendingContext, d7.pendingContext = null);
          if (a7 === null || a7.child === null)
            rh(b7) ? b7.flags |= 4 : d7.hydrate || (b7.flags |= 256);
          Ci(b7);
          return null;
        case 5:
          hh(b7);
          var e11 = dh(ch.current);
          c8 = b7.type;
          if (a7 !== null && b7.stateNode != null)
            Di(a7, b7, c8, d7, e11), a7.ref !== b7.ref && (b7.flags |= 128);
          else {
            if (!d7) {
              if (b7.stateNode === null)
                throw Error(y5(166));
              return null;
            }
            a7 = dh(ah.current);
            if (rh(b7)) {
              d7 = b7.stateNode;
              c8 = b7.type;
              var f10 = b7.memoizedProps;
              d7[wf] = b7;
              d7[xf] = f10;
              switch (c8) {
                case "dialog":
                  G4("cancel", d7);
                  G4("close", d7);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G4("load", d7);
                  break;
                case "video":
                case "audio":
                  for (a7 = 0; a7 < Xe.length; a7++)
                    G4(Xe[a7], d7);
                  break;
                case "source":
                  G4("error", d7);
                  break;
                case "img":
                case "image":
                case "link":
                  G4("error", d7);
                  G4("load", d7);
                  break;
                case "details":
                  G4("toggle", d7);
                  break;
                case "input":
                  Za(d7, f10);
                  G4("invalid", d7);
                  break;
                case "select":
                  d7._wrapperState = { wasMultiple: !!f10.multiple };
                  G4("invalid", d7);
                  break;
                case "textarea":
                  hb(d7, f10), G4("invalid", d7);
              }
              vb(c8, f10);
              a7 = null;
              for (var g6 in f10)
                f10.hasOwnProperty(g6) && (e11 = f10[g6], g6 === "children" ? typeof e11 === "string" ? d7.textContent !== e11 && (a7 = ["children", e11]) : typeof e11 === "number" && d7.textContent !== "" + e11 && (a7 = ["children", "" + e11]) : ca.hasOwnProperty(g6) && e11 != null && g6 === "onScroll" && G4("scroll", d7));
              switch (c8) {
                case "input":
                  Va(d7);
                  cb(d7, f10, true);
                  break;
                case "textarea":
                  Va(d7);
                  jb(d7);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  typeof f10.onClick === "function" && (d7.onclick = jf);
              }
              d7 = a7;
              b7.updateQueue = d7;
              d7 !== null && (b7.flags |= 4);
            } else {
              g6 = e11.nodeType === 9 ? e11 : e11.ownerDocument;
              a7 === kb.html && (a7 = lb(c8));
              a7 === kb.html ? c8 === "script" ? (a7 = g6.createElement("div"), a7.innerHTML = "<script><\/script>", a7 = a7.removeChild(a7.firstChild)) : typeof d7.is === "string" ? a7 = g6.createElement(c8, { is: d7.is }) : (a7 = g6.createElement(c8), c8 === "select" && (g6 = a7, d7.multiple ? g6.multiple = true : d7.size && (g6.size = d7.size))) : a7 = g6.createElementNS(a7, c8);
              a7[wf] = b7;
              a7[xf] = d7;
              Bi(a7, b7, false, false);
              b7.stateNode = a7;
              g6 = wb(c8, d7);
              switch (c8) {
                case "dialog":
                  G4("cancel", a7);
                  G4("close", a7);
                  e11 = d7;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G4("load", a7);
                  e11 = d7;
                  break;
                case "video":
                case "audio":
                  for (e11 = 0; e11 < Xe.length; e11++)
                    G4(Xe[e11], a7);
                  e11 = d7;
                  break;
                case "source":
                  G4("error", a7);
                  e11 = d7;
                  break;
                case "img":
                case "image":
                case "link":
                  G4("error", a7);
                  G4("load", a7);
                  e11 = d7;
                  break;
                case "details":
                  G4("toggle", a7);
                  e11 = d7;
                  break;
                case "input":
                  Za(a7, d7);
                  e11 = Ya(a7, d7);
                  G4("invalid", a7);
                  break;
                case "option":
                  e11 = eb(a7, d7);
                  break;
                case "select":
                  a7._wrapperState = { wasMultiple: !!d7.multiple };
                  e11 = m8({}, d7, { value: void 0 });
                  G4("invalid", a7);
                  break;
                case "textarea":
                  hb(a7, d7);
                  e11 = gb(a7, d7);
                  G4("invalid", a7);
                  break;
                default:
                  e11 = d7;
              }
              vb(c8, e11);
              var h4 = e11;
              for (f10 in h4)
                if (h4.hasOwnProperty(f10)) {
                  var k4 = h4[f10];
                  f10 === "style" ? tb(a7, k4) : f10 === "dangerouslySetInnerHTML" ? (k4 = k4 ? k4.__html : void 0, k4 != null && ob(a7, k4)) : f10 === "children" ? typeof k4 === "string" ? (c8 !== "textarea" || k4 !== "") && pb(a7, k4) : typeof k4 === "number" && pb(a7, "" + k4) : f10 !== "suppressContentEditableWarning" && f10 !== "suppressHydrationWarning" && f10 !== "autoFocus" && (ca.hasOwnProperty(f10) ? k4 != null && f10 === "onScroll" && G4("scroll", a7) : k4 != null && qa(a7, f10, k4, g6));
                }
              switch (c8) {
                case "input":
                  Va(a7);
                  cb(a7, d7, false);
                  break;
                case "textarea":
                  Va(a7);
                  jb(a7);
                  break;
                case "option":
                  d7.value != null && a7.setAttribute("value", "" + Sa(d7.value));
                  break;
                case "select":
                  a7.multiple = !!d7.multiple;
                  f10 = d7.value;
                  f10 != null ? fb(a7, !!d7.multiple, f10, false) : d7.defaultValue != null && fb(a7, !!d7.multiple, d7.defaultValue, true);
                  break;
                default:
                  typeof e11.onClick === "function" && (a7.onclick = jf);
              }
              mf(c8, d7) && (b7.flags |= 4);
            }
            b7.ref !== null && (b7.flags |= 128);
          }
          return null;
        case 6:
          if (a7 && b7.stateNode != null)
            Ei(a7, b7, a7.memoizedProps, d7);
          else {
            if (typeof d7 !== "string" && b7.stateNode === null)
              throw Error(y5(166));
            c8 = dh(ch.current);
            dh(ah.current);
            rh(b7) ? (d7 = b7.stateNode, c8 = b7.memoizedProps, d7[wf] = b7, d7.nodeValue !== c8 && (b7.flags |= 4)) : (d7 = (c8.nodeType === 9 ? c8 : c8.ownerDocument).createTextNode(d7), d7[wf] = b7, b7.stateNode = d7);
          }
          return null;
        case 13:
          H4(P3);
          d7 = b7.memoizedState;
          if ((b7.flags & 64) !== 0)
            return b7.lanes = c8, b7;
          d7 = d7 !== null;
          c8 = false;
          a7 === null ? b7.memoizedProps.fallback !== void 0 && rh(b7) : c8 = a7.memoizedState !== null;
          if (d7 && !c8 && (b7.mode & 2) !== 0)
            if (a7 === null && b7.memoizedProps.unstable_avoidThisFallback !== true || (P3.current & 1) !== 0)
              V5 === 0 && (V5 = 3);
            else {
              if (V5 === 0 || V5 === 3)
                V5 = 4;
              U3 === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U3, W4);
            }
          if (d7 || c8)
            b7.flags |= 4;
          return null;
        case 4:
          return fh(), Ci(b7), a7 === null && cf(b7.stateNode.containerInfo), null;
        case 10:
          return rg(b7), null;
        case 17:
          return Ff(b7.type) && Gf(), null;
        case 19:
          H4(P3);
          d7 = b7.memoizedState;
          if (d7 === null)
            return null;
          f10 = (b7.flags & 64) !== 0;
          g6 = d7.rendering;
          if (g6 === null)
            if (f10)
              Fi(d7, false);
            else {
              if (V5 !== 0 || a7 !== null && (a7.flags & 64) !== 0)
                for (a7 = b7.child; a7 !== null; ) {
                  g6 = ih(a7);
                  if (g6 !== null) {
                    b7.flags |= 64;
                    Fi(d7, false);
                    f10 = g6.updateQueue;
                    f10 !== null && (b7.updateQueue = f10, b7.flags |= 4);
                    d7.lastEffect === null && (b7.firstEffect = null);
                    b7.lastEffect = d7.lastEffect;
                    d7 = c8;
                    for (c8 = b7.child; c8 !== null; )
                      f10 = c8, a7 = d7, f10.flags &= 2, f10.nextEffect = null, f10.firstEffect = null, f10.lastEffect = null, g6 = f10.alternate, g6 === null ? (f10.childLanes = 0, f10.lanes = a7, f10.child = null, f10.memoizedProps = null, f10.memoizedState = null, f10.updateQueue = null, f10.dependencies = null, f10.stateNode = null) : (f10.childLanes = g6.childLanes, f10.lanes = g6.lanes, f10.child = g6.child, f10.memoizedProps = g6.memoizedProps, f10.memoizedState = g6.memoizedState, f10.updateQueue = g6.updateQueue, f10.type = g6.type, a7 = g6.dependencies, f10.dependencies = a7 === null ? null : { lanes: a7.lanes, firstContext: a7.firstContext }), c8 = c8.sibling;
                    I4(P3, P3.current & 1 | 2);
                    return b7.child;
                  }
                  a7 = a7.sibling;
                }
              d7.tail !== null && O4() > Ji && (b7.flags |= 64, f10 = true, Fi(d7, false), b7.lanes = 33554432);
            }
          else {
            if (!f10)
              if (a7 = ih(g6), a7 !== null) {
                if (b7.flags |= 64, f10 = true, c8 = a7.updateQueue, c8 !== null && (b7.updateQueue = c8, b7.flags |= 4), Fi(d7, true), d7.tail === null && d7.tailMode === "hidden" && !g6.alternate && !lh)
                  return b7 = b7.lastEffect = d7.lastEffect, b7 !== null && (b7.nextEffect = null), null;
              } else
                2 * O4() - d7.renderingStartTime > Ji && c8 !== 1073741824 && (b7.flags |= 64, f10 = true, Fi(d7, false), b7.lanes = 33554432);
            d7.isBackwards ? (g6.sibling = b7.child, b7.child = g6) : (c8 = d7.last, c8 !== null ? c8.sibling = g6 : b7.child = g6, d7.last = g6);
          }
          return d7.tail !== null ? (c8 = d7.tail, d7.rendering = c8, d7.tail = c8.sibling, d7.lastEffect = b7.lastEffect, d7.renderingStartTime = O4(), c8.sibling = null, b7 = P3.current, I4(P3, f10 ? b7 & 1 | 2 : b7 & 1), c8) : null;
        case 23:
        case 24:
          return Ki(), a7 !== null && a7.memoizedState !== null !== (b7.memoizedState !== null) && d7.mode !== "unstable-defer-without-hiding" && (b7.flags |= 4), null;
      }
      throw Error(y5(156, b7.tag));
    }
    function Li(a7) {
      switch (a7.tag) {
        case 1:
          Ff(a7.type) && Gf();
          var b7 = a7.flags;
          return b7 & 4096 ? (a7.flags = b7 & -4097 | 64, a7) : null;
        case 3:
          fh();
          H4(N2);
          H4(M3);
          uh();
          b7 = a7.flags;
          if ((b7 & 64) !== 0)
            throw Error(y5(285));
          a7.flags = b7 & -4097 | 64;
          return a7;
        case 5:
          return hh(a7), null;
        case 13:
          return H4(P3), b7 = a7.flags, b7 & 4096 ? (a7.flags = b7 & -4097 | 64, a7) : null;
        case 19:
          return H4(P3), null;
        case 4:
          return fh(), null;
        case 10:
          return rg(a7), null;
        case 23:
        case 24:
          return Ki(), null;
        default:
          return null;
      }
    }
    function Mi(a7, b7) {
      try {
        var c8 = "", d7 = b7;
        do
          c8 += Qa(d7), d7 = d7.return;
        while (d7);
        var e11 = c8;
      } catch (f10) {
        e11 = "\nError generating stack: " + f10.message + "\n" + f10.stack;
      }
      return { value: a7, source: b7, stack: e11 };
    }
    function Ni(a7, b7) {
      try {
        console.error(b7.value);
      } catch (c8) {
        setTimeout(function() {
          throw c8;
        });
      }
    }
    var Oi = typeof WeakMap === "function" ? WeakMap : Map;
    function Pi(a7, b7, c8) {
      c8 = zg(-1, c8);
      c8.tag = 3;
      c8.payload = { element: null };
      var d7 = b7.value;
      c8.callback = function() {
        Qi || (Qi = true, Ri = d7);
        Ni(a7, b7);
      };
      return c8;
    }
    function Si(a7, b7, c8) {
      c8 = zg(-1, c8);
      c8.tag = 3;
      var d7 = a7.type.getDerivedStateFromError;
      if (typeof d7 === "function") {
        var e11 = b7.value;
        c8.payload = function() {
          Ni(a7, b7);
          return d7(e11);
        };
      }
      var f10 = a7.stateNode;
      f10 !== null && typeof f10.componentDidCatch === "function" && (c8.callback = function() {
        typeof d7 !== "function" && (Ti === null ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a7, b7));
        var c9 = b7.stack;
        this.componentDidCatch(b7.value, { componentStack: c9 !== null ? c9 : "" });
      });
      return c8;
    }
    var Ui = typeof WeakSet === "function" ? WeakSet : Set;
    function Vi(a7) {
      var b7 = a7.ref;
      if (b7 !== null)
        if (typeof b7 === "function")
          try {
            b7(null);
          } catch (c8) {
            Wi(a7, c8);
          }
        else
          b7.current = null;
    }
    function Xi(a7, b7) {
      switch (b7.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b7.flags & 256 && a7 !== null) {
            var c8 = a7.memoizedProps, d7 = a7.memoizedState;
            a7 = b7.stateNode;
            b7 = a7.getSnapshotBeforeUpdate(b7.elementType === b7.type ? c8 : lg(b7.type, c8), d7);
            a7.__reactInternalSnapshotBeforeUpdate = b7;
          }
          return;
        case 3:
          b7.flags & 256 && qf(b7.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(y5(163));
    }
    function Yi(a7, b7, c8) {
      switch (c8.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b7 = c8.updateQueue;
          b7 = b7 !== null ? b7.lastEffect : null;
          if (b7 !== null) {
            a7 = b7 = b7.next;
            do {
              if ((a7.tag & 3) === 3) {
                var d7 = a7.create;
                a7.destroy = d7();
              }
              a7 = a7.next;
            } while (a7 !== b7);
          }
          b7 = c8.updateQueue;
          b7 = b7 !== null ? b7.lastEffect : null;
          if (b7 !== null) {
            a7 = b7 = b7.next;
            do {
              var e11 = a7;
              d7 = e11.next;
              e11 = e11.tag;
              (e11 & 4) !== 0 && (e11 & 1) !== 0 && (Zi(c8, a7), $i(c8, a7));
              a7 = d7;
            } while (a7 !== b7);
          }
          return;
        case 1:
          a7 = c8.stateNode;
          c8.flags & 4 && (b7 === null ? a7.componentDidMount() : (d7 = c8.elementType === c8.type ? b7.memoizedProps : lg(c8.type, b7.memoizedProps), a7.componentDidUpdate(d7, b7.memoizedState, a7.__reactInternalSnapshotBeforeUpdate)));
          b7 = c8.updateQueue;
          b7 !== null && Eg(c8, b7, a7);
          return;
        case 3:
          b7 = c8.updateQueue;
          if (b7 !== null) {
            a7 = null;
            if (c8.child !== null)
              switch (c8.child.tag) {
                case 5:
                  a7 = c8.child.stateNode;
                  break;
                case 1:
                  a7 = c8.child.stateNode;
              }
            Eg(c8, b7, a7);
          }
          return;
        case 5:
          a7 = c8.stateNode;
          b7 === null && c8.flags & 4 && mf(c8.type, c8.memoizedProps) && a7.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          c8.memoizedState === null && (c8 = c8.alternate, c8 !== null && (c8 = c8.memoizedState, c8 !== null && (c8 = c8.dehydrated, c8 !== null && Cc(c8))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(y5(163));
    }
    function aj(a7, b7) {
      for (var c8 = a7; ; ) {
        if (c8.tag === 5) {
          var d7 = c8.stateNode;
          if (b7)
            d7 = d7.style, typeof d7.setProperty === "function" ? d7.setProperty("display", "none", "important") : d7.display = "none";
          else {
            d7 = c8.stateNode;
            var e11 = c8.memoizedProps.style;
            e11 = e11 !== void 0 && e11 !== null && e11.hasOwnProperty("display") ? e11.display : null;
            d7.style.display = sb("display", e11);
          }
        } else if (c8.tag === 6)
          c8.stateNode.nodeValue = b7 ? "" : c8.memoizedProps;
        else if ((c8.tag !== 23 && c8.tag !== 24 || c8.memoizedState === null || c8 === a7) && c8.child !== null) {
          c8.child.return = c8;
          c8 = c8.child;
          continue;
        }
        if (c8 === a7)
          break;
        for (; c8.sibling === null; ) {
          if (c8.return === null || c8.return === a7)
            return;
          c8 = c8.return;
        }
        c8.sibling.return = c8.return;
        c8 = c8.sibling;
      }
    }
    function bj(a7, b7) {
      if (Mf && typeof Mf.onCommitFiberUnmount === "function")
        try {
          Mf.onCommitFiberUnmount(Lf, b7);
        } catch (f10) {
        }
      switch (b7.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a7 = b7.updateQueue;
          if (a7 !== null && (a7 = a7.lastEffect, a7 !== null)) {
            var c8 = a7 = a7.next;
            do {
              var d7 = c8, e11 = d7.destroy;
              d7 = d7.tag;
              if (e11 !== void 0)
                if ((d7 & 4) !== 0)
                  Zi(b7, c8);
                else {
                  d7 = b7;
                  try {
                    e11();
                  } catch (f10) {
                    Wi(d7, f10);
                  }
                }
              c8 = c8.next;
            } while (c8 !== a7);
          }
          break;
        case 1:
          Vi(b7);
          a7 = b7.stateNode;
          if (typeof a7.componentWillUnmount === "function")
            try {
              a7.props = b7.memoizedProps, a7.state = b7.memoizedState, a7.componentWillUnmount();
            } catch (f10) {
              Wi(b7, f10);
            }
          break;
        case 5:
          Vi(b7);
          break;
        case 4:
          cj(a7, b7);
      }
    }
    function dj(a7) {
      a7.alternate = null;
      a7.child = null;
      a7.dependencies = null;
      a7.firstEffect = null;
      a7.lastEffect = null;
      a7.memoizedProps = null;
      a7.memoizedState = null;
      a7.pendingProps = null;
      a7.return = null;
      a7.updateQueue = null;
    }
    function ej(a7) {
      return a7.tag === 5 || a7.tag === 3 || a7.tag === 4;
    }
    function fj(a7) {
      a: {
        for (var b7 = a7.return; b7 !== null; ) {
          if (ej(b7))
            break a;
          b7 = b7.return;
        }
        throw Error(y5(160));
      }
      var c8 = b7;
      b7 = c8.stateNode;
      switch (c8.tag) {
        case 5:
          var d7 = false;
          break;
        case 3:
          b7 = b7.containerInfo;
          d7 = true;
          break;
        case 4:
          b7 = b7.containerInfo;
          d7 = true;
          break;
        default:
          throw Error(y5(161));
      }
      c8.flags & 16 && (pb(b7, ""), c8.flags &= -17);
      a:
        b:
          for (c8 = a7; ; ) {
            for (; c8.sibling === null; ) {
              if (c8.return === null || ej(c8.return)) {
                c8 = null;
                break a;
              }
              c8 = c8.return;
            }
            c8.sibling.return = c8.return;
            for (c8 = c8.sibling; c8.tag !== 5 && c8.tag !== 6 && c8.tag !== 18; ) {
              if (c8.flags & 2)
                continue b;
              if (c8.child === null || c8.tag === 4)
                continue b;
              else
                c8.child.return = c8, c8 = c8.child;
            }
            if (!(c8.flags & 2)) {
              c8 = c8.stateNode;
              break a;
            }
          }
      d7 ? gj(a7, c8, b7) : hj(a7, c8, b7);
    }
    function gj(a7, b7, c8) {
      var d7 = a7.tag, e11 = d7 === 5 || d7 === 6;
      if (e11)
        a7 = e11 ? a7.stateNode : a7.stateNode.instance, b7 ? c8.nodeType === 8 ? c8.parentNode.insertBefore(a7, b7) : c8.insertBefore(a7, b7) : (c8.nodeType === 8 ? (b7 = c8.parentNode, b7.insertBefore(a7, c8)) : (b7 = c8, b7.appendChild(a7)), c8 = c8._reactRootContainer, c8 !== null && c8 !== void 0 || b7.onclick !== null || (b7.onclick = jf));
      else if (d7 !== 4 && (a7 = a7.child, a7 !== null))
        for (gj(a7, b7, c8), a7 = a7.sibling; a7 !== null; )
          gj(a7, b7, c8), a7 = a7.sibling;
    }
    function hj(a7, b7, c8) {
      var d7 = a7.tag, e11 = d7 === 5 || d7 === 6;
      if (e11)
        a7 = e11 ? a7.stateNode : a7.stateNode.instance, b7 ? c8.insertBefore(a7, b7) : c8.appendChild(a7);
      else if (d7 !== 4 && (a7 = a7.child, a7 !== null))
        for (hj(a7, b7, c8), a7 = a7.sibling; a7 !== null; )
          hj(a7, b7, c8), a7 = a7.sibling;
    }
    function cj(a7, b7) {
      for (var c8 = b7, d7 = false, e11, f10; ; ) {
        if (!d7) {
          d7 = c8.return;
          a:
            for (; ; ) {
              if (d7 === null)
                throw Error(y5(160));
              e11 = d7.stateNode;
              switch (d7.tag) {
                case 5:
                  f10 = false;
                  break a;
                case 3:
                  e11 = e11.containerInfo;
                  f10 = true;
                  break a;
                case 4:
                  e11 = e11.containerInfo;
                  f10 = true;
                  break a;
              }
              d7 = d7.return;
            }
          d7 = true;
        }
        if (c8.tag === 5 || c8.tag === 6) {
          a:
            for (var g6 = a7, h4 = c8, k4 = h4; ; )
              if (bj(g6, k4), k4.child !== null && k4.tag !== 4)
                k4.child.return = k4, k4 = k4.child;
              else {
                if (k4 === h4)
                  break a;
                for (; k4.sibling === null; ) {
                  if (k4.return === null || k4.return === h4)
                    break a;
                  k4 = k4.return;
                }
                k4.sibling.return = k4.return;
                k4 = k4.sibling;
              }
          f10 ? (g6 = e11, h4 = c8.stateNode, g6.nodeType === 8 ? g6.parentNode.removeChild(h4) : g6.removeChild(h4)) : e11.removeChild(c8.stateNode);
        } else if (c8.tag === 4) {
          if (c8.child !== null) {
            e11 = c8.stateNode.containerInfo;
            f10 = true;
            c8.child.return = c8;
            c8 = c8.child;
            continue;
          }
        } else if (bj(a7, c8), c8.child !== null) {
          c8.child.return = c8;
          c8 = c8.child;
          continue;
        }
        if (c8 === b7)
          break;
        for (; c8.sibling === null; ) {
          if (c8.return === null || c8.return === b7)
            return;
          c8 = c8.return;
          c8.tag === 4 && (d7 = false);
        }
        c8.sibling.return = c8.return;
        c8 = c8.sibling;
      }
    }
    function ij(a7, b7) {
      switch (b7.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          var c8 = b7.updateQueue;
          c8 = c8 !== null ? c8.lastEffect : null;
          if (c8 !== null) {
            var d7 = c8 = c8.next;
            do
              (d7.tag & 3) === 3 && (a7 = d7.destroy, d7.destroy = void 0, a7 !== void 0 && a7()), d7 = d7.next;
            while (d7 !== c8);
          }
          return;
        case 1:
          return;
        case 5:
          c8 = b7.stateNode;
          if (c8 != null) {
            d7 = b7.memoizedProps;
            var e11 = a7 !== null ? a7.memoizedProps : d7;
            a7 = b7.type;
            var f10 = b7.updateQueue;
            b7.updateQueue = null;
            if (f10 !== null) {
              c8[xf] = d7;
              a7 === "input" && d7.type === "radio" && d7.name != null && $a(c8, d7);
              wb(a7, e11);
              b7 = wb(a7, d7);
              for (e11 = 0; e11 < f10.length; e11 += 2) {
                var g6 = f10[e11], h4 = f10[e11 + 1];
                g6 === "style" ? tb(c8, h4) : g6 === "dangerouslySetInnerHTML" ? ob(c8, h4) : g6 === "children" ? pb(c8, h4) : qa(c8, g6, h4, b7);
              }
              switch (a7) {
                case "input":
                  ab(c8, d7);
                  break;
                case "textarea":
                  ib(c8, d7);
                  break;
                case "select":
                  a7 = c8._wrapperState.wasMultiple, c8._wrapperState.wasMultiple = !!d7.multiple, f10 = d7.value, f10 != null ? fb(c8, !!d7.multiple, f10, false) : a7 !== !!d7.multiple && (d7.defaultValue != null ? fb(c8, !!d7.multiple, d7.defaultValue, true) : fb(c8, !!d7.multiple, d7.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (b7.stateNode === null)
            throw Error(y5(162));
          b7.stateNode.nodeValue = b7.memoizedProps;
          return;
        case 3:
          c8 = b7.stateNode;
          c8.hydrate && (c8.hydrate = false, Cc(c8.containerInfo));
          return;
        case 12:
          return;
        case 13:
          b7.memoizedState !== null && (jj = O4(), aj(b7.child, true));
          kj(b7);
          return;
        case 19:
          kj(b7);
          return;
        case 17:
          return;
        case 23:
        case 24:
          aj(b7, b7.memoizedState !== null);
          return;
      }
      throw Error(y5(163));
    }
    function kj(a7) {
      var b7 = a7.updateQueue;
      if (b7 !== null) {
        a7.updateQueue = null;
        var c8 = a7.stateNode;
        c8 === null && (c8 = a7.stateNode = new Ui());
        b7.forEach(function(b8) {
          var d7 = lj.bind(null, a7, b8);
          c8.has(b8) || (c8.add(b8), b8.then(d7, d7));
        });
      }
    }
    function mj(a7, b7) {
      return a7 !== null && (a7 = a7.memoizedState, a7 === null || a7.dehydrated !== null) ? (b7 = b7.memoizedState, b7 !== null && b7.dehydrated === null) : false;
    }
    var nj = Math.ceil;
    var oj = ra.ReactCurrentDispatcher;
    var pj = ra.ReactCurrentOwner;
    var X3 = 0;
    var U3 = null;
    var Y4 = null;
    var W4 = 0;
    var qj = 0;
    var rj = Bf(0);
    var V5 = 0;
    var sj = null;
    var tj = 0;
    var Dg = 0;
    var Hi = 0;
    var uj = 0;
    var vj = null;
    var jj = 0;
    var Ji = Infinity;
    function wj() {
      Ji = O4() + 500;
    }
    var Z4 = null;
    var Qi = false;
    var Ri = null;
    var Ti = null;
    var xj = false;
    var yj = null;
    var zj = 90;
    var Aj = [];
    var Bj = [];
    var Cj = null;
    var Dj = 0;
    var Ej = null;
    var Fj = -1;
    var Gj = 0;
    var Hj = 0;
    var Ij = null;
    var Jj = false;
    function Hg() {
      return (X3 & 48) !== 0 ? O4() : Fj !== -1 ? Fj : Fj = O4();
    }
    function Ig(a7) {
      a7 = a7.mode;
      if ((a7 & 2) === 0)
        return 1;
      if ((a7 & 4) === 0)
        return eg() === 99 ? 1 : 2;
      Gj === 0 && (Gj = tj);
      if (kg.transition !== 0) {
        Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
        a7 = Gj;
        var b7 = 4186112 & ~Hj;
        b7 &= -b7;
        b7 === 0 && (a7 = 4186112 & ~a7, b7 = a7 & -a7, b7 === 0 && (b7 = 8192));
        return b7;
      }
      a7 = eg();
      (X3 & 4) !== 0 && a7 === 98 ? a7 = Xc(12, Gj) : (a7 = Sc(a7), a7 = Xc(a7, Gj));
      return a7;
    }
    function Jg(a7, b7, c8) {
      if (50 < Dj)
        throw Dj = 0, Ej = null, Error(y5(185));
      a7 = Kj(a7, b7);
      if (a7 === null)
        return null;
      $c(a7, b7, c8);
      a7 === U3 && (Hi |= b7, V5 === 4 && Ii(a7, W4));
      var d7 = eg();
      b7 === 1 ? (X3 & 8) !== 0 && (X3 & 48) === 0 ? Lj(a7) : (Mj(a7, c8), X3 === 0 && (wj(), ig())) : ((X3 & 4) === 0 || d7 !== 98 && d7 !== 99 || (Cj === null ? Cj = /* @__PURE__ */ new Set([a7]) : Cj.add(a7)), Mj(a7, c8));
      vj = a7;
    }
    function Kj(a7, b7) {
      a7.lanes |= b7;
      var c8 = a7.alternate;
      c8 !== null && (c8.lanes |= b7);
      c8 = a7;
      for (a7 = a7.return; a7 !== null; )
        a7.childLanes |= b7, c8 = a7.alternate, c8 !== null && (c8.childLanes |= b7), c8 = a7, a7 = a7.return;
      return c8.tag === 3 ? c8.stateNode : null;
    }
    function Mj(a7, b7) {
      for (var c8 = a7.callbackNode, d7 = a7.suspendedLanes, e11 = a7.pingedLanes, f10 = a7.expirationTimes, g6 = a7.pendingLanes; 0 < g6; ) {
        var h4 = 31 - Vc(g6), k4 = 1 << h4, l9 = f10[h4];
        if (l9 === -1) {
          if ((k4 & d7) === 0 || (k4 & e11) !== 0) {
            l9 = b7;
            Rc(k4);
            var n6 = F5;
            f10[h4] = 10 <= n6 ? l9 + 250 : 6 <= n6 ? l9 + 5e3 : -1;
          }
        } else
          l9 <= b7 && (a7.expiredLanes |= k4);
        g6 &= ~k4;
      }
      d7 = Uc(a7, a7 === U3 ? W4 : 0);
      b7 = F5;
      if (d7 === 0)
        c8 !== null && (c8 !== Zf && Pf(c8), a7.callbackNode = null, a7.callbackPriority = 0);
      else {
        if (c8 !== null) {
          if (a7.callbackPriority === b7)
            return;
          c8 !== Zf && Pf(c8);
        }
        b7 === 15 ? (c8 = Lj.bind(null, a7), ag === null ? (ag = [c8], bg = Of(Uf, jg)) : ag.push(c8), c8 = Zf) : b7 === 14 ? c8 = hg(99, Lj.bind(null, a7)) : (c8 = Tc(b7), c8 = hg(c8, Nj.bind(null, a7)));
        a7.callbackPriority = b7;
        a7.callbackNode = c8;
      }
    }
    function Nj(a7) {
      Fj = -1;
      Hj = Gj = 0;
      if ((X3 & 48) !== 0)
        throw Error(y5(327));
      var b7 = a7.callbackNode;
      if (Oj() && a7.callbackNode !== b7)
        return null;
      var c8 = Uc(a7, a7 === U3 ? W4 : 0);
      if (c8 === 0)
        return null;
      var d7 = c8;
      var e11 = X3;
      X3 |= 16;
      var f10 = Pj();
      if (U3 !== a7 || W4 !== d7)
        wj(), Qj(a7, d7);
      do
        try {
          Rj();
          break;
        } catch (h4) {
          Sj(a7, h4);
        }
      while (1);
      qg();
      oj.current = f10;
      X3 = e11;
      Y4 !== null ? d7 = 0 : (U3 = null, W4 = 0, d7 = V5);
      if ((tj & Hi) !== 0)
        Qj(a7, 0);
      else if (d7 !== 0) {
        d7 === 2 && (X3 |= 64, a7.hydrate && (a7.hydrate = false, qf(a7.containerInfo)), c8 = Wc(a7), c8 !== 0 && (d7 = Tj(a7, c8)));
        if (d7 === 1)
          throw b7 = sj, Qj(a7, 0), Ii(a7, c8), Mj(a7, O4()), b7;
        a7.finishedWork = a7.current.alternate;
        a7.finishedLanes = c8;
        switch (d7) {
          case 0:
          case 1:
            throw Error(y5(345));
          case 2:
            Uj(a7);
            break;
          case 3:
            Ii(a7, c8);
            if ((c8 & 62914560) === c8 && (d7 = jj + 500 - O4(), 10 < d7)) {
              if (Uc(a7, 0) !== 0)
                break;
              e11 = a7.suspendedLanes;
              if ((e11 & c8) !== c8) {
                Hg();
                a7.pingedLanes |= a7.suspendedLanes & e11;
                break;
              }
              a7.timeoutHandle = of(Uj.bind(null, a7), d7);
              break;
            }
            Uj(a7);
            break;
          case 4:
            Ii(a7, c8);
            if ((c8 & 4186112) === c8)
              break;
            d7 = a7.eventTimes;
            for (e11 = -1; 0 < c8; ) {
              var g6 = 31 - Vc(c8);
              f10 = 1 << g6;
              g6 = d7[g6];
              g6 > e11 && (e11 = g6);
              c8 &= ~f10;
            }
            c8 = e11;
            c8 = O4() - c8;
            c8 = (120 > c8 ? 120 : 480 > c8 ? 480 : 1080 > c8 ? 1080 : 1920 > c8 ? 1920 : 3e3 > c8 ? 3e3 : 4320 > c8 ? 4320 : 1960 * nj(c8 / 1960)) - c8;
            if (10 < c8) {
              a7.timeoutHandle = of(Uj.bind(null, a7), c8);
              break;
            }
            Uj(a7);
            break;
          case 5:
            Uj(a7);
            break;
          default:
            throw Error(y5(329));
        }
      }
      Mj(a7, O4());
      return a7.callbackNode === b7 ? Nj.bind(null, a7) : null;
    }
    function Ii(a7, b7) {
      b7 &= ~uj;
      b7 &= ~Hi;
      a7.suspendedLanes |= b7;
      a7.pingedLanes &= ~b7;
      for (a7 = a7.expirationTimes; 0 < b7; ) {
        var c8 = 31 - Vc(b7), d7 = 1 << c8;
        a7[c8] = -1;
        b7 &= ~d7;
      }
    }
    function Lj(a7) {
      if ((X3 & 48) !== 0)
        throw Error(y5(327));
      Oj();
      if (a7 === U3 && (a7.expiredLanes & W4) !== 0) {
        var b7 = W4;
        var c8 = Tj(a7, b7);
        (tj & Hi) !== 0 && (b7 = Uc(a7, b7), c8 = Tj(a7, b7));
      } else
        b7 = Uc(a7, 0), c8 = Tj(a7, b7);
      a7.tag !== 0 && c8 === 2 && (X3 |= 64, a7.hydrate && (a7.hydrate = false, qf(a7.containerInfo)), b7 = Wc(a7), b7 !== 0 && (c8 = Tj(a7, b7)));
      if (c8 === 1)
        throw c8 = sj, Qj(a7, 0), Ii(a7, b7), Mj(a7, O4()), c8;
      a7.finishedWork = a7.current.alternate;
      a7.finishedLanes = b7;
      Uj(a7);
      Mj(a7, O4());
      return null;
    }
    function Vj() {
      if (Cj !== null) {
        var a7 = Cj;
        Cj = null;
        a7.forEach(function(a8) {
          a8.expiredLanes |= 24 & a8.pendingLanes;
          Mj(a8, O4());
        });
      }
      ig();
    }
    function Wj(a7, b7) {
      var c8 = X3;
      X3 |= 1;
      try {
        return a7(b7);
      } finally {
        X3 = c8, X3 === 0 && (wj(), ig());
      }
    }
    function Xj(a7, b7) {
      var c8 = X3;
      X3 &= -2;
      X3 |= 8;
      try {
        return a7(b7);
      } finally {
        X3 = c8, X3 === 0 && (wj(), ig());
      }
    }
    function ni(a7, b7) {
      I4(rj, qj);
      qj |= b7;
      tj |= b7;
    }
    function Ki() {
      qj = rj.current;
      H4(rj);
    }
    function Qj(a7, b7) {
      a7.finishedWork = null;
      a7.finishedLanes = 0;
      var c8 = a7.timeoutHandle;
      c8 !== -1 && (a7.timeoutHandle = -1, pf(c8));
      if (Y4 !== null)
        for (c8 = Y4.return; c8 !== null; ) {
          var d7 = c8;
          switch (d7.tag) {
            case 1:
              d7 = d7.type.childContextTypes;
              d7 !== null && d7 !== void 0 && Gf();
              break;
            case 3:
              fh();
              H4(N2);
              H4(M3);
              uh();
              break;
            case 5:
              hh(d7);
              break;
            case 4:
              fh();
              break;
            case 13:
              H4(P3);
              break;
            case 19:
              H4(P3);
              break;
            case 10:
              rg(d7);
              break;
            case 23:
            case 24:
              Ki();
          }
          c8 = c8.return;
        }
      U3 = a7;
      Y4 = Tg(a7.current, null);
      W4 = qj = tj = b7;
      V5 = 0;
      sj = null;
      uj = Hi = Dg = 0;
    }
    function Sj(a7, b7) {
      do {
        var c8 = Y4;
        try {
          qg();
          vh.current = Gh;
          if (yh) {
            for (var d7 = R5.memoizedState; d7 !== null; ) {
              var e11 = d7.queue;
              e11 !== null && (e11.pending = null);
              d7 = d7.next;
            }
            yh = false;
          }
          xh = 0;
          T5 = S3 = R5 = null;
          zh = false;
          pj.current = null;
          if (c8 === null || c8.return === null) {
            V5 = 1;
            sj = b7;
            Y4 = null;
            break;
          }
          a: {
            var f10 = a7, g6 = c8.return, h4 = c8, k4 = b7;
            b7 = W4;
            h4.flags |= 2048;
            h4.firstEffect = h4.lastEffect = null;
            if (k4 !== null && typeof k4 === "object" && typeof k4.then === "function") {
              var l9 = k4;
              if ((h4.mode & 2) === 0) {
                var n6 = h4.alternate;
                n6 ? (h4.updateQueue = n6.updateQueue, h4.memoizedState = n6.memoizedState, h4.lanes = n6.lanes) : (h4.updateQueue = null, h4.memoizedState = null);
              }
              var A3 = (P3.current & 1) !== 0, p7 = g6;
              do {
                var C6;
                if (C6 = p7.tag === 13) {
                  var x6 = p7.memoizedState;
                  if (x6 !== null)
                    C6 = x6.dehydrated !== null ? true : false;
                  else {
                    var w6 = p7.memoizedProps;
                    C6 = w6.fallback === void 0 ? false : w6.unstable_avoidThisFallback !== true ? true : A3 ? false : true;
                  }
                }
                if (C6) {
                  var z3 = p7.updateQueue;
                  if (z3 === null) {
                    var u4 = /* @__PURE__ */ new Set();
                    u4.add(l9);
                    p7.updateQueue = u4;
                  } else
                    z3.add(l9);
                  if ((p7.mode & 2) === 0) {
                    p7.flags |= 64;
                    h4.flags |= 16384;
                    h4.flags &= -2981;
                    if (h4.tag === 1)
                      if (h4.alternate === null)
                        h4.tag = 17;
                      else {
                        var t12 = zg(-1, 1);
                        t12.tag = 2;
                        Ag(h4, t12);
                      }
                    h4.lanes |= 1;
                    break a;
                  }
                  k4 = void 0;
                  h4 = b7;
                  var q3 = f10.pingCache;
                  q3 === null ? (q3 = f10.pingCache = new Oi(), k4 = /* @__PURE__ */ new Set(), q3.set(l9, k4)) : (k4 = q3.get(l9), k4 === void 0 && (k4 = /* @__PURE__ */ new Set(), q3.set(l9, k4)));
                  if (!k4.has(h4)) {
                    k4.add(h4);
                    var v6 = Yj.bind(null, f10, l9, h4);
                    l9.then(v6, v6);
                  }
                  p7.flags |= 4096;
                  p7.lanes = b7;
                  break a;
                }
                p7 = p7.return;
              } while (p7 !== null);
              k4 = Error((Ra(h4.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            V5 !== 5 && (V5 = 2);
            k4 = Mi(k4, h4);
            p7 = g6;
            do {
              switch (p7.tag) {
                case 3:
                  f10 = k4;
                  p7.flags |= 4096;
                  b7 &= -b7;
                  p7.lanes |= b7;
                  var J4 = Pi(p7, f10, b7);
                  Bg(p7, J4);
                  break a;
                case 1:
                  f10 = k4;
                  var K3 = p7.type, Q = p7.stateNode;
                  if ((p7.flags & 64) === 0 && (typeof K3.getDerivedStateFromError === "function" || Q !== null && typeof Q.componentDidCatch === "function" && (Ti === null || !Ti.has(Q)))) {
                    p7.flags |= 4096;
                    b7 &= -b7;
                    p7.lanes |= b7;
                    var L4 = Si(p7, f10, b7);
                    Bg(p7, L4);
                    break a;
                  }
              }
              p7 = p7.return;
            } while (p7 !== null);
          }
          Zj(c8);
        } catch (va) {
          b7 = va;
          Y4 === c8 && c8 !== null && (Y4 = c8 = c8.return);
          continue;
        }
        break;
      } while (1);
    }
    function Pj() {
      var a7 = oj.current;
      oj.current = Gh;
      return a7 === null ? Gh : a7;
    }
    function Tj(a7, b7) {
      var c8 = X3;
      X3 |= 16;
      var d7 = Pj();
      U3 === a7 && W4 === b7 || Qj(a7, b7);
      do
        try {
          ak();
          break;
        } catch (e11) {
          Sj(a7, e11);
        }
      while (1);
      qg();
      X3 = c8;
      oj.current = d7;
      if (Y4 !== null)
        throw Error(y5(261));
      U3 = null;
      W4 = 0;
      return V5;
    }
    function ak() {
      for (; Y4 !== null; )
        bk(Y4);
    }
    function Rj() {
      for (; Y4 !== null && !Qf(); )
        bk(Y4);
    }
    function bk(a7) {
      var b7 = ck(a7.alternate, a7, qj);
      a7.memoizedProps = a7.pendingProps;
      b7 === null ? Zj(a7) : Y4 = b7;
      pj.current = null;
    }
    function Zj(a7) {
      var b7 = a7;
      do {
        var c8 = b7.alternate;
        a7 = b7.return;
        if ((b7.flags & 2048) === 0) {
          c8 = Gi(c8, b7, qj);
          if (c8 !== null) {
            Y4 = c8;
            return;
          }
          c8 = b7;
          if (c8.tag !== 24 && c8.tag !== 23 || c8.memoizedState === null || (qj & 1073741824) !== 0 || (c8.mode & 4) === 0) {
            for (var d7 = 0, e11 = c8.child; e11 !== null; )
              d7 |= e11.lanes | e11.childLanes, e11 = e11.sibling;
            c8.childLanes = d7;
          }
          a7 !== null && (a7.flags & 2048) === 0 && (a7.firstEffect === null && (a7.firstEffect = b7.firstEffect), b7.lastEffect !== null && (a7.lastEffect !== null && (a7.lastEffect.nextEffect = b7.firstEffect), a7.lastEffect = b7.lastEffect), 1 < b7.flags && (a7.lastEffect !== null ? a7.lastEffect.nextEffect = b7 : a7.firstEffect = b7, a7.lastEffect = b7));
        } else {
          c8 = Li(b7);
          if (c8 !== null) {
            c8.flags &= 2047;
            Y4 = c8;
            return;
          }
          a7 !== null && (a7.firstEffect = a7.lastEffect = null, a7.flags |= 2048);
        }
        b7 = b7.sibling;
        if (b7 !== null) {
          Y4 = b7;
          return;
        }
        Y4 = b7 = a7;
      } while (b7 !== null);
      V5 === 0 && (V5 = 5);
    }
    function Uj(a7) {
      var b7 = eg();
      gg(99, dk.bind(null, a7, b7));
      return null;
    }
    function dk(a7, b7) {
      do
        Oj();
      while (yj !== null);
      if ((X3 & 48) !== 0)
        throw Error(y5(327));
      var c8 = a7.finishedWork;
      if (c8 === null)
        return null;
      a7.finishedWork = null;
      a7.finishedLanes = 0;
      if (c8 === a7.current)
        throw Error(y5(177));
      a7.callbackNode = null;
      var d7 = c8.lanes | c8.childLanes, e11 = d7, f10 = a7.pendingLanes & ~e11;
      a7.pendingLanes = e11;
      a7.suspendedLanes = 0;
      a7.pingedLanes = 0;
      a7.expiredLanes &= e11;
      a7.mutableReadLanes &= e11;
      a7.entangledLanes &= e11;
      e11 = a7.entanglements;
      for (var g6 = a7.eventTimes, h4 = a7.expirationTimes; 0 < f10; ) {
        var k4 = 31 - Vc(f10), l9 = 1 << k4;
        e11[k4] = 0;
        g6[k4] = -1;
        h4[k4] = -1;
        f10 &= ~l9;
      }
      Cj !== null && (d7 & 24) === 0 && Cj.has(a7) && Cj.delete(a7);
      a7 === U3 && (Y4 = U3 = null, W4 = 0);
      1 < c8.flags ? c8.lastEffect !== null ? (c8.lastEffect.nextEffect = c8, d7 = c8.firstEffect) : d7 = c8 : d7 = c8.firstEffect;
      if (d7 !== null) {
        e11 = X3;
        X3 |= 32;
        pj.current = null;
        kf = fd;
        g6 = Ne();
        if (Oe(g6)) {
          if ("selectionStart" in g6)
            h4 = { start: g6.selectionStart, end: g6.selectionEnd };
          else
            a:
              if (h4 = (h4 = g6.ownerDocument) && h4.defaultView || window, (l9 = h4.getSelection && h4.getSelection()) && l9.rangeCount !== 0) {
                h4 = l9.anchorNode;
                f10 = l9.anchorOffset;
                k4 = l9.focusNode;
                l9 = l9.focusOffset;
                try {
                  h4.nodeType, k4.nodeType;
                } catch (va) {
                  h4 = null;
                  break a;
                }
                var n6 = 0, A3 = -1, p7 = -1, C6 = 0, x6 = 0, w6 = g6, z3 = null;
                b:
                  for (; ; ) {
                    for (var u4; ; ) {
                      w6 !== h4 || f10 !== 0 && w6.nodeType !== 3 || (A3 = n6 + f10);
                      w6 !== k4 || l9 !== 0 && w6.nodeType !== 3 || (p7 = n6 + l9);
                      w6.nodeType === 3 && (n6 += w6.nodeValue.length);
                      if ((u4 = w6.firstChild) === null)
                        break;
                      z3 = w6;
                      w6 = u4;
                    }
                    for (; ; ) {
                      if (w6 === g6)
                        break b;
                      z3 === h4 && ++C6 === f10 && (A3 = n6);
                      z3 === k4 && ++x6 === l9 && (p7 = n6);
                      if ((u4 = w6.nextSibling) !== null)
                        break;
                      w6 = z3;
                      z3 = w6.parentNode;
                    }
                    w6 = u4;
                  }
                h4 = A3 === -1 || p7 === -1 ? null : { start: A3, end: p7 };
              } else
                h4 = null;
          h4 = h4 || { start: 0, end: 0 };
        } else
          h4 = null;
        lf = { focusedElem: g6, selectionRange: h4 };
        fd = false;
        Ij = null;
        Jj = false;
        Z4 = d7;
        do
          try {
            ek();
          } catch (va) {
            if (Z4 === null)
              throw Error(y5(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        Ij = null;
        Z4 = d7;
        do
          try {
            for (g6 = a7; Z4 !== null; ) {
              var t12 = Z4.flags;
              t12 & 16 && pb(Z4.stateNode, "");
              if (t12 & 128) {
                var q3 = Z4.alternate;
                if (q3 !== null) {
                  var v6 = q3.ref;
                  v6 !== null && (typeof v6 === "function" ? v6(null) : v6.current = null);
                }
              }
              switch (t12 & 1038) {
                case 2:
                  fj(Z4);
                  Z4.flags &= -3;
                  break;
                case 6:
                  fj(Z4);
                  Z4.flags &= -3;
                  ij(Z4.alternate, Z4);
                  break;
                case 1024:
                  Z4.flags &= -1025;
                  break;
                case 1028:
                  Z4.flags &= -1025;
                  ij(Z4.alternate, Z4);
                  break;
                case 4:
                  ij(Z4.alternate, Z4);
                  break;
                case 8:
                  h4 = Z4;
                  cj(g6, h4);
                  var J4 = h4.alternate;
                  dj(h4);
                  J4 !== null && dj(J4);
              }
              Z4 = Z4.nextEffect;
            }
          } catch (va) {
            if (Z4 === null)
              throw Error(y5(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        v6 = lf;
        q3 = Ne();
        t12 = v6.focusedElem;
        g6 = v6.selectionRange;
        if (q3 !== t12 && t12 && t12.ownerDocument && Me(t12.ownerDocument.documentElement, t12)) {
          g6 !== null && Oe(t12) && (q3 = g6.start, v6 = g6.end, v6 === void 0 && (v6 = q3), "selectionStart" in t12 ? (t12.selectionStart = q3, t12.selectionEnd = Math.min(v6, t12.value.length)) : (v6 = (q3 = t12.ownerDocument || document) && q3.defaultView || window, v6.getSelection && (v6 = v6.getSelection(), h4 = t12.textContent.length, J4 = Math.min(g6.start, h4), g6 = g6.end === void 0 ? J4 : Math.min(g6.end, h4), !v6.extend && J4 > g6 && (h4 = g6, g6 = J4, J4 = h4), h4 = Le(t12, J4), f10 = Le(t12, g6), h4 && f10 && (v6.rangeCount !== 1 || v6.anchorNode !== h4.node || v6.anchorOffset !== h4.offset || v6.focusNode !== f10.node || v6.focusOffset !== f10.offset) && (q3 = q3.createRange(), q3.setStart(h4.node, h4.offset), v6.removeAllRanges(), J4 > g6 ? (v6.addRange(q3), v6.extend(f10.node, f10.offset)) : (q3.setEnd(f10.node, f10.offset), v6.addRange(q3))))));
          q3 = [];
          for (v6 = t12; v6 = v6.parentNode; )
            v6.nodeType === 1 && q3.push({ element: v6, left: v6.scrollLeft, top: v6.scrollTop });
          typeof t12.focus === "function" && t12.focus();
          for (t12 = 0; t12 < q3.length; t12++)
            v6 = q3[t12], v6.element.scrollLeft = v6.left, v6.element.scrollTop = v6.top;
        }
        fd = !!kf;
        lf = kf = null;
        a7.current = c8;
        Z4 = d7;
        do
          try {
            for (t12 = a7; Z4 !== null; ) {
              var K3 = Z4.flags;
              K3 & 36 && Yi(t12, Z4.alternate, Z4);
              if (K3 & 128) {
                q3 = void 0;
                var Q = Z4.ref;
                if (Q !== null) {
                  var L4 = Z4.stateNode;
                  switch (Z4.tag) {
                    case 5:
                      q3 = L4;
                      break;
                    default:
                      q3 = L4;
                  }
                  typeof Q === "function" ? Q(q3) : Q.current = q3;
                }
              }
              Z4 = Z4.nextEffect;
            }
          } catch (va) {
            if (Z4 === null)
              throw Error(y5(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        Z4 = null;
        $f();
        X3 = e11;
      } else
        a7.current = c8;
      if (xj)
        xj = false, yj = a7, zj = b7;
      else
        for (Z4 = d7; Z4 !== null; )
          b7 = Z4.nextEffect, Z4.nextEffect = null, Z4.flags & 8 && (K3 = Z4, K3.sibling = null, K3.stateNode = null), Z4 = b7;
      d7 = a7.pendingLanes;
      d7 === 0 && (Ti = null);
      d7 === 1 ? a7 === Ej ? Dj++ : (Dj = 0, Ej = a7) : Dj = 0;
      c8 = c8.stateNode;
      if (Mf && typeof Mf.onCommitFiberRoot === "function")
        try {
          Mf.onCommitFiberRoot(Lf, c8, void 0, (c8.current.flags & 64) === 64);
        } catch (va) {
        }
      Mj(a7, O4());
      if (Qi)
        throw Qi = false, a7 = Ri, Ri = null, a7;
      if ((X3 & 8) !== 0)
        return null;
      ig();
      return null;
    }
    function ek() {
      for (; Z4 !== null; ) {
        var a7 = Z4.alternate;
        Jj || Ij === null || ((Z4.flags & 8) !== 0 ? dc(Z4, Ij) && (Jj = true) : Z4.tag === 13 && mj(a7, Z4) && dc(Z4, Ij) && (Jj = true));
        var b7 = Z4.flags;
        (b7 & 256) !== 0 && Xi(a7, Z4);
        (b7 & 512) === 0 || xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
        Z4 = Z4.nextEffect;
      }
    }
    function Oj() {
      if (zj !== 90) {
        var a7 = 97 < zj ? 97 : zj;
        zj = 90;
        return gg(a7, fk);
      }
      return false;
    }
    function $i(a7, b7) {
      Aj.push(b7, a7);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function Zi(a7, b7) {
      Bj.push(b7, a7);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function fk() {
      if (yj === null)
        return false;
      var a7 = yj;
      yj = null;
      if ((X3 & 48) !== 0)
        throw Error(y5(331));
      var b7 = X3;
      X3 |= 32;
      var c8 = Bj;
      Bj = [];
      for (var d7 = 0; d7 < c8.length; d7 += 2) {
        var e11 = c8[d7], f10 = c8[d7 + 1], g6 = e11.destroy;
        e11.destroy = void 0;
        if (typeof g6 === "function")
          try {
            g6();
          } catch (k4) {
            if (f10 === null)
              throw Error(y5(330));
            Wi(f10, k4);
          }
      }
      c8 = Aj;
      Aj = [];
      for (d7 = 0; d7 < c8.length; d7 += 2) {
        e11 = c8[d7];
        f10 = c8[d7 + 1];
        try {
          var h4 = e11.create;
          e11.destroy = h4();
        } catch (k4) {
          if (f10 === null)
            throw Error(y5(330));
          Wi(f10, k4);
        }
      }
      for (h4 = a7.current.firstEffect; h4 !== null; )
        a7 = h4.nextEffect, h4.nextEffect = null, h4.flags & 8 && (h4.sibling = null, h4.stateNode = null), h4 = a7;
      X3 = b7;
      ig();
      return true;
    }
    function gk(a7, b7, c8) {
      b7 = Mi(c8, b7);
      b7 = Pi(a7, b7, 1);
      Ag(a7, b7);
      b7 = Hg();
      a7 = Kj(a7, 1);
      a7 !== null && ($c(a7, 1, b7), Mj(a7, b7));
    }
    function Wi(a7, b7) {
      if (a7.tag === 3)
        gk(a7, a7, b7);
      else
        for (var c8 = a7.return; c8 !== null; ) {
          if (c8.tag === 3) {
            gk(c8, a7, b7);
            break;
          } else if (c8.tag === 1) {
            var d7 = c8.stateNode;
            if (typeof c8.type.getDerivedStateFromError === "function" || typeof d7.componentDidCatch === "function" && (Ti === null || !Ti.has(d7))) {
              a7 = Mi(b7, a7);
              var e11 = Si(c8, a7, 1);
              Ag(c8, e11);
              e11 = Hg();
              c8 = Kj(c8, 1);
              if (c8 !== null)
                $c(c8, 1, e11), Mj(c8, e11);
              else if (typeof d7.componentDidCatch === "function" && (Ti === null || !Ti.has(d7)))
                try {
                  d7.componentDidCatch(b7, a7);
                } catch (f10) {
                }
              break;
            }
          }
          c8 = c8.return;
        }
    }
    function Yj(a7, b7, c8) {
      var d7 = a7.pingCache;
      d7 !== null && d7.delete(b7);
      b7 = Hg();
      a7.pingedLanes |= a7.suspendedLanes & c8;
      U3 === a7 && (W4 & c8) === c8 && (V5 === 4 || V5 === 3 && (W4 & 62914560) === W4 && 500 > O4() - jj ? Qj(a7, 0) : uj |= c8);
      Mj(a7, b7);
    }
    function lj(a7, b7) {
      var c8 = a7.stateNode;
      c8 !== null && c8.delete(b7);
      b7 = 0;
      b7 === 0 && (b7 = a7.mode, (b7 & 2) === 0 ? b7 = 1 : (b7 & 4) === 0 ? b7 = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b7 = Yc(62914560 & ~Gj), b7 === 0 && (b7 = 4194304)));
      c8 = Hg();
      a7 = Kj(a7, b7);
      a7 !== null && ($c(a7, b7, c8), Mj(a7, c8));
    }
    var ck;
    ck = function(a7, b7, c8) {
      var d7 = b7.lanes;
      if (a7 !== null)
        if (a7.memoizedProps !== b7.pendingProps || N2.current)
          ug = true;
        else if ((c8 & d7) !== 0)
          ug = (a7.flags & 16384) !== 0 ? true : false;
        else {
          ug = false;
          switch (b7.tag) {
            case 3:
              ri(b7);
              sh();
              break;
            case 5:
              gh(b7);
              break;
            case 1:
              Ff(b7.type) && Jf(b7);
              break;
            case 4:
              eh(b7, b7.stateNode.containerInfo);
              break;
            case 10:
              d7 = b7.memoizedProps.value;
              var e11 = b7.type._context;
              I4(mg, e11._currentValue);
              e11._currentValue = d7;
              break;
            case 13:
              if (b7.memoizedState !== null) {
                if ((c8 & b7.child.childLanes) !== 0)
                  return ti(a7, b7, c8);
                I4(P3, P3.current & 1);
                b7 = hi(a7, b7, c8);
                return b7 !== null ? b7.sibling : null;
              }
              I4(P3, P3.current & 1);
              break;
            case 19:
              d7 = (c8 & b7.childLanes) !== 0;
              if ((a7.flags & 64) !== 0) {
                if (d7)
                  return Ai(a7, b7, c8);
                b7.flags |= 64;
              }
              e11 = b7.memoizedState;
              e11 !== null && (e11.rendering = null, e11.tail = null, e11.lastEffect = null);
              I4(P3, P3.current);
              if (d7)
                break;
              else
                return null;
            case 23:
            case 24:
              return b7.lanes = 0, mi(a7, b7, c8);
          }
          return hi(a7, b7, c8);
        }
      else
        ug = false;
      b7.lanes = 0;
      switch (b7.tag) {
        case 2:
          d7 = b7.type;
          a7 !== null && (a7.alternate = null, b7.alternate = null, b7.flags |= 2);
          a7 = b7.pendingProps;
          e11 = Ef(b7, M3.current);
          tg(b7, c8);
          e11 = Ch(null, b7, d7, a7, e11, c8);
          b7.flags |= 1;
          if (typeof e11 === "object" && e11 !== null && typeof e11.render === "function" && e11.$$typeof === void 0) {
            b7.tag = 1;
            b7.memoizedState = null;
            b7.updateQueue = null;
            if (Ff(d7)) {
              var f10 = true;
              Jf(b7);
            } else
              f10 = false;
            b7.memoizedState = e11.state !== null && e11.state !== void 0 ? e11.state : null;
            xg(b7);
            var g6 = d7.getDerivedStateFromProps;
            typeof g6 === "function" && Gg(b7, d7, g6, a7);
            e11.updater = Kg;
            b7.stateNode = e11;
            e11._reactInternals = b7;
            Og(b7, d7, a7, c8);
            b7 = qi(null, b7, d7, true, f10, c8);
          } else
            b7.tag = 0, fi(null, b7, e11, c8), b7 = b7.child;
          return b7;
        case 16:
          e11 = b7.elementType;
          a: {
            a7 !== null && (a7.alternate = null, b7.alternate = null, b7.flags |= 2);
            a7 = b7.pendingProps;
            f10 = e11._init;
            e11 = f10(e11._payload);
            b7.type = e11;
            f10 = b7.tag = hk(e11);
            a7 = lg(e11, a7);
            switch (f10) {
              case 0:
                b7 = li(null, b7, e11, a7, c8);
                break a;
              case 1:
                b7 = pi(null, b7, e11, a7, c8);
                break a;
              case 11:
                b7 = gi(null, b7, e11, a7, c8);
                break a;
              case 14:
                b7 = ii(null, b7, e11, lg(e11.type, a7), d7, c8);
                break a;
            }
            throw Error(y5(306, e11, ""));
          }
          return b7;
        case 0:
          return d7 = b7.type, e11 = b7.pendingProps, e11 = b7.elementType === d7 ? e11 : lg(d7, e11), li(a7, b7, d7, e11, c8);
        case 1:
          return d7 = b7.type, e11 = b7.pendingProps, e11 = b7.elementType === d7 ? e11 : lg(d7, e11), pi(a7, b7, d7, e11, c8);
        case 3:
          ri(b7);
          d7 = b7.updateQueue;
          if (a7 === null || d7 === null)
            throw Error(y5(282));
          d7 = b7.pendingProps;
          e11 = b7.memoizedState;
          e11 = e11 !== null ? e11.element : null;
          yg(a7, b7);
          Cg(b7, d7, null, c8);
          d7 = b7.memoizedState.element;
          if (d7 === e11)
            sh(), b7 = hi(a7, b7, c8);
          else {
            e11 = b7.stateNode;
            if (f10 = e11.hydrate)
              kh = rf(b7.stateNode.containerInfo.firstChild), jh = b7, f10 = lh = true;
            if (f10) {
              a7 = e11.mutableSourceEagerHydrationData;
              if (a7 != null)
                for (e11 = 0; e11 < a7.length; e11 += 2)
                  f10 = a7[e11], f10._workInProgressVersionPrimary = a7[e11 + 1], th.push(f10);
              c8 = Zg(b7, null, d7, c8);
              for (b7.child = c8; c8; )
                c8.flags = c8.flags & -3 | 1024, c8 = c8.sibling;
            } else
              fi(a7, b7, d7, c8), sh();
            b7 = b7.child;
          }
          return b7;
        case 5:
          return gh(b7), a7 === null && ph(b7), d7 = b7.type, e11 = b7.pendingProps, f10 = a7 !== null ? a7.memoizedProps : null, g6 = e11.children, nf(d7, e11) ? g6 = null : f10 !== null && nf(d7, f10) && (b7.flags |= 16), oi(a7, b7), fi(a7, b7, g6, c8), b7.child;
        case 6:
          return a7 === null && ph(b7), null;
        case 13:
          return ti(a7, b7, c8);
        case 4:
          return eh(b7, b7.stateNode.containerInfo), d7 = b7.pendingProps, a7 === null ? b7.child = Yg(b7, null, d7, c8) : fi(a7, b7, d7, c8), b7.child;
        case 11:
          return d7 = b7.type, e11 = b7.pendingProps, e11 = b7.elementType === d7 ? e11 : lg(d7, e11), gi(a7, b7, d7, e11, c8);
        case 7:
          return fi(a7, b7, b7.pendingProps, c8), b7.child;
        case 8:
          return fi(a7, b7, b7.pendingProps.children, c8), b7.child;
        case 12:
          return fi(a7, b7, b7.pendingProps.children, c8), b7.child;
        case 10:
          a: {
            d7 = b7.type._context;
            e11 = b7.pendingProps;
            g6 = b7.memoizedProps;
            f10 = e11.value;
            var h4 = b7.type._context;
            I4(mg, h4._currentValue);
            h4._currentValue = f10;
            if (g6 !== null)
              if (h4 = g6.value, f10 = He(h4, f10) ? 0 : (typeof d7._calculateChangedBits === "function" ? d7._calculateChangedBits(h4, f10) : 1073741823) | 0, f10 === 0) {
                if (g6.children === e11.children && !N2.current) {
                  b7 = hi(a7, b7, c8);
                  break a;
                }
              } else
                for (h4 = b7.child, h4 !== null && (h4.return = b7); h4 !== null; ) {
                  var k4 = h4.dependencies;
                  if (k4 !== null) {
                    g6 = h4.child;
                    for (var l9 = k4.firstContext; l9 !== null; ) {
                      if (l9.context === d7 && (l9.observedBits & f10) !== 0) {
                        h4.tag === 1 && (l9 = zg(-1, c8 & -c8), l9.tag = 2, Ag(h4, l9));
                        h4.lanes |= c8;
                        l9 = h4.alternate;
                        l9 !== null && (l9.lanes |= c8);
                        sg(h4.return, c8);
                        k4.lanes |= c8;
                        break;
                      }
                      l9 = l9.next;
                    }
                  } else
                    g6 = h4.tag === 10 ? h4.type === b7.type ? null : h4.child : h4.child;
                  if (g6 !== null)
                    g6.return = h4;
                  else
                    for (g6 = h4; g6 !== null; ) {
                      if (g6 === b7) {
                        g6 = null;
                        break;
                      }
                      h4 = g6.sibling;
                      if (h4 !== null) {
                        h4.return = g6.return;
                        g6 = h4;
                        break;
                      }
                      g6 = g6.return;
                    }
                  h4 = g6;
                }
            fi(a7, b7, e11.children, c8);
            b7 = b7.child;
          }
          return b7;
        case 9:
          return e11 = b7.type, f10 = b7.pendingProps, d7 = f10.children, tg(b7, c8), e11 = vg(e11, f10.unstable_observedBits), d7 = d7(e11), b7.flags |= 1, fi(a7, b7, d7, c8), b7.child;
        case 14:
          return e11 = b7.type, f10 = lg(e11, b7.pendingProps), f10 = lg(e11.type, f10), ii(a7, b7, e11, f10, d7, c8);
        case 15:
          return ki(a7, b7, b7.type, b7.pendingProps, d7, c8);
        case 17:
          return d7 = b7.type, e11 = b7.pendingProps, e11 = b7.elementType === d7 ? e11 : lg(d7, e11), a7 !== null && (a7.alternate = null, b7.alternate = null, b7.flags |= 2), b7.tag = 1, Ff(d7) ? (a7 = true, Jf(b7)) : a7 = false, tg(b7, c8), Mg(b7, d7, e11), Og(b7, d7, e11, c8), qi(null, b7, d7, true, a7, c8);
        case 19:
          return Ai(a7, b7, c8);
        case 23:
          return mi(a7, b7, c8);
        case 24:
          return mi(a7, b7, c8);
      }
      throw Error(y5(156, b7.tag));
    };
    function ik(a7, b7, c8, d7) {
      this.tag = a7;
      this.key = c8;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b7;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d7;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function nh(a7, b7, c8, d7) {
      return new ik(a7, b7, c8, d7);
    }
    function ji(a7) {
      a7 = a7.prototype;
      return !(!a7 || !a7.isReactComponent);
    }
    function hk(a7) {
      if (typeof a7 === "function")
        return ji(a7) ? 1 : 0;
      if (a7 !== void 0 && a7 !== null) {
        a7 = a7.$$typeof;
        if (a7 === Aa)
          return 11;
        if (a7 === Da)
          return 14;
      }
      return 2;
    }
    function Tg(a7, b7) {
      var c8 = a7.alternate;
      c8 === null ? (c8 = nh(a7.tag, b7, a7.key, a7.mode), c8.elementType = a7.elementType, c8.type = a7.type, c8.stateNode = a7.stateNode, c8.alternate = a7, a7.alternate = c8) : (c8.pendingProps = b7, c8.type = a7.type, c8.flags = 0, c8.nextEffect = null, c8.firstEffect = null, c8.lastEffect = null);
      c8.childLanes = a7.childLanes;
      c8.lanes = a7.lanes;
      c8.child = a7.child;
      c8.memoizedProps = a7.memoizedProps;
      c8.memoizedState = a7.memoizedState;
      c8.updateQueue = a7.updateQueue;
      b7 = a7.dependencies;
      c8.dependencies = b7 === null ? null : { lanes: b7.lanes, firstContext: b7.firstContext };
      c8.sibling = a7.sibling;
      c8.index = a7.index;
      c8.ref = a7.ref;
      return c8;
    }
    function Vg(a7, b7, c8, d7, e11, f10) {
      var g6 = 2;
      d7 = a7;
      if (typeof a7 === "function")
        ji(a7) && (g6 = 1);
      else if (typeof a7 === "string")
        g6 = 5;
      else
        a:
          switch (a7) {
            case ua:
              return Xg(c8.children, e11, f10, b7);
            case Ha:
              g6 = 8;
              e11 |= 16;
              break;
            case wa:
              g6 = 8;
              e11 |= 1;
              break;
            case xa:
              return a7 = nh(12, c8, b7, e11 | 8), a7.elementType = xa, a7.type = xa, a7.lanes = f10, a7;
            case Ba:
              return a7 = nh(13, c8, b7, e11), a7.type = Ba, a7.elementType = Ba, a7.lanes = f10, a7;
            case Ca:
              return a7 = nh(19, c8, b7, e11), a7.elementType = Ca, a7.lanes = f10, a7;
            case Ia:
              return vi(c8, e11, f10, b7);
            case Ja:
              return a7 = nh(24, c8, b7, e11), a7.elementType = Ja, a7.lanes = f10, a7;
            default:
              if (typeof a7 === "object" && a7 !== null)
                switch (a7.$$typeof) {
                  case ya:
                    g6 = 10;
                    break a;
                  case za:
                    g6 = 9;
                    break a;
                  case Aa:
                    g6 = 11;
                    break a;
                  case Da:
                    g6 = 14;
                    break a;
                  case Ea:
                    g6 = 16;
                    d7 = null;
                    break a;
                  case Fa:
                    g6 = 22;
                    break a;
                }
              throw Error(y5(130, a7 == null ? a7 : typeof a7, ""));
          }
      b7 = nh(g6, c8, b7, e11);
      b7.elementType = a7;
      b7.type = d7;
      b7.lanes = f10;
      return b7;
    }
    function Xg(a7, b7, c8, d7) {
      a7 = nh(7, a7, d7, b7);
      a7.lanes = c8;
      return a7;
    }
    function vi(a7, b7, c8, d7) {
      a7 = nh(23, a7, d7, b7);
      a7.elementType = Ia;
      a7.lanes = c8;
      return a7;
    }
    function Ug(a7, b7, c8) {
      a7 = nh(6, a7, null, b7);
      a7.lanes = c8;
      return a7;
    }
    function Wg(a7, b7, c8) {
      b7 = nh(4, a7.children !== null ? a7.children : [], a7.key, b7);
      b7.lanes = c8;
      b7.stateNode = { containerInfo: a7.containerInfo, pendingChildren: null, implementation: a7.implementation };
      return b7;
    }
    function jk(a7, b7, c8) {
      this.tag = b7;
      this.containerInfo = a7;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c8;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = Zc(0);
      this.expirationTimes = Zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = Zc(0);
      this.mutableSourceEagerHydrationData = null;
    }
    function kk(a7, b7, c8) {
      var d7 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: ta, key: d7 == null ? null : "" + d7, children: a7, containerInfo: b7, implementation: c8 };
    }
    function lk(a7, b7, c8, d7) {
      var e11 = b7.current, f10 = Hg(), g6 = Ig(e11);
      a:
        if (c8) {
          c8 = c8._reactInternals;
          b: {
            if (Zb(c8) !== c8 || c8.tag !== 1)
              throw Error(y5(170));
            var h4 = c8;
            do {
              switch (h4.tag) {
                case 3:
                  h4 = h4.stateNode.context;
                  break b;
                case 1:
                  if (Ff(h4.type)) {
                    h4 = h4.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h4 = h4.return;
            } while (h4 !== null);
            throw Error(y5(171));
          }
          if (c8.tag === 1) {
            var k4 = c8.type;
            if (Ff(k4)) {
              c8 = If(c8, k4, h4);
              break a;
            }
          }
          c8 = h4;
        } else
          c8 = Cf;
      b7.context === null ? b7.context = c8 : b7.pendingContext = c8;
      b7 = zg(f10, g6);
      b7.payload = { element: a7 };
      d7 = d7 === void 0 ? null : d7;
      d7 !== null && (b7.callback = d7);
      Ag(e11, b7);
      Jg(e11, g6, f10);
      return g6;
    }
    function mk(a7) {
      a7 = a7.current;
      if (!a7.child)
        return null;
      switch (a7.child.tag) {
        case 5:
          return a7.child.stateNode;
        default:
          return a7.child.stateNode;
      }
    }
    function nk(a7, b7) {
      a7 = a7.memoizedState;
      if (a7 !== null && a7.dehydrated !== null) {
        var c8 = a7.retryLane;
        a7.retryLane = c8 !== 0 && c8 < b7 ? c8 : b7;
      }
    }
    function ok(a7, b7) {
      nk(a7, b7);
      (a7 = a7.alternate) && nk(a7, b7);
    }
    function pk() {
      return null;
    }
    function qk(a7, b7, c8) {
      var d7 = c8 != null && c8.hydrationOptions != null && c8.hydrationOptions.mutableSources || null;
      c8 = new jk(a7, b7, c8 != null && c8.hydrate === true);
      b7 = nh(3, null, null, b7 === 2 ? 7 : b7 === 1 ? 3 : 0);
      c8.current = b7;
      b7.stateNode = c8;
      xg(b7);
      a7[ff] = c8.current;
      cf(a7.nodeType === 8 ? a7.parentNode : a7);
      if (d7)
        for (a7 = 0; a7 < d7.length; a7++) {
          b7 = d7[a7];
          var e11 = b7._getVersion;
          e11 = e11(b7._source);
          c8.mutableSourceEagerHydrationData == null ? c8.mutableSourceEagerHydrationData = [b7, e11] : c8.mutableSourceEagerHydrationData.push(b7, e11);
        }
      this._internalRoot = c8;
    }
    qk.prototype.render = function(a7) {
      lk(a7, this._internalRoot, null, null);
    };
    qk.prototype.unmount = function() {
      var a7 = this._internalRoot, b7 = a7.containerInfo;
      lk(null, a7, null, function() {
        b7[ff] = null;
      });
    };
    function rk(a7) {
      return !(!a7 || a7.nodeType !== 1 && a7.nodeType !== 9 && a7.nodeType !== 11 && (a7.nodeType !== 8 || a7.nodeValue !== " react-mount-point-unstable "));
    }
    function sk(a7, b7) {
      b7 || (b7 = a7 ? a7.nodeType === 9 ? a7.documentElement : a7.firstChild : null, b7 = !(!b7 || b7.nodeType !== 1 || !b7.hasAttribute("data-reactroot")));
      if (!b7)
        for (var c8; c8 = a7.lastChild; )
          a7.removeChild(c8);
      return new qk(a7, 0, b7 ? { hydrate: true } : void 0);
    }
    function tk(a7, b7, c8, d7, e11) {
      var f10 = c8._reactRootContainer;
      if (f10) {
        var g6 = f10._internalRoot;
        if (typeof e11 === "function") {
          var h4 = e11;
          e11 = function() {
            var a8 = mk(g6);
            h4.call(a8);
          };
        }
        lk(b7, g6, a7, e11);
      } else {
        f10 = c8._reactRootContainer = sk(c8, d7);
        g6 = f10._internalRoot;
        if (typeof e11 === "function") {
          var k4 = e11;
          e11 = function() {
            var a8 = mk(g6);
            k4.call(a8);
          };
        }
        Xj(function() {
          lk(b7, g6, a7, e11);
        });
      }
      return mk(g6);
    }
    ec = function(a7) {
      if (a7.tag === 13) {
        var b7 = Hg();
        Jg(a7, 4, b7);
        ok(a7, 4);
      }
    };
    fc = function(a7) {
      if (a7.tag === 13) {
        var b7 = Hg();
        Jg(a7, 67108864, b7);
        ok(a7, 67108864);
      }
    };
    gc = function(a7) {
      if (a7.tag === 13) {
        var b7 = Hg(), c8 = Ig(a7);
        Jg(a7, c8, b7);
        ok(a7, c8);
      }
    };
    hc = function(a7, b7) {
      return b7();
    };
    yb = function(a7, b7, c8) {
      switch (b7) {
        case "input":
          ab(a7, c8);
          b7 = c8.name;
          if (c8.type === "radio" && b7 != null) {
            for (c8 = a7; c8.parentNode; )
              c8 = c8.parentNode;
            c8 = c8.querySelectorAll("input[name=" + JSON.stringify("" + b7) + '][type="radio"]');
            for (b7 = 0; b7 < c8.length; b7++) {
              var d7 = c8[b7];
              if (d7 !== a7 && d7.form === a7.form) {
                var e11 = Db(d7);
                if (!e11)
                  throw Error(y5(90));
                Wa(d7);
                ab(d7, e11);
              }
            }
          }
          break;
        case "textarea":
          ib(a7, c8);
          break;
        case "select":
          b7 = c8.value, b7 != null && fb(a7, !!c8.multiple, b7, false);
      }
    };
    Gb = Wj;
    Hb = function(a7, b7, c8, d7, e11) {
      var f10 = X3;
      X3 |= 4;
      try {
        return gg(98, a7.bind(null, b7, c8, d7, e11));
      } finally {
        X3 = f10, X3 === 0 && (wj(), ig());
      }
    };
    Ib = function() {
      (X3 & 49) === 0 && (Vj(), Oj());
    };
    Jb = function(a7, b7) {
      var c8 = X3;
      X3 |= 2;
      try {
        return a7(b7);
      } finally {
        X3 = c8, X3 === 0 && (wj(), ig());
      }
    };
    function uk(a7, b7) {
      var c8 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!rk(b7))
        throw Error(y5(200));
      return kk(a7, b7, null, c8);
    }
    var vk = { Events: [Cb, ue2, Db, Eb, Fb, Oj, { current: false }] };
    var wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
    var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a7) {
      a7 = cc(a7);
      return a7 === null ? null : a7.stateNode;
    }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
      yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!yk.isDisabled && yk.supportsFiber)
        try {
          Lf = yk.inject(xk), Mf = yk;
        } catch (a7) {
        }
    }
    var yk;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
    exports.createPortal = uk;
    exports.findDOMNode = function(a7) {
      if (a7 == null)
        return null;
      if (a7.nodeType === 1)
        return a7;
      var b7 = a7._reactInternals;
      if (b7 === void 0) {
        if (typeof a7.render === "function")
          throw Error(y5(188));
        throw Error(y5(268, Object.keys(a7)));
      }
      a7 = cc(b7);
      a7 = a7 === null ? null : a7.stateNode;
      return a7;
    };
    exports.flushSync = function(a7, b7) {
      var c8 = X3;
      if ((c8 & 48) !== 0)
        return a7(b7);
      X3 |= 1;
      try {
        if (a7)
          return gg(99, a7.bind(null, b7));
      } finally {
        X3 = c8, ig();
      }
    };
    exports.hydrate = function(a7, b7, c8) {
      if (!rk(b7))
        throw Error(y5(200));
      return tk(null, a7, b7, true, c8);
    };
    exports.render = function(a7, b7, c8) {
      if (!rk(b7))
        throw Error(y5(200));
      return tk(null, a7, b7, false, c8);
    };
    exports.unmountComponentAtNode = function(a7) {
      if (!rk(a7))
        throw Error(y5(40));
      return a7._reactRootContainer ? (Xj(function() {
        tk(null, null, a7, false, function() {
          a7._reactRootContainer = null;
          a7[ff] = null;
        });
      }), true) : false;
    };
    exports.unstable_batchedUpdates = Wj;
    exports.unstable_createPortal = function(a7, b7) {
      return uk(a7, b7, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
    };
    exports.unstable_renderSubtreeIntoContainer = function(a7, b7, c8, d7) {
      if (!rk(c8))
        throw Error(y5(200));
      if (a7 == null || a7._reactInternals === void 0)
        throw Error(y5(38));
      return tk(a7, b7, c8, false, d7);
    };
    exports.version = "17.0.2";
  }
});

// ../../node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "../../node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/react-remove-scroll/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/react-remove-scroll/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends3;
    var __assign4;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values4;
    var __read4;
    var __spread3;
    var __spreadArrays3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v6) {
          return exports2[id] = previous ? previous(id, v6) : v6;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b7) {
        d7.__proto__ = b7;
      } || function(d7, b7) {
        for (var p7 in b7)
          if (b7.hasOwnProperty(p7))
            d7[p7] = b7[p7];
      };
      __extends3 = function(d7, b7) {
        extendStatics(d7, b7);
        function __() {
          this.constructor = d7;
        }
        d7.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
      };
      __assign4 = Object.assign || function(t12) {
        for (var s9, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
          s9 = arguments[i8];
          for (var p7 in s9)
            if (Object.prototype.hasOwnProperty.call(s9, p7))
              t12[p7] = s9[p7];
        }
        return t12;
      };
      __rest3 = function(s9, e11) {
        var t12 = {};
        for (var p7 in s9)
          if (Object.prototype.hasOwnProperty.call(s9, p7) && e11.indexOf(p7) < 0)
            t12[p7] = s9[p7];
        if (s9 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i8 = 0, p7 = Object.getOwnPropertySymbols(s9); i8 < p7.length; i8++) {
            if (e11.indexOf(p7[i8]) < 0 && Object.prototype.propertyIsEnumerable.call(s9, p7[i8]))
              t12[p7[i8]] = s9[p7[i8]];
          }
        return t12;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c8 = arguments.length, r12 = c8 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r12 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i8 = decorators.length - 1; i8 >= 0; i8--)
            if (d7 = decorators[i8])
              r12 = (c8 < 3 ? d7(r12) : c8 > 3 ? d7(target, key, r12) : d7(target, key)) || r12;
        return c8 > 3 && r12 && Object.defineProperty(target, key, r12), r12;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e11) {
              reject2(e11);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e11) {
              reject2(e11);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _5 = { label: 0, sent: function() {
          if (t12[0] & 1)
            throw t12[1];
          return t12[1];
        }, trys: [], ops: [] }, f10, y5, t12, g6;
        return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
          return this;
        }), g6;
        function verb(n6) {
          return function(v6) {
            return step([n6, v6]);
          };
        }
        function step(op) {
          if (f10)
            throw new TypeError("Generator is already executing.");
          while (_5)
            try {
              if (f10 = 1, y5 && (t12 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t12 = y5["return"]) && t12.call(y5), 0) : y5.next) && !(t12 = t12.call(y5, op[1])).done)
                return t12;
              if (y5 = 0, t12)
                op = [op[0] & 2, t12.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t12 = op;
                  break;
                case 4:
                  _5.label++;
                  return { value: op[1], done: false };
                case 5:
                  _5.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _5.ops.pop();
                  _5.trys.pop();
                  continue;
                default:
                  if (!(t12 = _5.trys, t12 = t12.length > 0 && t12[t12.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _5 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t12 || op[1] > t12[0] && op[1] < t12[3])) {
                    _5.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _5.label < t12[1]) {
                    _5.label = t12[1];
                    t12 = op;
                    break;
                  }
                  if (t12 && _5.label < t12[2]) {
                    _5.label = t12[2];
                    _5.ops.push(op);
                    break;
                  }
                  if (t12[2])
                    _5.ops.pop();
                  _5.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _5);
            } catch (e11) {
              op = [6, e11];
              y5 = 0;
            } finally {
              f10 = t12 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding3 = function(o11, m8, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o11[k22] = m8[k4];
      };
      __exportStar3 = function(m8, exports2) {
        for (var p7 in m8)
          if (p7 !== "default" && !exports2.hasOwnProperty(p7))
            exports2[p7] = m8[p7];
      };
      __values4 = function(o11) {
        var s9 = typeof Symbol === "function" && Symbol.iterator, m8 = s9 && o11[s9], i8 = 0;
        if (m8)
          return m8.call(o11);
        if (o11 && typeof o11.length === "number")
          return {
            next: function() {
              if (o11 && i8 >= o11.length)
                o11 = void 0;
              return { value: o11 && o11[i8++], done: !o11 };
            }
          };
        throw new TypeError(s9 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read4 = function(o11, n6) {
        var m8 = typeof Symbol === "function" && o11[Symbol.iterator];
        if (!m8)
          return o11;
        var i8 = m8.call(o11), r12, ar = [], e11;
        try {
          while ((n6 === void 0 || n6-- > 0) && !(r12 = i8.next()).done)
            ar.push(r12.value);
        } catch (error) {
          e11 = { error };
        } finally {
          try {
            if (r12 && !r12.done && (m8 = i8["return"]))
              m8.call(i8);
          } finally {
            if (e11)
              throw e11.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i8 = 0; i8 < arguments.length; i8++)
          ar = ar.concat(__read4(arguments[i8]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s9 = 0, i8 = 0, il = arguments.length; i8 < il; i8++)
          s9 += arguments[i8].length;
        for (var r12 = Array(s9), k4 = 0, i8 = 0; i8 < il; i8++)
          for (var a7 = arguments[i8], j4 = 0, jl = a7.length; j4 < jl; j4++, k4++)
            r12[k4] = a7[j4];
        return r12;
      };
      __await3 = function(v6) {
        return this instanceof __await3 ? (this.v = v6, this) : new __await3(v6);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g6 = generator.apply(thisArg, _arguments || []), i8, q3 = [];
        return i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8;
        function verb(n6) {
          if (g6[n6])
            i8[n6] = function(v6) {
              return new Promise(function(a7, b7) {
                q3.push([n6, v6, a7, b7]) > 1 || resume(n6, v6);
              });
            };
        }
        function resume(n6, v6) {
          try {
            step(g6[n6](v6));
          } catch (e11) {
            settle(q3[0][3], e11);
          }
        }
        function step(r12) {
          r12.value instanceof __await3 ? Promise.resolve(r12.value.v).then(fulfill, reject2) : settle(q3[0][2], r12);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject2(value) {
          resume("throw", value);
        }
        function settle(f10, v6) {
          if (f10(v6), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator3 = function(o11) {
        var i8, p7;
        return i8 = {}, verb("next"), verb("throw", function(e11) {
          throw e11;
        }), verb("return"), i8[Symbol.iterator] = function() {
          return this;
        }, i8;
        function verb(n6, f10) {
          i8[n6] = o11[n6] ? function(v6) {
            return (p7 = !p7) ? { value: __await3(o11[n6](v6)), done: n6 === "return" } : f10 ? f10(v6) : v6;
          } : f10;
        }
      };
      __asyncValues3 = function(o11) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m8 = o11[Symbol.asyncIterator], i8;
        return m8 ? m8.call(o11) : (o11 = typeof __values4 === "function" ? __values4(o11) : o11[Symbol.iterator](), i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8);
        function verb(n6) {
          i8[n6] = o11[n6] && function(v6) {
            return new Promise(function(resolve, reject2) {
              v6 = o11[n6](v6), settle(resolve, reject2, v6.done, v6.value);
            });
          };
        }
        function settle(resolve, reject2, d7, v6) {
          Promise.resolve(v6).then(function(v7) {
            resolve({ value: v7, done: d7 });
          }, reject2);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k4 in mod)
            if (Object.hasOwnProperty.call(mod, k4))
              result[k4] = mod[k4];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign4);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values4);
      exporter("__read", __read4);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// ../../node_modules/use-sidecar/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "../../node_modules/use-sidecar/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends3;
    var __assign4;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values4;
    var __read4;
    var __spread3;
    var __spreadArrays3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v6) {
          return exports2[id] = previous ? previous(id, v6) : v6;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b7) {
        d7.__proto__ = b7;
      } || function(d7, b7) {
        for (var p7 in b7)
          if (b7.hasOwnProperty(p7))
            d7[p7] = b7[p7];
      };
      __extends3 = function(d7, b7) {
        extendStatics(d7, b7);
        function __() {
          this.constructor = d7;
        }
        d7.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
      };
      __assign4 = Object.assign || function(t12) {
        for (var s9, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
          s9 = arguments[i8];
          for (var p7 in s9)
            if (Object.prototype.hasOwnProperty.call(s9, p7))
              t12[p7] = s9[p7];
        }
        return t12;
      };
      __rest3 = function(s9, e11) {
        var t12 = {};
        for (var p7 in s9)
          if (Object.prototype.hasOwnProperty.call(s9, p7) && e11.indexOf(p7) < 0)
            t12[p7] = s9[p7];
        if (s9 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i8 = 0, p7 = Object.getOwnPropertySymbols(s9); i8 < p7.length; i8++) {
            if (e11.indexOf(p7[i8]) < 0 && Object.prototype.propertyIsEnumerable.call(s9, p7[i8]))
              t12[p7[i8]] = s9[p7[i8]];
          }
        return t12;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c8 = arguments.length, r12 = c8 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r12 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i8 = decorators.length - 1; i8 >= 0; i8--)
            if (d7 = decorators[i8])
              r12 = (c8 < 3 ? d7(r12) : c8 > 3 ? d7(target, key, r12) : d7(target, key)) || r12;
        return c8 > 3 && r12 && Object.defineProperty(target, key, r12), r12;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject2) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e11) {
              reject2(e11);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e11) {
              reject2(e11);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _5 = { label: 0, sent: function() {
          if (t12[0] & 1)
            throw t12[1];
          return t12[1];
        }, trys: [], ops: [] }, f10, y5, t12, g6;
        return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
          return this;
        }), g6;
        function verb(n6) {
          return function(v6) {
            return step([n6, v6]);
          };
        }
        function step(op) {
          if (f10)
            throw new TypeError("Generator is already executing.");
          while (_5)
            try {
              if (f10 = 1, y5 && (t12 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t12 = y5["return"]) && t12.call(y5), 0) : y5.next) && !(t12 = t12.call(y5, op[1])).done)
                return t12;
              if (y5 = 0, t12)
                op = [op[0] & 2, t12.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t12 = op;
                  break;
                case 4:
                  _5.label++;
                  return { value: op[1], done: false };
                case 5:
                  _5.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _5.ops.pop();
                  _5.trys.pop();
                  continue;
                default:
                  if (!(t12 = _5.trys, t12 = t12.length > 0 && t12[t12.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _5 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t12 || op[1] > t12[0] && op[1] < t12[3])) {
                    _5.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _5.label < t12[1]) {
                    _5.label = t12[1];
                    t12 = op;
                    break;
                  }
                  if (t12 && _5.label < t12[2]) {
                    _5.label = t12[2];
                    _5.ops.push(op);
                    break;
                  }
                  if (t12[2])
                    _5.ops.pop();
                  _5.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _5);
            } catch (e11) {
              op = [6, e11];
              y5 = 0;
            } finally {
              f10 = t12 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding3 = function(o11, m8, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o11[k22] = m8[k4];
      };
      __exportStar3 = function(m8, exports2) {
        for (var p7 in m8)
          if (p7 !== "default" && !exports2.hasOwnProperty(p7))
            exports2[p7] = m8[p7];
      };
      __values4 = function(o11) {
        var s9 = typeof Symbol === "function" && Symbol.iterator, m8 = s9 && o11[s9], i8 = 0;
        if (m8)
          return m8.call(o11);
        if (o11 && typeof o11.length === "number")
          return {
            next: function() {
              if (o11 && i8 >= o11.length)
                o11 = void 0;
              return { value: o11 && o11[i8++], done: !o11 };
            }
          };
        throw new TypeError(s9 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read4 = function(o11, n6) {
        var m8 = typeof Symbol === "function" && o11[Symbol.iterator];
        if (!m8)
          return o11;
        var i8 = m8.call(o11), r12, ar = [], e11;
        try {
          while ((n6 === void 0 || n6-- > 0) && !(r12 = i8.next()).done)
            ar.push(r12.value);
        } catch (error) {
          e11 = { error };
        } finally {
          try {
            if (r12 && !r12.done && (m8 = i8["return"]))
              m8.call(i8);
          } finally {
            if (e11)
              throw e11.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i8 = 0; i8 < arguments.length; i8++)
          ar = ar.concat(__read4(arguments[i8]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s9 = 0, i8 = 0, il = arguments.length; i8 < il; i8++)
          s9 += arguments[i8].length;
        for (var r12 = Array(s9), k4 = 0, i8 = 0; i8 < il; i8++)
          for (var a7 = arguments[i8], j4 = 0, jl = a7.length; j4 < jl; j4++, k4++)
            r12[k4] = a7[j4];
        return r12;
      };
      __await3 = function(v6) {
        return this instanceof __await3 ? (this.v = v6, this) : new __await3(v6);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g6 = generator.apply(thisArg, _arguments || []), i8, q3 = [];
        return i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8;
        function verb(n6) {
          if (g6[n6])
            i8[n6] = function(v6) {
              return new Promise(function(a7, b7) {
                q3.push([n6, v6, a7, b7]) > 1 || resume(n6, v6);
              });
            };
        }
        function resume(n6, v6) {
          try {
            step(g6[n6](v6));
          } catch (e11) {
            settle(q3[0][3], e11);
          }
        }
        function step(r12) {
          r12.value instanceof __await3 ? Promise.resolve(r12.value.v).then(fulfill, reject2) : settle(q3[0][2], r12);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject2(value) {
          resume("throw", value);
        }
        function settle(f10, v6) {
          if (f10(v6), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator3 = function(o11) {
        var i8, p7;
        return i8 = {}, verb("next"), verb("throw", function(e11) {
          throw e11;
        }), verb("return"), i8[Symbol.iterator] = function() {
          return this;
        }, i8;
        function verb(n6, f10) {
          i8[n6] = o11[n6] ? function(v6) {
            return (p7 = !p7) ? { value: __await3(o11[n6](v6)), done: n6 === "return" } : f10 ? f10(v6) : v6;
          } : f10;
        }
      };
      __asyncValues3 = function(o11) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m8 = o11[Symbol.asyncIterator], i8;
        return m8 ? m8.call(o11) : (o11 = typeof __values4 === "function" ? __values4(o11) : o11[Symbol.iterator](), i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8);
        function verb(n6) {
          i8[n6] = o11[n6] && function(v6) {
            return new Promise(function(resolve, reject2) {
              v6 = o11[n6](v6), settle(resolve, reject2, v6.done, v6.value);
            });
          };
        }
        function settle(resolve, reject2, d7, v6) {
          Promise.resolve(v6).then(function(v7) {
            resolve({ value: v7, done: d7 });
          }, reject2);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k4 in mod)
            if (Object.hasOwnProperty.call(mod, k4))
              result[k4] = mod[k4];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign4);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values4);
      exporter("__read", __read4);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// src/index.tsx
var import_react22 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// src/yjs-tldraw/src/yjs-tldraw.tsx
var React78 = __toESM(require_react());

// ../../packages/tldraw/dist/index.mjs
var React77 = __toESM(require_react(), 1);

// ../../node_modules/mobx/dist/mobx.esm.js
function die(error) {
  for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args2[_key - 1] = arguments[_key];
  }
  if (false) {
    var e11 = typeof error === "string" ? error : errors[error];
    if (typeof e11 === "function")
      e11 = e11.apply(null, args2);
    throw new Error("[MobX] " + e11);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args2.length ? " " + args2.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die(false ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked)
      return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t12 = typeof value;
  switch (t12) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value))
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null)
    return true;
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor)
    return false;
  if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction")
    return true;
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x6) {
    return isObject(x6) && x6[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys2 = Object.keys(object2);
  if (!hasGetOwnPropertySymbols)
    return keys2;
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length)
    return keys2;
  return [].concat(keys2, symbols.filter(function(s9) {
    return objectPrototype.propertyIsEnumerable.call(object2, s9);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames;
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function _defineProperties(target, props) {
  for (var i8 = 0; i8 < props.length; i8++) {
    var descriptor = props[i8];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o11, p7) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o12, p8) {
    o12.__proto__ = p8;
    return o12;
  };
  return _setPrototypeOf(o11, p7);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o11, minLen) {
  if (!o11)
    return;
  if (typeof o11 === "string")
    return _arrayLikeToArray(o11, minLen);
  var n6 = Object.prototype.toString.call(o11).slice(8, -1);
  if (n6 === "Object" && o11.constructor)
    n6 = o11.constructor.name;
  if (n6 === "Map" || n6 === "Set")
    return Array.from(o11);
  if (n6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6))
    return _arrayLikeToArray(o11, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i8 = 0, arr2 = new Array(len); i8 < len; i8++)
    arr2[i8] = arr[i8];
  return arr2;
}
function _createForOfIteratorHelperLoose(o11, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o11[Symbol.iterator] || o11["@@iterator"];
  if (it)
    return (it = it.call(o11)).next.bind(it);
  if (Array.isArray(o11) || (it = _unsupportedIterableToArray(o11)) || allowArrayLike && o11 && typeof o11.length === "number") {
    if (it)
      o11 = it;
    var i8 = 0;
    return function() {
      if (i8 >= o11.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o11[i8++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overriden by subclass.");
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if (false) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    }
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = false ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return Atom2;
}();
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a7, b7) {
  return a7 === b7;
}
function structuralComparer(a7, b7) {
  return deepEqual(a7, b7);
}
function shallowComparer(a7, b7) {
  return deepEqual(a7, b7, 1);
}
function defaultComparer(a7, b7) {
  if (Object.is)
    return Object.is(a7, b7);
  return a7 === b7 ? a7 !== 0 || 1 / a7 === 1 / b7 : a7 !== a7 && b7 !== b7;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v6, _5, name) {
  if (isObservable(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, {
      name
    });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, {
      name
    });
  if (isES6Map(v6))
    return observable.map(v6, {
      name
    });
  if (isES6Set(v6))
    return observable.set(v6, {
      name
    });
  if (typeof v6 === "function" && !isAction(v6) && !isFlow(v6)) {
    if (isGenerator(v6)) {
      return flow(v6);
    } else {
      return autoAction(name, v6);
    }
  }
  return v6;
}
function shallowEnhancer(v6, _5, name) {
  if (v6 === void 0 || v6 === null)
    return v6;
  if (isObservableObject(v6) || isObservableArray(v6) || isObservableMap(v6) || isObservableSet(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, {
      name,
      deep: false
    });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, {
      name,
      deep: false
    });
  if (isES6Map(v6))
    return observable.map(v6, {
      name,
      deep: false
    });
  if (isES6Set(v6))
    return observable.set(v6, {
      name,
      deep: false
    });
  if (false)
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v6, oldValue) {
  if (false)
    die("observable.struct should not be used with observable values");
  if (deepEqual(v6, oldValue))
    return oldValue;
  return v6;
}
var OVERRIDE = "override";
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function createActionAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$1,
    extend_: extend_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$2,
    extend_: extend_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null)
      return 0;
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$3,
    extend_: extend_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get4 = _ref2.get;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$4,
    extend_: extend_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options2) {
  return {
    annotationType_: AUTO,
    options_: options2,
    make_: make_$5,
    extend_: extend_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set5 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set5
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set5
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options2) {
  return options2.deep === true ? deepEnhancer : options2.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options2.defaultDecorator);
}
function getAnnotationFromOptions(options2) {
  var _options$defaultDecor;
  return options2 ? (_options$defaultDecor = options2.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options2) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v6, arg2, arg3) {
  if (isStringish(arg2)) {
    storeAnnotation(v6, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v6))
    return v6;
  if (isPlainObject(v6))
    return observable.object(v6, arg2, arg3);
  if (Array.isArray(v6))
    return observable.array(v6, arg2);
  if (isES6Map(v6))
    return observable.map(v6, arg2);
  if (isES6Set(v6))
    return observable.set(v6, arg2);
  if (typeof v6 === "object" && v6 !== null)
    return v6;
  return observable.box(v6, arg2);
}
Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options2) {
    var o11 = asCreateObservableOptions(options2);
    return new ObservableValue(value, getEnhancerFromOptions(o11), o11.name, true, o11.equals);
  },
  array: function array(initialValues, options2) {
    var o11 = asCreateObservableOptions(options2);
    return (globalState.useProxies === false || o11.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o11), o11.name);
  },
  map: function map(initialValues, options2) {
    var o11 = asCreateObservableOptions(options2);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o11), o11.name);
  },
  set: function set(initialValues, options2) {
    var o11 = asCreateObservableOptions(options2);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o11), o11.name);
  },
  object: function object(props, decorators, options2) {
    return extendObservable(globalState.useProxies === false || (options2 == null ? void 0 : options2.proxy) === false ? asObservableObject({}, options2) : asDynamicObservableObject({}, options2), props, decorators);
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  if (false) {
    if (!isFunction(arg1))
      die("First argument to `computed` should be an expression.");
    if (isFunction(arg2))
      die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config;
var _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  if (false) {
    if (!isFunction(fn))
      die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName)
      die("actions should have valid names, got: '" + actionName + "'");
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args2) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args2);
  try {
    return fn.apply(scope, args2);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args2) {
  var notifySpy_ = false;
  var startTime_ = 0;
  if (false) {
    startTime_ = Date.now();
    var flattenedArgs = args2 ? Array.from(args2) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_)
    untrackedEnd(runInfo.prevDerivation_);
  if (false) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var _Symbol$toPrimitive;
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /* @__PURE__ */ function(_Atom, _Symbol$toPrimitive2) {
  _inheritsLoose(ObservableValue2, _Atom);
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = false ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (false) {
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }
    return _this;
  }
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.set = function set5(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (false) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (false)
        spyReportEnd();
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change)
        return globalState.UNCHANGED;
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get4() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately)
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive2] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom, _Symbol$toPrimitive);
var _Symbol$toPrimitive$1;
_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /* @__PURE__ */ function(_Symbol$toPrimitive2) {
  function ComputedValue2(options2) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options2.get)
      die(31);
    this.derivation = options2.get;
    this.name_ = options2.name || (false ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options2.set) {
      this.setter_ = createAction(false ? this.name_ + "-setter" : "ComputedValue-setter", options2.set);
    }
    this.equals_ = options2.equals || (options2.compareStructural || options2.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options2.context;
    this.requiresReaction_ = options2.requiresReaction;
    this.keepAlive_ = !!options2.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get4() {
    if (this.isComputing_)
      die(32, this.name_, this.derivation);
    if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext)
          globalState.trackingContext = this;
        if (this.trackAndCompute())
          propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result))
      throw result.cause;
    return result;
  };
  _proto.set = function set5(value) {
    if (this.setter_) {
      if (this.isRunningSetter_)
        die(33, this.name_);
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else
      die(34, this.name_);
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (false) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e11) {
          res = new CaughtException(e11);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
      if (false) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (true)
      return;
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive2] = function() {
    return this.valueOf();
  };
  return ComputedValue2;
}(_Symbol$toPrimitive$1);
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e11) {
  return e11 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l9 = obs.length;
      for (var i8 = 0; i8 < l9; i8++) {
        var obj = obs[i8];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e11) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  if (true) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always"))
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable2) {
  if (false) {
    console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f10, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f10.call(context);
  } else {
    try {
      result = f10.call(context);
    } catch (e11) {
      result = new CaughtException(e11);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (true)
    return;
  if (derivation.observing_.length !== 0)
    return;
  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l9 = derivation.unboundDepsCount_;
  for (var i8 = 0; i8 < l9; i8++) {
    var dep = observing[i8];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i8)
        observing[i0] = dep;
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l9 = prevObserving.length;
  while (l9--) {
    var _dep = prevObserving[l9];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i8 = obs.length;
  while (i8--) {
    removeObserver(obs[i8], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_)
    return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i8 = obs.length;
  while (i8--) {
    obs[i8].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
    canMergeGlobalState = false;
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version)
    canMergeGlobalState = false;
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED)
      global2.__mobxGlobals.UNCHANGED = {};
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions)
    die(36);
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0)
      global2.__mobxGlobals = void 0;
    globalState = new MobXGlobals();
  }
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_)
    observable2.lowestObserverState_ = node.dependenciesState_;
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation_ === false) {
    observable2.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i8 = 0; i8 < list.length; i8++) {
      var observable2 = list[i8];
      observable2.isPendingUnobservation_ = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved_) {
          observable2.isBeingObserved_ = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved_ && globalState.trackingContext) {
        observable2.isBeingObserved_ = true;
        observable2.onBO();
      }
    }
    return true;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_)
    return;
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d7) {
    if (d7.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (false) {
        logTraceInfo(d7, observable2);
      }
      d7.onBecomeStale_();
    }
    d7.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_)
    return;
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d7) {
    if (d7.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d7.dependenciesState_ = IDerivationState_.STALE_;
      if (false) {
        logTraceInfo(d7, observable2);
      }
    } else if (d7.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_)
    return;
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d7) {
    if (d7.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d7.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d7.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = false ? "Reaction@" + getNextId() : "Reaction";
    }
    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (false) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e11) {
          this.reportExceptionInDerivation_(e11);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (false) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result))
      this.reportExceptionInDerivation_(result.cause);
    if (false) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries)
      throw error;
    var message = false ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    } else if (false)
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    if (false) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState.globalReactionErrorHandlers.forEach(function(f10) {
      return f10(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_() {
    var r12 = this.dispose.bind(this);
    r12[$mobx] = this;
    return r12;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return Reaction2;
}();
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f10) {
  return f10();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions)
    return;
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error(false ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i8 = 0, l9 = remainingReactions.length; i8 < l9; i8++) {
      remainingReactions[i8].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f10) {
    return fn(function() {
      return baseScheduler(f10);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spy(listener) {
  if (true) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l9) {
        return l9 !== listener;
      });
    });
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1))
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    if (isFunction(arg2))
      return createAction(arg1, arg2, autoAction2);
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
    if (false)
      die("Invalid arguments for `action`");
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (false) {
    if (!isFunction(view))
      die("Autorun expects a function as first argument");
    if (isAction(view))
      die("Autorun does not accept actions since actions are untrackable");
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : false ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    reaction = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction.isDisposed_)
            reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  reaction.schedule_();
  return reaction.getDisposer_();
}
var run = function run2(f10) {
  return f10();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f10) {
    return setTimeout(f10, opts.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options2) {
  if (options2.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options2.useProxies, enforceActions = options2.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable")
    globalState.verifyProxies = true;
  if (enforceActions !== void 0) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options2)
      globalState[key] = !!options2[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (false) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }
  if (options2.reactionScheduler) {
    setReactionScheduler(options2.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options2) {
  if (false) {
    if (arguments.length > 4)
      die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object")
      die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target))
      die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties))
      die("'extendObservable' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations))
      die("Extending an object with another observable (object) is not supported");
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options2)[$mobx];
  startBatch();
  try {
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(key, descriptors[key], !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0)
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  if (false)
    die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args2 = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args2);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject2) {
      var stepId = 0;
      rejector = reject2;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e11) {
          return reject2(e11);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e11) {
          return reject2(e11);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject2);
          return;
        }
        if (ret.done)
          return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise)
          cancelPromise(pendingPromise);
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e11) {
        rejector(e11);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel))
    promise.cancel();
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable(value, property) {
  if (!value)
    return false;
  if (property !== void 0) {
    if (false)
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (false)
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function trace() {
  if (true)
    die("trace() is not available in production builds");
  var enterBreakPoint = false;
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
    args2[_key] = arguments[_key];
  }
  if (typeof args2[args2.length - 1] === "boolean")
    enterBreakPoint = args2.pop();
  var derivation = getAtomFromArgs(args2);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args2) {
  switch (args2.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args2[0]);
    case 2:
      return getAtom(args2[0], args2[1]);
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    if (false)
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name))
      return false;
    if (false) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (false) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish(name))
      return false;
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    if (false) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    if (false)
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options2) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options2);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1)
      interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i8 = 0, l9 = interceptors.length; i8 < l9; i8++) {
      change = interceptors[i8](change);
      if (change && !change.type)
        die(14);
      if (!change)
        break;
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1)
      listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners)
    return;
  listeners = listeners.slice();
  for (var i8 = 0, l9 = listeners.length; i8 < l9; i8++) {
    listeners[i8](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options2) {
  var adm = asObservableObject(target, options2)[$mobx];
  startBatch();
  try {
    var _annotations;
    if (false) {
      die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
    }
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name) {
    var adm = target[$mobx];
    if (name === $mobx)
      return adm;
    if (name === "length")
      return adm.getArrayLength_();
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, false ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0)
      return values.map(this.dehancer);
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0)
      die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength)
      return;
    else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i8 = 0; i8 < newLength - currentLength; i8++) {
        newItems[i8] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else
      this.spliceWithArray_(newLength, currentLength - newLength);
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_)
      die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0)
      reserveArrayBuffer(oldLength + delta + 1);
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length3 = this.values_.length;
    if (index2 === void 0)
      index2 = 0;
    else if (index2 > length3)
      index2 = length3;
    else if (index2 < 0)
      index2 = Math.max(0, length3 + index2);
    if (arguments.length === 1)
      deleteCount = length3 - index2;
    else if (deleteCount === void 0 || deleteCount === null)
      deleteCount = 0;
    else
      deleteCount = Math.max(0, Math.min(deleteCount, length3 - index2));
    if (newItems === void 0)
      newItems = EMPTY_ARRAY;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change)
        return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v6) {
      return _this.enhancer_(v6, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length3, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0)
      this.notifyArraySplice_(index2, newItems, res);
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i8 = 0; i8 < newItems.length; i8++) {
        this.values_[index2 + i8] = newItems[i8];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    if (false)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (false)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.get_ = function get_(index2) {
    if (index2 < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index2]);
    }
    console.warn(false ? "[mobx] Out of bounds read: " + index2 : "[mobx.array] Attempt to read an array index (" + index2 + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
  };
  _proto.set_ = function set_(index2, newValue) {
    var values = this.values_;
    if (index2 < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else if (index2 === values.length) {
      this.spliceWithArray_(index2, 0, [newValue]);
    } else {
      die(17, index2, values.length);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;
  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }
  return proxy;
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  toJSON: function toJSON() {
    return this.slice();
  },
  splice: function splice(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy2 = this.slice();
    copy2.sort.apply(copy2, arguments);
    this.replace(copy2);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element2, index2) {
      return callback.call(thisArg, element2, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _Symbol$iterator;
var _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /* @__PURE__ */ function(_Symbol$iterator2, _Symbol$toStringTag2) {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    this.keysAtom_ = createAtom(false ? this.name_ + ".keys()" : "ObservableMap.keys()");
    this.data_ = /* @__PURE__ */ new Map();
    this.hasMap_ = /* @__PURE__ */ new Map();
    allowStateChanges(true, function() {
      _this.merge(initialData);
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has2(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation)
      return this.has_(key);
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set5(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change)
        return this;
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change)
        return false;
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (false)
        spyReportStart(_change);
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify)
        notifyListeners(this, _change);
      if (false)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (false)
        spyReportStart(change);
      observable2.setNewValue_(newValue);
      if (notify)
        notifyListeners(this, change);
      if (false)
        spyReportEnd();
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, false ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (false)
      spyReportStart(change);
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.get = function get4(key) {
    if (this.has(key))
      return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys2() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator2] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other))
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      else if (Array.isArray(other))
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      else if (isES6Map(other)) {
        if (other.constructor !== Map)
          die(19, other);
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0)
        die(20, other);
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false)
      die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _createClass(ObservableMap2, [{
    key: "size",
    get: function get4() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Map";
    }
  }]);
  return ObservableMap2;
}(_Symbol$iterator, _Symbol$toStringTag);
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map4 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map4.set(key, dataStructure[key]);
    }
    return map4;
  } else {
    return die(21, dataStructure);
  }
}
var _Symbol$iterator$1;
var _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /* @__PURE__ */ function(_Symbol$iterator2, _Symbol$toStringTag2) {
  function ObservableSet2(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.atom_ = createAtom(this.name_);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    if (initialData) {
      this.replace(initialData);
    }
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change)
        return this;
    }
    if (!this.has(value)) {
      transaction(function() {
        _this2.data_.add(_this2.enhancer_(value, void 0));
        _this2.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && false)
        spyReportStart(_change);
      if (notify)
        notifyListeners(this, _change);
      if (notifySpy && false)
        spyReportEnd();
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this3 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change)
        return false;
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && false)
        spyReportStart(_change2);
      transaction(function() {
        _this3.atom_.reportChanged();
        _this3.data_["delete"](value);
      });
      if (notify)
        notifyListeners(this, _change2);
      if (notifySpy && false)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.has = function has2(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys2 = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values.length ? {
          value: [keys2[index2], values[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys2() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace2(other) {
    var _this4 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false)
      die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator2] = function() {
    return this.values();
  };
  _createClass(ObservableSet2, [{
    key: "size",
    get: function get4() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Set";
    }
  }]);
  return ObservableSet2;
}(_Symbol$iterator$1, _Symbol$toStringTag$1);
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom(false ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
    if (false) {
      die("defaultAnnotation must be valid annotation");
    }
    if (false) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change)
        return null;
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (false)
        spyReportStart(_change);
      observable2.setNewValue_(newValue);
      if (notify)
        notifyListeners(this, _change);
      if (false)
        spyReportEnd();
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0)
          return;
        if (outcome === 1)
          break;
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change)
          return null;
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change)
          return null;
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options2, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change)
          return null;
      }
      options2.name || (options2.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options2.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options2));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change)
        return null;
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false) {
        delete this.appliedAnnotations_[key];
      }
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false)
          spyReportStart(_change2);
        if (notify)
          notifyListeners(this, _change2);
        if (false)
          spyReportEnd();
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (false)
      die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (false)
        spyReportStart(change);
      if (notify)
        notifyListeners(this, change);
      if (false)
        spyReportEnd();
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options2) {
  var _options$name;
  if (false) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (false) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (false)
    die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options2 == null ? void 0 : options2.name) != null ? _options$name : false ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options2));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get4() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set5(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (false) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (false) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (false) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overriden by subclass.");
  }
}
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      _this.spliceWithArray(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    return _this;
  }
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(this.slice(), arrays.map(function(a7) {
      return isObservableArray(a7) ? a7.slice() : a7;
    }));
  };
  _proto[_Symbol$iterator2] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get4() {
      return this[$mobx].getArrayLength_();
    },
    set: function set5(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Array";
    }
  }]);
  return LegacyObservableArray2;
}(StubArray, Symbol.toStringTag, Symbol.iterator);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat")
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get4() {
      return this[$mobx].get_(index2);
    },
    set: function set5(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max2) {
  if (max2 > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max2 + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max2;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0)
        die(23);
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing[$mobx];
    }
    if (isObservableMap(thing)) {
      if (property === void 0)
        return thing.keysAtom_;
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2)
        die(25, property, getDebugName(thing));
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property)
        return die(26);
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable)
        die(27, property, getDebugName(thing));
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing)
    die(29);
  if (property !== void 0)
    return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
    return thing;
  if (isObservableMap(thing) || isObservableSet(thing))
    return thing;
  if (thing[$mobx])
    return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
var toString = objectPrototype.toString;
function deepEqual(a7, b7, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a7, b7, depth);
}
function eq(a7, b7, depth, aStack, bStack) {
  if (a7 === b7)
    return a7 !== 0 || 1 / a7 === 1 / b7;
  if (a7 == null || b7 == null)
    return false;
  if (a7 !== a7)
    return b7 !== b7;
  var type = typeof a7;
  if (type !== "function" && type !== "object" && typeof b7 != "object")
    return false;
  var className = toString.call(a7);
  if (className !== toString.call(b7))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a7 === "" + b7;
    case "[object Number]":
      if (+a7 !== +a7)
        return +b7 !== +b7;
      return +a7 === 0 ? 1 / +a7 === 1 / b7 : +a7 === +b7;
    case "[object Date]":
    case "[object Boolean]":
      return +a7 === +b7;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a7) === Symbol.valueOf.call(b7);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a7 = unwrap(a7);
  b7 = unwrap(b7);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a7 != "object" || typeof b7 != "object")
      return false;
    var aCtor = a7.constructor, bCtor = b7.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a7 && "constructor" in b7) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length3 = aStack.length;
  while (length3--) {
    if (aStack[length3] === a7)
      return bStack[length3] === b7;
  }
  aStack.push(a7);
  bStack.push(b7);
  if (areArrays) {
    length3 = a7.length;
    if (length3 !== b7.length)
      return false;
    while (length3--) {
      if (!eq(a7[length3], b7[length3], depth - 1, aStack, bStack))
        return false;
    }
  } else {
    var keys2 = Object.keys(a7);
    var key;
    length3 = keys2.length;
    if (Object.keys(b7).length !== length3)
      return false;
    while (length3--) {
      key = keys2[length3];
      if (!(hasProp(b7, key) && eq(a7[key], b7[key], depth - 1, aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a7) {
  if (isObservableArray(a7))
    return a7.slice();
  if (isES6Map(a7) || isObservableMap(a7))
    return Array.from(a7.entries());
  if (isES6Set(a7) || isObservableSet(a7))
    return Array.from(a7.entries());
  return a7;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m8) {
  var g6 = getGlobal();
  if (typeof g6[m8] === "undefined") {
    die("MobX requires global '" + m8 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// ../../node_modules/mobx-react-lite/es/utils/assertEnvironment.js
var import_react = __toESM(require_react());
if (!import_react.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}

// ../../node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js
var import_react_dom = __toESM(require_react_dom());

// ../../node_modules/mobx-react-lite/es/utils/observerBatching.js
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
    if (false) {
      console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native");
    }
  }
  configure({ reactionScheduler: reactionScheduler3 });
}

// ../../node_modules/mobx-react-lite/es/useObserver.js
var import_react2 = __toESM(require_react());

// ../../node_modules/mobx-react-lite/es/utils/printDebugValue.js
function printDebugValue(v6) {
  return getDependencyTree(v6);
}

// ../../node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js
var FinalizationRegistryLocal = typeof FinalizationRegistry === "undefined" ? void 0 : FinalizationRegistry;

// ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js
function createTrackingData(reaction) {
  var trackingData = {
    reaction,
    mounted: false,
    changedBeforeMount: false,
    cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS
  };
  return trackingData;
}
var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 1e4;
var CLEANUP_TIMER_LOOP_MILLIS = 1e4;

// ../../node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js
function createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry2) {
  var cleanupTokenToReactionTrackingMap = /* @__PURE__ */ new Map();
  var globalCleanupTokensCounter = 1;
  var registry = new FinalizationRegistry2(function cleanupFunction(token) {
    var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);
    if (trackedReaction) {
      trackedReaction.reaction.dispose();
      cleanupTokenToReactionTrackingMap.delete(token);
    }
  });
  return {
    addReactionToTrack: function(reactionTrackingRef, reaction, objectRetainedByReact) {
      var token = globalCleanupTokensCounter++;
      registry.register(objectRetainedByReact, token, reactionTrackingRef);
      reactionTrackingRef.current = createTrackingData(reaction);
      reactionTrackingRef.current.finalizationRegistryCleanupToken = token;
      cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);
      return reactionTrackingRef.current;
    },
    recordReactionAsCommitted: function(reactionRef) {
      registry.unregister(reactionRef);
      if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {
        cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);
      }
    },
    forceCleanupTimerToRunNowForTests: function() {
    },
    resetCleanupScheduleForTests: function() {
    }
  };
}

// ../../node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js
var __values = function(o11) {
  var s9 = typeof Symbol === "function" && Symbol.iterator, m8 = s9 && o11[s9], i8 = 0;
  if (m8)
    return m8.call(o11);
  if (o11 && typeof o11.length === "number")
    return {
      next: function() {
        if (o11 && i8 >= o11.length)
          o11 = void 0;
        return { value: o11 && o11[i8++], done: !o11 };
      }
    };
  throw new TypeError(s9 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function createTimerBasedReactionCleanupTracking() {
  var uncommittedReactionRefs = /* @__PURE__ */ new Set();
  var reactionCleanupHandle;
  function forceCleanupTimerToRunNowForTests2() {
    if (reactionCleanupHandle) {
      clearTimeout(reactionCleanupHandle);
      cleanUncommittedReactions();
    }
  }
  function resetCleanupScheduleForTests2() {
    var e_1, _a2;
    if (uncommittedReactionRefs.size > 0) {
      try {
        for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {
          var ref = uncommittedReactionRefs_1_1.value;
          var tracking = ref.current;
          if (tracking) {
            tracking.reaction.dispose();
            ref.current = null;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a2 = uncommittedReactionRefs_1.return))
            _a2.call(uncommittedReactionRefs_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      uncommittedReactionRefs.clear();
    }
    if (reactionCleanupHandle) {
      clearTimeout(reactionCleanupHandle);
      reactionCleanupHandle = void 0;
    }
  }
  function ensureCleanupTimerRunning() {
    if (reactionCleanupHandle === void 0) {
      reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);
    }
  }
  function scheduleCleanupOfReactionIfLeaked(ref) {
    uncommittedReactionRefs.add(ref);
    ensureCleanupTimerRunning();
  }
  function recordReactionAsCommitted2(reactionRef) {
    uncommittedReactionRefs.delete(reactionRef);
  }
  function cleanUncommittedReactions() {
    reactionCleanupHandle = void 0;
    var now = Date.now();
    uncommittedReactionRefs.forEach(function(ref) {
      var tracking = ref.current;
      if (tracking) {
        if (now >= tracking.cleanAt) {
          tracking.reaction.dispose();
          ref.current = null;
          uncommittedReactionRefs.delete(ref);
        }
      }
    });
    if (uncommittedReactionRefs.size > 0) {
      ensureCleanupTimerRunning();
    }
  }
  return {
    addReactionToTrack: function(reactionTrackingRef, reaction, objectRetainedByReact) {
      reactionTrackingRef.current = createTrackingData(reaction);
      scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);
      return reactionTrackingRef.current;
    },
    recordReactionAsCommitted: recordReactionAsCommitted2,
    forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests2,
    resetCleanupScheduleForTests: resetCleanupScheduleForTests2
  };
}

// ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js
var _a = FinalizationRegistryLocal ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryLocal) : createTimerBasedReactionCleanupTracking();
var addReactionToTrack = _a.addReactionToTrack;
var recordReactionAsCommitted = _a.recordReactionAsCommitted;
var resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests;
var forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;

// ../../node_modules/mobx-react-lite/es/staticRendering.js
var globalIsUsingStaticRendering = false;
function isUsingStaticRendering() {
  return globalIsUsingStaticRendering;
}

// ../../node_modules/mobx-react-lite/es/useObserver.js
var __read = function(o11, n6) {
  var m8 = typeof Symbol === "function" && o11[Symbol.iterator];
  if (!m8)
    return o11;
  var i8 = m8.call(o11), r12, ar = [], e11;
  try {
    while ((n6 === void 0 || n6-- > 0) && !(r12 = i8.next()).done)
      ar.push(r12.value);
  } catch (error) {
    e11 = { error };
  } finally {
    try {
      if (r12 && !r12.done && (m8 = i8["return"]))
        m8.call(i8);
    } finally {
      if (e11)
        throw e11.error;
    }
  }
  return ar;
};
function observerComponentNameFor(baseComponentName) {
  return "observer".concat(baseComponentName);
}
var ObjectToBeRetainedByReact = function() {
  function ObjectToBeRetainedByReact2() {
  }
  return ObjectToBeRetainedByReact2;
}();
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver(fn, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  if (isUsingStaticRendering()) {
    return fn();
  }
  var _a2 = __read(import_react2.default.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
  var _b = __read(import_react2.default.useState(), 2), setState = _b[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var reactionTrackingRef = import_react2.default.useRef(null);
  if (!reactionTrackingRef.current) {
    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (trackingData_1.mounted) {
        forceUpdate();
      } else {
        trackingData_1.changedBeforeMount = true;
      }
    });
    var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);
  }
  var reaction = reactionTrackingRef.current.reaction;
  import_react2.default.useDebugValue(reaction, printDebugValue);
  import_react2.default.useEffect(function() {
    recordReactionAsCommitted(reactionTrackingRef);
    if (reactionTrackingRef.current) {
      reactionTrackingRef.current.mounted = true;
      if (reactionTrackingRef.current.changedBeforeMount) {
        reactionTrackingRef.current.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      reactionTrackingRef.current = {
        reaction: new Reaction(observerComponentNameFor(baseComponentName), function() {
          forceUpdate();
        }),
        mounted: true,
        changedBeforeMount: false,
        cleanAt: Infinity
      };
      forceUpdate();
    }
    return function() {
      reactionTrackingRef.current.reaction.dispose();
      reactionTrackingRef.current = null;
    };
  }, []);
  var rendering;
  var exception;
  reaction.track(function() {
    try {
      rendering = fn();
    } catch (e11) {
      exception = e11;
    }
  });
  if (exception) {
    throw exception;
  }
  return rendering;
}

// ../../node_modules/mobx-react-lite/es/observer.js
var import_react3 = __toESM(require_react());
var __assign = function() {
  __assign = Object.assign || function(t12) {
    for (var s9, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
      s9 = arguments[i8];
      for (var p7 in s9)
        if (Object.prototype.hasOwnProperty.call(s9, p7))
          t12[p7] = s9[p7];
    }
    return t12;
  };
  return __assign.apply(this, arguments);
};
function observer(baseComponent, options2) {
  if (isUsingStaticRendering()) {
    return baseComponent;
  }
  var realOptions = __assign({ forwardRef: false }, options2);
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  var wrappedComponent = function(props, ref) {
    return useObserver(function() {
      return baseComponent(props, ref);
    }, baseComponentName);
  };
  if (baseComponentName !== "") {
    wrappedComponent.displayName = baseComponentName;
  }
  if (baseComponent.contextTypes) {
    wrappedComponent.contextTypes = baseComponent.contextTypes;
  }
  var memoComponent;
  if (realOptions.forwardRef) {
    memoComponent = (0, import_react3.memo)((0, import_react3.forwardRef)(wrappedComponent));
  } else {
    memoComponent = (0, import_react3.memo)(wrappedComponent);
  }
  copyStaticProperties(baseComponent, memoComponent);
  if (false) {
    Object.defineProperty(memoComponent, "contextTypes", {
      set: function() {
        var _a2;
        throw new Error("[mobx-react-lite] `".concat(this.displayName || ((_a2 = this.type) === null || _a2 === void 0 ? void 0 : _a2.displayName) || "Component", ".contextTypes` must be set before applying `observer`."));
      }
    });
  }
  return memoComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  displayName: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}

// ../../node_modules/mobx-react-lite/es/ObserverComponent.js
function ObserverComponent(_a2) {
  var children = _a2.children, render = _a2.render;
  var component = children || render;
  if (typeof component !== "function") {
    return null;
  }
  return useObserver(component);
}
if (false) {
  ObserverComponent.propTypes = {
    children: ObserverPropsCheck,
    render: ObserverPropsCheck
  };
}
ObserverComponent.displayName = "Observer";

// ../../node_modules/mobx-react-lite/es/useLocalObservable.js
var import_react4 = __toESM(require_react());

// ../../node_modules/mobx-react-lite/es/useLocalStore.js
var import_react6 = __toESM(require_react());

// ../../node_modules/mobx-react-lite/es/useAsObservableSource.js
var import_react5 = __toESM(require_react());

// ../../node_modules/mobx-react-lite/es/index.js
observerBatching(import_react_dom.unstable_batchedUpdates);

// ../../packages/core/dist/index.mjs
var React44 = __toESM(require_react(), 1);
var React43 = __toESM(require_react(), 1);
var React3 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);

// ../../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js
function clamp(v6, min2, max2) {
  return Math.max(min2, Math.min(v6, max2));
}
var V = {
  toVector(v6, fallback) {
    if (v6 === void 0)
      v6 = fallback;
    return Array.isArray(v6) ? v6 : [v6, v6];
  },
  add(v1, v22) {
    return [v1[0] + v22[0], v1[1] + v22[1]];
  },
  sub(v1, v22) {
    return [v1[0] - v22[0], v1[1] - v22[1]];
  },
  addTo(v1, v22) {
    v1[0] += v22[0];
    v1[1] += v22[1];
  },
  subTo(v1, v22) {
    v1[0] -= v22[0];
    v1[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0)
    return clamp(position, min2, max2);
  if (position < min2)
    return -rubberband(min2 - position, max2 - min2, constant) + min2;
  if (position > max2)
    return +rubberband(position - max2, max2 - min2, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// ../../node_modules/@use-gesture/core/dist/actions-5ad85d2f.esm.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys3(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i8 = 1; i8 < arguments.length; i8++) {
    var source = arguments[i8] != null ? arguments[i8] : {};
    i8 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
function toHandlerProp(device, action2 = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action2] || action2 : action2;
  return "on" + capitalize(device) + capitalize(actionKey) + (capture ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive)
    eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture)
    eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action2 = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action2] || action2 : action2;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e11) => {
    var _event$currentTarget, _event$currentTarget$;
    return e11.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e11.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P22) {
  const dx = P22.clientX - P1.clientX;
  const dy = P22.clientY - P1.clientY;
  const cx = (P22.clientX + P1.clientX) / 2;
  const cy = (P22.clientY + P1.clientY) / 2;
  const distance = Math.hypot(dx, dy);
  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  const origin = [cx, cy];
  return {
    angle,
    distance,
    origin
  };
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P22);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v6, ...args2) {
  if (typeof v6 === "function") {
    return v6(...args2);
  } else {
    return v6;
  }
}
function noop3() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop3;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args2, key) {
    this.ctrl = ctrl;
    this.args = args2;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args: args2
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args2;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
    }
    state.startTime = state.timeStamp = event.timeStamp;
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.intent)
      this.intent(movement);
    if (state._active && !state._blocked || state.active) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config)
            state._bounds = call(config.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        const previousOffset = state.offset;
        this.computeOffset();
        if (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY) {
          state.delta = V.sub(state.offset, previousOffset);
          const absoluteDelta = state.delta.map(Math.abs);
          V.addTo(state.distance, absoluteDelta);
          state.direction = state.delta.map(Math.sign);
          state._direction = state._delta.map(Math.sign);
          if (!state.first && dt > 0) {
            state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
          }
        }
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    this.computeMovement();
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
      return;
    const memo22 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo22 !== void 0)
      state.memo = memo22;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy]) {
  const d7 = Math.abs(dx) - Math.abs(dy);
  if (d7 > 0)
    return "x";
  if (d7 < 0)
    return "y";
  return void 0;
}
function restrictVectorToAxis(v6, axis) {
  switch (axis) {
    case "x":
      v6[1] = 0;
      break;
    case "y":
      v6[0] = 0;
      break;
  }
}
var CoordinatesEngine = class extends Engine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  intent(v6) {
    this.state.axis = this.state.axis || selectAxis(v6);
    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;
    if (this.state._blocked)
      return;
    if (this.config.axis || this.config.lockDirection) {
      restrictVectorToAxis(v6, this.state.axis);
    }
  }
};
var identity = (v6) => v6;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (false) {
      const originalTransform = transform || identity;
      return (v6) => {
        const r12 = originalTransform(v6);
        if (!isFinite(r12[0]) || !isFinite(r12[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r12[0]},${[1]}]`);
        }
        return r12;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (false) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top: top2 = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top2, bottom]];
  }
});
var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))
      return;
    this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScroll) {
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    if (state.type === event.type && event.timeStamp === state.timeStamp)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScroll && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (false) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [dirx, diry] = state.direction;
      const [vx, vy] = state.velocity;
      const [mx, my] = state.movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        if (Math.abs(vx) > svx && Math.abs(mx) > sx)
          state.swipe[0] = dirx;
        if (Math.abs(vy) > svy && Math.abs(my) > sy)
          state.swipe[1] = diry;
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    let device = config.device;
    if (false) {
      try {
        if (device === "pointer") {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    persistEvent(event);
    this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", this.clean.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", this.clean.bind(this), {
      passive: false
    });
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScroll, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", this.startPointerDrag.bind(this), this.config.delay, event);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      state._delta = deltaFn(factor);
      this.start(event);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    bindFunction("key", "down", this.keyDown.bind(this));
    bindFunction("key", "up", this.keyUp.bind(this));
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e11) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  pointerLock(_v, _k, {
    pointer: {
      lock = false,
      touch = false
    } = {}
  }) {
    this.useTouch = touch && SUPPORT.touch;
    return lock && SUPPORT.pointerLock;
  },
  device(_v, _k) {
    if (this.useTouch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScroll(value = false, _k, {
    preventScrollAxis = "y"
  }) {
    if (preventScrollAxis)
      this.preventScrollAxis = preventScrollAxis;
    if (!SUPPORT.touchscreen)
      return false;
    if (typeof value === "number")
      return value;
    return value ? DEFAULT_PREVENT_SCROLL_DELAY : false;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1
    } = {}
  }) {
    this.pointerButtons = buttons;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  }
});
if (false) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 36;
var PinchEngine = class extends Engine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  intent(v6) {
    const state = this.state;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(v6[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v6[1]);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
    if (this.config.lockDirection) {
      if (state.axis === "scale")
        v6[1] = 0;
      else if (state.axis === "angle")
        v6[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    if (!event.ctrlKey)
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (false) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
    } else {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  useTouch(_v, _k, {
    pointer: {
      touch = false
    } = {}
  }) {
    return touch && SUPPORT.touch;
  },
  device(_v, _k, config) {
    const sharedConfig = config.shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (this.useTouch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D5 = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D5.min, D5.max];
    };
    const _angleBounds = (state) => {
      const A3 = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A3.min, A3.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    const [ox, oy] = state.overflow;
    const [dx, dy] = state._delta;
    const [dirx, diry] = state._direction;
    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
      state._movement[0] = state._movementBound[0];
    }
    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
      state._movement[1] = state._movementBound[1];
    }
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args2) {
    super(...args2);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action2) {
  EngineMap.set(action2.key, action2.engine);
  ConfigResolverMap.set(action2.key, action2.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// ../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react7 = __toESM(require_react());

// ../../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i8;
  for (i8 = 0; i8 < sourceKeys.length; i8++) {
    key = sourceKeys[i8];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i8;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i8 = 0; i8 < sourceSymbolKeys.length; i8++) {
      key = sourceSymbolKeys[i8];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (false) {
          const r12 = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r12))
            result[key] = r12;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(config, gestureKey) {
  const _ref = config, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  const _config = {
    shared: resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver)
  };
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (false) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl) {
    _defineProperty(this, "_listeners", []);
    this._ctrl = ctrl;
  }
  add(element2, device, action2, handler, options2) {
    const type = toDomEventType(device, action2);
    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options2);
    element2.addEventListener(type, handler, eventOptions);
    this._listeners.push(() => element2.removeEventListener(type, handler, eventOptions));
  }
  clean() {
    this._listeners.forEach((remove2) => remove2());
    this._listeners = [];
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args2) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args2));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args2) {
    const sharedConfig = this.config.shared;
    const eventOptions = sharedConfig.eventOptions;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target)
        return;
    }
    const bindFunction = bindToProps(props, eventOptions, !!target);
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        if (this.config[gestureKey].enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args2, gestureKey).bind(bindFunction);
        }
      }
      for (const eventKey in this.nativeHandlers) {
        bindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args: args2
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target)
      return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action2, handler, options2 = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action2, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (false) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo22 = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo22 = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo22;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// ../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react7.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react7.default.useEffect(ctrl.effect.bind(ctrl));
  import_react7.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config = {}) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config);
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config = {}) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config);
}

// ../../packages/vec/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _Vec = class {
  static clamp(n6, min2, max2) {
    return Math.max(min2, typeof max2 !== "undefined" ? Math.min(n6, max2) : n6);
  }
  static clampV(A3, min2, max2) {
    return A3.map((n6) => max2 ? _Vec.clamp(n6, min2, max2) : _Vec.clamp(n6, min2));
  }
  static cross(x6, y5, z3) {
    return (y5[0] - x6[0]) * (z3[1] - x6[1]) - (z3[0] - x6[0]) * (y5[1] - x6[1]);
  }
  static snap(a7, step = 1) {
    return [Math.round(a7[0] / step) * step, Math.round(a7[1] / step) * step];
  }
};
var Vec = _Vec;
__publicField(Vec, "neg", (A3) => {
  return [-A3[0], -A3[1]];
});
__publicField(Vec, "add", (A3, B4) => {
  return [A3[0] + B4[0], A3[1] + B4[1]];
});
__publicField(Vec, "addScalar", (A3, n6) => {
  return [A3[0] + n6, A3[1] + n6];
});
__publicField(Vec, "sub", (A3, B4) => {
  return [A3[0] - B4[0], A3[1] - B4[1]];
});
__publicField(Vec, "subScalar", (A3, n6) => {
  return [A3[0] - n6, A3[1] - n6];
});
__publicField(Vec, "vec", (A3, B4) => {
  return [B4[0] - A3[0], B4[1] - A3[1]];
});
__publicField(Vec, "mul", (A3, n6) => {
  return [A3[0] * n6, A3[1] * n6];
});
__publicField(Vec, "mulV", (A3, B4) => {
  return [A3[0] * B4[0], A3[1] * B4[1]];
});
__publicField(Vec, "div", (A3, n6) => {
  return [A3[0] / n6, A3[1] / n6];
});
__publicField(Vec, "divV", (A3, B4) => {
  return [A3[0] / B4[0], A3[1] / B4[1]];
});
__publicField(Vec, "per", (A3) => {
  return [A3[1], -A3[0]];
});
__publicField(Vec, "dpr", (A3, B4) => {
  return A3[0] * B4[0] + A3[1] * B4[1];
});
__publicField(Vec, "cpr", (A3, B4) => {
  return A3[0] * B4[1] - B4[0] * A3[1];
});
__publicField(Vec, "len2", (A3) => {
  return A3[0] * A3[0] + A3[1] * A3[1];
});
__publicField(Vec, "len", (A3) => {
  return Math.hypot(A3[0], A3[1]);
});
__publicField(Vec, "pry", (A3, B4) => {
  return _Vec.dpr(A3, B4) / _Vec.len(B4);
});
__publicField(Vec, "uni", (A3) => {
  return _Vec.div(A3, _Vec.len(A3));
});
__publicField(Vec, "normalize", (A3) => {
  return _Vec.uni(A3);
});
__publicField(Vec, "tangent", (A3, B4) => {
  return _Vec.uni(_Vec.sub(A3, B4));
});
__publicField(Vec, "dist2", (A3, B4) => {
  return _Vec.len2(_Vec.sub(A3, B4));
});
__publicField(Vec, "dist", (A3, B4) => {
  return Math.hypot(A3[1] - B4[1], A3[0] - B4[0]);
});
__publicField(Vec, "fastDist", (A3, B4) => {
  const V5 = [B4[0] - A3[0], B4[1] - A3[1]];
  const aV = [Math.abs(V5[0]), Math.abs(V5[1])];
  let r12 = 1 / Math.max(aV[0], aV[1]);
  r12 = r12 * (1.29289 - (aV[0] + aV[1]) * r12 * 0.29289);
  return [V5[0] * r12, V5[1] * r12];
});
__publicField(Vec, "ang", (A3, B4) => {
  return Math.atan2(_Vec.cpr(A3, B4), _Vec.dpr(A3, B4));
});
__publicField(Vec, "angle", (A3, B4) => {
  return Math.atan2(B4[1] - A3[1], B4[0] - A3[0]);
});
__publicField(Vec, "med", (A3, B4) => {
  return _Vec.mul(_Vec.add(A3, B4), 0.5);
});
__publicField(Vec, "rot", (A3, r12 = 0) => {
  return [A3[0] * Math.cos(r12) - A3[1] * Math.sin(r12), A3[0] * Math.sin(r12) + A3[1] * Math.cos(r12)];
});
__publicField(Vec, "rotWith", (A3, C6, r12 = 0) => {
  if (r12 === 0)
    return A3;
  const s9 = Math.sin(r12);
  const c8 = Math.cos(r12);
  const px = A3[0] - C6[0];
  const py = A3[1] - C6[1];
  const nx = px * c8 - py * s9;
  const ny = px * s9 + py * c8;
  return [nx + C6[0], ny + C6[1]];
});
__publicField(Vec, "isEqual", (A3, B4) => {
  return A3[0] === B4[0] && A3[1] === B4[1];
});
__publicField(Vec, "lrp", (A3, B4, t12) => {
  return _Vec.add(A3, _Vec.mul(_Vec.sub(B4, A3), t12));
});
__publicField(Vec, "int", (A3, B4, from2, to, s9 = 1) => {
  const t12 = (_Vec.clamp(from2, to) - from2) / (to - from2);
  return _Vec.add(_Vec.mul(A3, 1 - t12), _Vec.mul(B4, s9));
});
__publicField(Vec, "ang3", (p1, pc, p22) => {
  const v1 = _Vec.vec(pc, p1);
  const v22 = _Vec.vec(pc, p22);
  return _Vec.ang(v1, v22);
});
__publicField(Vec, "abs", (A3) => {
  return [Math.abs(A3[0]), Math.abs(A3[1])];
});
__publicField(Vec, "rescale", (a7, n6) => {
  const l9 = _Vec.len(a7);
  return [n6 * a7[0] / l9, n6 * a7[1] / l9];
});
__publicField(Vec, "isLeft", (p1, pc, p22) => {
  return (pc[0] - p1[0]) * (p22[1] - p1[1]) - (p22[0] - p1[0]) * (pc[1] - p1[1]);
});
__publicField(Vec, "clockwise", (p1, pc, p22) => {
  return _Vec.isLeft(p1, pc, p22) > 0;
});
__publicField(Vec, "toFixed", (a7) => {
  return a7.map((v6) => Math.round(v6 * 100) / 100);
});
__publicField(Vec, "nearestPointOnLineThroughPoint", (A3, u4, P3) => {
  return _Vec.add(A3, _Vec.mul(u4, _Vec.pry(_Vec.sub(P3, A3), u4)));
});
__publicField(Vec, "distanceToLineThroughPoint", (A3, u4, P3) => {
  return _Vec.dist(P3, _Vec.nearestPointOnLineThroughPoint(A3, u4, P3));
});
__publicField(Vec, "nearestPointOnLineSegment", (A3, B4, P3, clamp2 = true) => {
  const u4 = _Vec.uni(_Vec.sub(B4, A3));
  const C6 = _Vec.add(A3, _Vec.mul(u4, _Vec.pry(_Vec.sub(P3, A3), u4)));
  if (clamp2) {
    if (C6[0] < Math.min(A3[0], B4[0]))
      return A3[0] < B4[0] ? A3 : B4;
    if (C6[0] > Math.max(A3[0], B4[0]))
      return A3[0] > B4[0] ? A3 : B4;
    if (C6[1] < Math.min(A3[1], B4[1]))
      return A3[1] < B4[1] ? A3 : B4;
    if (C6[1] > Math.max(A3[1], B4[1]))
      return A3[1] > B4[1] ? A3 : B4;
  }
  return C6;
});
__publicField(Vec, "distanceToLineSegment", (A3, B4, P3, clamp2 = true) => {
  return _Vec.dist(P3, _Vec.nearestPointOnLineSegment(A3, B4, P3, clamp2));
});
__publicField(Vec, "nudge", (A3, B4, d7) => {
  if (_Vec.isEqual(A3, B4))
    return A3;
  return _Vec.add(A3, _Vec.mul(_Vec.uni(_Vec.sub(B4, A3)), d7));
});
__publicField(Vec, "nudgeAtAngle", (A3, a7, d7) => {
  return [Math.cos(a7) * d7 + A3[0], Math.sin(a7) * d7 + A3[1]];
});
__publicField(Vec, "toPrecision", (a7, n6 = 4) => {
  return [+a7[0].toPrecision(n6), +a7[1].toPrecision(n6)];
});
__publicField(Vec, "pointsBetween", (A3, B4, steps = 6) => {
  return Array.from(Array(steps)).map((_5, i8) => {
    const t12 = i8 / (steps - 1);
    const k4 = Math.min(1, 0.5 + Math.abs(0.5 - t12));
    return [..._Vec.lrp(A3, B4, t12), k4];
  });
});
__publicField(Vec, "slope", (A3, B4) => {
  if (A3[0] === B4[0])
    return NaN;
  return (A3[1] - B4[1]) / (A3[0] - B4[0]);
});
__publicField(Vec, "max", (...v6) => {
  return [Math.max(...v6.map((a7) => a7[0])), Math.max(...v6.map((a7) => a7[1]))];
});
__publicField(Vec, "min", (...v6) => {
  return [Math.max(...v6.map((a7) => a7[0])), Math.max(...v6.map((a7) => a7[1]))];
});
var src_default = Vec;

// ../../packages/core/dist/index.mjs
var import_react9 = __toESM(require_react(), 1);
var React32 = __toESM(require_react(), 1);
var React4 = __toESM(require_react(), 1);
var React5 = __toESM(require_react(), 1);
var React6 = __toESM(require_react(), 1);
var React7 = __toESM(require_react(), 1);
var React8 = __toESM(require_react(), 1);
var React9 = __toESM(require_react(), 1);
var React10 = __toESM(require_react(), 1);
var React11 = __toESM(require_react(), 1);
var React12 = __toESM(require_react(), 1);
var React13 = __toESM(require_react(), 1);
var React14 = __toESM(require_react(), 1);
var React15 = __toESM(require_react(), 1);
var React16 = __toESM(require_react(), 1);
var React17 = __toESM(require_react(), 1);
var React18 = __toESM(require_react(), 1);
var React35 = __toESM(require_react(), 1);
var React27 = __toESM(require_react(), 1);
var React19 = __toESM(require_react(), 1);
var React20 = __toESM(require_react(), 1);
var React21 = __toESM(require_react(), 1);
var React222 = __toESM(require_react(), 1);
var React23 = __toESM(require_react(), 1);
var React25 = __toESM(require_react(), 1);
var React24 = __toESM(require_react(), 1);
var React26 = __toESM(require_react(), 1);
var React28 = __toESM(require_react(), 1);
var React30 = __toESM(require_react(), 1);
var React29 = __toESM(require_react(), 1);
var React33 = __toESM(require_react(), 1);
var React322 = __toESM(require_react(), 1);
var React31 = __toESM(require_react(), 1);
var React34 = __toESM(require_react(), 1);
var React37 = __toESM(require_react(), 1);
var React36 = __toESM(require_react(), 1);

// ../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
        var entry = _a2[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer2) {
    if (!~this.observers_.indexOf(observer2)) {
      this.observers_.push(observer2);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer2) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer2);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer2) {
      return observer2.gatherActive(), observer2.hasActive();
    });
    activeObservers.forEach(function(observer2) {
      return observer2.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser2 || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser2 || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
    var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
    var key = _a2[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles3) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles3["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles3) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles3["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles3 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles3);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles3.width), height = toFloat(styles3.height);
  if (styles3.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles3, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles3, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser2) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x6 = _a2.x, y5 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x6,
    y: y5,
    width,
    height,
    top: y5,
    right: x6 + width,
    bottom: height + y5,
    left: x6
  });
  return rect;
}
function createRectInit(x6, y5, width, height) {
  return { x: x6, y: y5, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver2 = function() {
  function ResizeObserver3(callback) {
    if (!(this instanceof ResizeObserver3)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer2 = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer2);
  }
  return ResizeObserver3;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver2.prototype[method] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method].apply(_a2, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver2;
}();
var ResizeObserver_es_default = index;

// ../../packages/core/dist/index.mjs
var React38 = __toESM(require_react(), 1);
var React39 = __toESM(require_react(), 1);
var React40 = __toESM(require_react(), 1);
var React41 = __toESM(require_react(), 1);
var React42 = __toESM(require_react(), 1);
var React45 = __toESM(require_react(), 1);
var React46 = __toESM(require_react(), 1);

// ../../packages/intersect/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a7, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp2.call(b7, prop))
      __defNormalProp3(a7, prop, b7[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b7)) {
      if (__propIsEnum2.call(b7, prop))
        __defNormalProp3(a7, prop, b7[prop]);
    }
  return a7;
};
var __spreadProps2 = (a7, b7) => __defProps2(a7, __getOwnPropDescs2(b7));
function createIntersection(message, ...points) {
  const didIntersect = points.length > 0;
  return { didIntersect, message, points };
}
function getRectangleSides(point, size, rotation = 0) {
  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
  const tl = Vec.rotWith(point, center, rotation);
  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation);
  const br = Vec.rotWith(Vec.add(point, size), center, rotation);
  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation);
  return [
    ["top", [tl, tr]],
    ["right", [tr, br]],
    ["bottom", [br, bl]],
    ["left", [bl, tl]]
  ];
}
function isAngleBetween(a7, b7, c8) {
  if (c8 === a7 || c8 === b7)
    return true;
  const PI24 = Math.PI * 2;
  const AB = (b7 - a7 + PI24) % PI24;
  const AC = (c8 - a7 + PI24) % PI24;
  return AB <= Math.PI !== AC > AB;
}
function intersectLineLine(AB, PQ) {
  const slopeAB = Vec.slope(AB[0], AB[1]);
  const slopePQ = Vec.slope(PQ[0], PQ[1]);
  if (slopeAB === slopePQ)
    return void 0;
  if (Number.isNaN(slopeAB) && !Number.isNaN(slopePQ)) {
    return [AB[0][0], (AB[0][0] - PQ[0][0]) * slopePQ + PQ[0][1]];
  }
  if (Number.isNaN(slopePQ) && !Number.isNaN(slopeAB)) {
    return [PQ[0][0], (PQ[0][0] - AB[0][0]) * slopeAB + AB[0][1]];
  }
  const x6 = (slopeAB * AB[0][0] - slopePQ * PQ[0][0] + PQ[0][1] - AB[0][1]) / (slopeAB - slopePQ);
  const y5 = slopePQ * (x6 - PQ[0][0]) + PQ[0][1];
  return [x6, y5];
}
function intersectRayLineSegment(origin, direction, a1, a22) {
  const [x6, y5] = origin;
  const [dx, dy] = direction;
  const [x1, y1] = a1;
  const [x22, y22] = a22;
  if (dy / dx !== (y22 - y1) / (x22 - x1)) {
    const d7 = dx * (y22 - y1) - dy * (x22 - x1);
    if (d7 !== 0) {
      const r12 = ((y5 - y1) * (x22 - x1) - (x6 - x1) * (y22 - y1)) / d7;
      const s9 = ((y5 - y1) * dx - (x6 - x1) * dy) / d7;
      if (r12 >= 0 && s9 >= 0 && s9 <= 1) {
        return createIntersection("intersection", [x6 + r12 * dx, y5 + r12 * dy]);
      }
    }
  }
  return createIntersection("no intersection");
}
function intersectRayRectangle(origin, direction, point, size, rotation = 0) {
  return intersectRectangleRay(point, size, rotation, origin, direction);
}
function intersectRayEllipse(origin, direction, center, rx, ry, rotation) {
  const a1 = origin;
  const a22 = Vec.mul(direction, 999999999);
  return intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation);
}
function intersectRayBounds(origin, direction, bounds, rotation = 0) {
  const { minX, minY, width, height } = bounds;
  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation);
}
function intersectLineSegmentLineSegment(a1, a22, b1, b22) {
  const AB = Vec.sub(a1, b1);
  const BV = Vec.sub(b22, b1);
  const AV = Vec.sub(a22, a1);
  const ua_t = BV[0] * AB[1] - BV[1] * AB[0];
  const ub_t = AV[0] * AB[1] - AV[1] * AB[0];
  const u_b = BV[1] * AV[0] - BV[0] * AV[1];
  if (ua_t === 0 || ub_t === 0) {
    return createIntersection("coincident");
  }
  if (u_b === 0) {
    return createIntersection("parallel");
  }
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return createIntersection("intersection", Vec.add(a1, Vec.mul(AV, ua)));
    }
  }
  return createIntersection("no intersection");
}
function intersectLineSegmentRectangle(a1, a22, point, size) {
  return intersectRectangleLineSegment(point, size, a1, a22);
}
function intersectLineSegmentArc(a1, a22, center, radius, start, end) {
  const sa = Vec.angle(center, start);
  const ea = Vec.angle(center, end);
  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a22);
  if (!ellipseTest.didIntersect)
    return createIntersection("no intersection");
  const points = ellipseTest.points.filter((point) => isAngleBetween(sa, ea, Vec.angle(center, point)));
  if (points.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentCircle(a1, a22, c8, r12) {
  const a7 = (a22[0] - a1[0]) * (a22[0] - a1[0]) + (a22[1] - a1[1]) * (a22[1] - a1[1]);
  const b7 = 2 * ((a22[0] - a1[0]) * (a1[0] - c8[0]) + (a22[1] - a1[1]) * (a1[1] - c8[1]));
  const cc = c8[0] * c8[0] + c8[1] * c8[1] + a1[0] * a1[0] + a1[1] * a1[1] - 2 * (c8[0] * a1[0] + c8[1] * a1[1]) - r12 * r12;
  const deter = b7 * b7 - 4 * a7 * cc;
  if (deter < 0) {
    return createIntersection("outside");
  }
  if (deter === 0) {
    return createIntersection("tangent");
  }
  const e11 = Math.sqrt(deter);
  const u1 = (-b7 + e11) / (2 * a7);
  const u22 = (-b7 - e11) / (2 * a7);
  if ((u1 < 0 || u1 > 1) && (u22 < 0 || u22 > 1)) {
    if (u1 < 0 && u22 < 0 || u1 > 1 && u22 > 1) {
      return createIntersection("outside");
    } else {
      return createIntersection("inside");
    }
  }
  const results = [];
  if (0 <= u1 && u1 <= 1)
    results.push(Vec.lrp(a1, a22, u1));
  if (0 <= u22 && u22 <= 1)
    results.push(Vec.lrp(a1, a22, u22));
  return createIntersection("intersection", ...results);
}
function intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation = 0) {
  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a22)) {
    return createIntersection("no intersection");
  }
  rx = rx < 0 ? rx : -rx;
  ry = ry < 0 ? ry : -ry;
  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center);
  a22 = Vec.sub(Vec.rotWith(a22, center, -rotation), center);
  const diff = Vec.sub(a22, a1);
  const A3 = diff[0] * diff[0] / rx / rx + diff[1] * diff[1] / ry / ry;
  const B4 = 2 * a1[0] * diff[0] / rx / rx + 2 * a1[1] * diff[1] / ry / ry;
  const C6 = a1[0] * a1[0] / rx / rx + a1[1] * a1[1] / ry / ry - 1;
  const tValues = [];
  const discriminant = B4 * B4 - 4 * A3 * C6;
  if (discriminant === 0) {
    tValues.push(-B4 / 2 / A3);
  } else if (discriminant > 0) {
    const root = Math.sqrt(discriminant);
    tValues.push((-B4 + root) / 2 / A3);
    tValues.push((-B4 - root) / 2 / A3);
  }
  const points = tValues.filter((t12) => t12 >= 0 && t12 <= 1).map((t12) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a22, a1), t12)))).map((p7) => Vec.rotWith(p7, center, rotation));
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentBounds(a1, a22, bounds) {
  return intersectBoundsLineSegment(bounds, a1, a22);
}
function intersectLineSegmentPolyline(a1, a22, points) {
  const pts = [];
  for (let i8 = 1; i8 < points.length; i8++) {
    const int = intersectLineSegmentLineSegment(a1, a22, points[i8 - 1], points[i8]);
    if (int) {
      pts.push(...int.points);
    }
  }
  if (pts.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentPolygon(a1, a22, points) {
  const pts = [];
  for (let i8 = 1; i8 < points.length + 1; i8++) {
    const int = intersectLineSegmentLineSegment(a1, a22, points[i8 - 1], points[i8 % points.length]);
    if (int) {
      pts.push(...int.points);
    }
  }
  if (pts.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectRectangleRay(point, size, rotation, origin, direction) {
  const sideIntersections = getRectangleSides(point, size, rotation).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectRayLineSegment(origin, direction, a1, a22);
    if (intersection) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleLineSegment(point, size, a1, a22) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [b1, b22]]) => {
    const intersection = intersectLineSegmentLineSegment(a1, a22, b1, b22);
    if (intersection) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleRectangle(point1, size1, point2, size2) {
  const sideIntersections = getRectangleSides(point1, size1).reduce((acc, [message, [a1, a22]]) => {
    const intersections = intersectRectangleLineSegment(point2, size2, a1, a22);
    acc.push(...intersections.map((int) => createIntersection(`${message} ${int.message}`, ...int.points)));
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleArc(point, size, center, radius, start, end) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectArcLineSegment(center, radius, start, end, a1, a22);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleCircle(point, size, c8, r12) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentCircle(a1, a22, c8, r12);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleEllipse(point, size, c8, rx, ry, rotation = 0) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentEllipse(a1, a22, c8, rx, ry, rotation);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectanglePolyline(point, size, points) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentPolyline(a1, a22, points);
    if (intersection.didIntersect) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectanglePolygon(point, size, points) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentPolygon(a1, a22, points);
    if (intersection.didIntersect) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectArcLineSegment(center, radius, start, end, a1, a22) {
  return intersectLineSegmentArc(a1, a22, center, radius, start, end);
}
function intersectArcRectangle(center, radius, start, end, point, size) {
  return intersectRectangleArc(point, size, center, radius, start, end);
}
function intersectArcBounds(center, radius, start, end, bounds) {
  const { minX, minY, width, height } = bounds;
  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height]);
}
function intersectCircleLineSegment(c8, r12, a1, a22) {
  return intersectLineSegmentCircle(a1, a22, c8, r12);
}
function intersectCircleCircle(c1, r1, c22, r22) {
  let dx = c22[0] - c1[0], dy = c22[1] - c1[1];
  const d7 = Math.sqrt(dx * dx + dy * dy), x6 = (d7 * d7 - r22 * r22 + r1 * r1) / (2 * d7), y5 = Math.sqrt(r1 * r1 - x6 * x6);
  dx /= d7;
  dy /= d7;
  return createIntersection("intersection", [c1[0] + dx * x6 - dy * y5, c1[1] + dy * x6 + dx * y5], [c1[0] + dx * x6 + dy * y5, c1[1] + dy * x6 - dx * y5]);
}
function intersectEllipseLineSegment(center, rx, ry, rotation = 0, a1, a22) {
  if (rx === ry) {
    return intersectLineSegmentCircle(a1, a22, center, rx);
  }
  return intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation);
}
function intersectEllipseRectangle(center, rx, ry, rotation = 0, point, size) {
  if (rx === ry) {
    return intersectRectangleCircle(point, size, center, rx);
  }
  return intersectRectangleEllipse(point, size, center, rx, ry, rotation);
}
function intersectEllipseBounds(c8, rx, ry, rotation, bounds) {
  const { minX, minY, width, height } = bounds;
  return intersectEllipseRectangle(c8, rx, ry, rotation, [minX, minY], [width, height]);
}
function intersectBoundsLineSegment(bounds, a1, a22) {
  const { minX, minY, width, height } = bounds;
  return intersectLineSegmentRectangle(a1, a22, [minX, minY], [width, height]);
}
function intersectBoundsBounds(bounds1, bounds2) {
  return intersectRectangleRectangle([bounds1.minX, bounds1.minY], [bounds1.width, bounds1.height], [bounds2.minX, bounds2.minY], [bounds2.width, bounds2.height]);
}
function intersectBoundsPolyline(bounds, points) {
  return intersectPolylineBounds(points, bounds);
}
function intersectBoundsPolygon(bounds, points) {
  return intersectPolygonBounds(points, bounds);
}
function intersectPolylineBounds(points, bounds) {
  return intersectRectanglePolyline([bounds.minX, bounds.minY], [bounds.width, bounds.height], points);
}
function intersectPolygonBounds(points, bounds) {
  return intersectRectanglePolygon([bounds.minX, bounds.minY], [bounds.width, bounds.height], points);
}

// ../../packages/core/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a7, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp3.call(b7, prop))
      __defNormalProp4(a7, prop, b7[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b7)) {
      if (__propIsEnum3.call(b7, prop))
        __defNormalProp4(a7, prop, b7[prop]);
    }
  return a7;
};
var __spreadProps3 = (a7, b7) => __defProps3(a7, __getOwnPropDescs3(b7));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField2 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var TLContext = React3.createContext({});
function useTLContext() {
  const context = React3.useContext(TLContext);
  return context;
}
var TLBoundsCorner = /* @__PURE__ */ ((TLBoundsCorner2) => {
  TLBoundsCorner2["TopLeft"] = "top_left_corner";
  TLBoundsCorner2["TopRight"] = "top_right_corner";
  TLBoundsCorner2["BottomRight"] = "bottom_right_corner";
  TLBoundsCorner2["BottomLeft"] = "bottom_left_corner";
  return TLBoundsCorner2;
})(TLBoundsCorner || {});
if (!String.prototype.replaceAll) {
  String.prototype.replaceAll = function(str, newStr) {
    if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
      return this.replace(str, newStr);
    }
    return this.replace(new RegExp(str, "g"), newStr);
  };
}
var TAU = Math.PI * 2;
var _Utils = class {
  static lerp(y1, y22, mu) {
    mu = _Utils.clamp(mu, 0, 1);
    return y1 * (1 - mu) + y22 * mu;
  }
  static lerpColor(color1, color2, factor = 0.5) {
    function h2r(hex) {
      const result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return [parseInt(result2[1], 16), parseInt(result2[2], 16), parseInt(result2[3], 16)];
    }
    function r2h(rgb) {
      return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
    }
    const c1 = h2r(color1) || [0, 0, 0];
    const c22 = h2r(color2) || [0, 0, 0];
    const result = c1.slice();
    for (let i8 = 0; i8 < 3; i8++) {
      result[i8] = Math.round(result[i8] + factor * (c22[i8] - c1[i8]));
    }
    return r2h(result);
  }
  static modulate(value, rangeA, rangeB, clamp2 = false) {
    const [fromLow, fromHigh] = rangeA;
    const [v0, v1] = rangeB;
    const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
    return clamp2 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
  }
  static clamp(n6, min2, max2) {
    return Math.max(min2, typeof max2 !== "undefined" ? Math.min(n6, max2) : n6);
  }
  static deepClone(obj) {
    if (obj === null)
      return obj;
    if (Array.isArray(obj)) {
      return [...obj];
    }
    if (typeof obj === "object") {
      const clone = __spreadValues3({}, obj);
      Object.keys(clone).forEach((key) => clone[key] = typeof obj[key] === "object" ? _Utils.deepClone(obj[key]) : obj[key]);
      return clone;
    }
    return obj;
  }
  static rng(seed = "") {
    let x6 = 0;
    let y5 = 0;
    let z3 = 0;
    let w6 = 0;
    function next() {
      const t12 = x6 ^ x6 << 11;
      x6 = y5;
      y5 = z3;
      z3 = w6;
      w6 ^= (w6 >>> 19 ^ t12 ^ t12 >>> 8) >>> 0;
      return w6 / 4294967296;
    }
    for (let k4 = 0; k4 < seed.length + 64; k4++) {
      x6 ^= seed.charCodeAt(k4) | 0;
      next();
    }
    return next;
  }
  static pointsToLineSegments(points, closed = false) {
    const segments = [];
    for (let i8 = 1; i8 < points.length; i8++)
      segments.push([points[i8 - 1], points[i8]]);
    if (closed)
      segments.push([points[points.length - 1], points[0]]);
    return segments;
  }
  static getRectangleSides(point, size, rotation = 0) {
    const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
    const tl = Vec.rotWith(point, center, rotation);
    const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation);
    const br = Vec.rotWith(Vec.add(point, size), center, rotation);
    const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation);
    return [
      ["top", [tl, tr]],
      ["right", [tr, br]],
      ["bottom", [br, bl]],
      ["left", [bl, tl]]
    ];
  }
  static circleFromThreePoints(A3, B4, C6) {
    const [x1, y1] = A3;
    const [x22, y22] = B4;
    const [x32, y32] = C6;
    const a7 = x1 * (y22 - y32) - y1 * (x22 - x32) + x22 * y32 - x32 * y22;
    const b7 = (x1 * x1 + y1 * y1) * (y32 - y22) + (x22 * x22 + y22 * y22) * (y1 - y32) + (x32 * x32 + y32 * y32) * (y22 - y1);
    const c8 = (x1 * x1 + y1 * y1) * (x22 - x32) + (x22 * x22 + y22 * y22) * (x32 - x1) + (x32 * x32 + y32 * y32) * (x1 - x22);
    const x6 = -b7 / (2 * a7);
    const y5 = -c8 / (2 * a7);
    return [x6, y5, Math.hypot(x6 - x1, y5 - y1)];
  }
  static perimeterOfEllipse(rx, ry) {
    const h4 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    const p7 = Math.PI * (rx + ry) * (1 + 3 * h4 / (10 + Math.sqrt(4 - 3 * h4)));
    return p7;
  }
  static shortAngleDist(a0, a1) {
    const max2 = Math.PI * 2;
    const da = (a1 - a0) % max2;
    return 2 * da % max2 - da;
  }
  static longAngleDist(a0, a1) {
    return Math.PI * 2 - _Utils.shortAngleDist(a0, a1);
  }
  static lerpAngles(a0, a1, t12) {
    return a0 + _Utils.shortAngleDist(a0, a1) * t12;
  }
  static angleDelta(a0, a1) {
    return _Utils.shortAngleDist(a0, a1);
  }
  static getSweep(C6, A3, B4) {
    return _Utils.angleDelta(Vec.angle(C6, A3), Vec.angle(C6, B4));
  }
  static clampRadians(r12) {
    return (Math.PI * 2 + r12) % (Math.PI * 2);
  }
  static snapAngleToSegments(r12, segments) {
    const seg = Math.PI * 2 / segments;
    return Math.floor((_Utils.clampRadians(r12) + seg / 2) / seg) * seg;
  }
  static isAngleBetween(a7, b7, c8) {
    if (c8 === a7 || c8 === b7)
      return true;
    const AB = (b7 - a7 + TAU) % TAU;
    const AC = (c8 - a7 + TAU) % TAU;
    return AB <= Math.PI !== AC > AB;
  }
  static degreesToRadians(d7) {
    return d7 * Math.PI / 180;
  }
  static radiansToDegrees(r12) {
    return r12 * 180 / Math.PI;
  }
  static getArcLength(C6, r12, A3, B4) {
    const sweep = _Utils.getSweep(C6, A3, B4);
    return r12 * (2 * Math.PI) * (sweep / (2 * Math.PI));
  }
  static getSweepFlag(A3, B4, C6) {
    const angleAC = Vec.angle(A3, C6);
    const angleAB = Vec.angle(A3, B4);
    const angleCAB = (angleAB - angleAC + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return angleCAB > 0 ? 0 : 1;
  }
  static getLargeArcFlag(A3, C6, P3) {
    const anglePA = Vec.angle(P3, A3);
    const anglePC = Vec.angle(P3, C6);
    const angleAPC = (anglePC - anglePA + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(angleAPC) > Math.PI / 2 ? 0 : 1;
  }
  static getArcDashOffset(C6, r12, A3, B4, step) {
    const del0 = _Utils.getSweepFlag(C6, A3, B4);
    const len0 = _Utils.getArcLength(C6, r12, A3, B4);
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C6[2] - len0;
    return -off0 / 2 + step;
  }
  static getEllipseDashOffset(A3, step) {
    const c8 = 2 * Math.PI * A3[2];
    return -c8 / 2 + -step;
  }
  static pointInCircle(A3, C6, r12) {
    return Vec.dist(A3, C6) <= r12;
  }
  static pointInEllipse(A3, C6, rx, ry, rotation = 0) {
    rotation = rotation || 0;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const delta = Vec.sub(A3, C6);
    const tdx = cos * delta[0] + sin * delta[1];
    const tdy = sin * delta[0] - cos * delta[1];
    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;
  }
  static pointInRect(point, size) {
    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);
  }
  static pointInPolygon(p7, points) {
    let wn = 0;
    points.forEach((a7, i8) => {
      const b7 = points[(i8 + 1) % points.length];
      if (a7[1] <= p7[1]) {
        if (b7[1] > p7[1] && Vec.cross(a7, b7, p7) > 0) {
          wn += 1;
        }
      } else if (b7[1] <= p7[1] && Vec.cross(a7, b7, p7) < 0) {
        wn -= 1;
      }
    });
    return wn !== 0;
  }
  static pointInBounds(A3, b7) {
    return !(A3[0] < b7.minX || A3[0] > b7.maxX || A3[1] < b7.minY || A3[1] > b7.maxY);
  }
  static pointInPolyline(A3, points, distance = 3) {
    for (let i8 = 1; i8 < points.length; i8++) {
      if (Vec.distanceToLineSegment(points[i8 - 1], points[i8], A3) < distance) {
        return true;
      }
    }
    return false;
  }
  static getBoundsSides(bounds) {
    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);
  }
  static expandBounds(bounds, delta) {
    return {
      minX: bounds.minX - delta,
      minY: bounds.minY - delta,
      maxX: bounds.maxX + delta,
      maxY: bounds.maxY + delta,
      width: bounds.width + delta * 2,
      height: bounds.height + delta * 2
    };
  }
  static boundsCollide(a7, b7) {
    return !(a7.maxX < b7.minX || a7.minX > b7.maxX || a7.maxY < b7.minY || a7.minY > b7.maxY);
  }
  static boundsContain(a7, b7) {
    return a7.minX < b7.minX && a7.minY < b7.minY && a7.maxY > b7.maxY && a7.maxX > b7.maxX;
  }
  static boundsContained(a7, b7) {
    return _Utils.boundsContain(b7, a7);
  }
  static boundsAreEqual(a7, b7) {
    return !(b7.maxX !== a7.maxX || b7.minX !== a7.minX || b7.maxY !== a7.maxY || b7.minY !== a7.minY);
  }
  static getBoundsFromPoints(points, rotation = 0) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if (points.length < 2) {
      minX = 0;
      minY = 0;
      maxX = 1;
      maxY = 1;
    } else {
      for (const [x6, y5] of points) {
        minX = Math.min(x6, minX);
        minY = Math.min(y5, minY);
        maxX = Math.max(x6, maxX);
        maxY = Math.max(y5, maxY);
      }
    }
    if (rotation !== 0) {
      return _Utils.getBoundsFromPoints(points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation)));
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static centerBounds(bounds, point) {
    const boundsCenter = this.getBoundsCenter(bounds);
    const dx = point[0] - boundsCenter[0];
    const dy = point[1] - boundsCenter[1];
    return this.translateBounds(bounds, [dx, dy]);
  }
  static snapBoundsToGrid(bounds, gridSize) {
    const minX = Math.round(bounds.minX / gridSize) * gridSize;
    const minY = Math.round(bounds.minY / gridSize) * gridSize;
    const maxX = Math.round(bounds.maxX / gridSize) * gridSize;
    const maxY = Math.round(bounds.maxY / gridSize) * gridSize;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static translateBounds(bounds, delta) {
    return {
      minX: bounds.minX + delta[0],
      minY: bounds.minY + delta[1],
      maxX: bounds.maxX + delta[0],
      maxY: bounds.maxY + delta[1],
      width: bounds.width,
      height: bounds.height
    };
  }
  static rotateBounds(bounds, center, rotation) {
    const [minX, minY] = Vec.rotWith([bounds.minX, bounds.minY], center, rotation);
    const [maxX, maxY] = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation);
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: bounds.width,
      height: bounds.height
    };
  }
  static getRotatedEllipseBounds(x6, y5, rx, ry, rotation = 0) {
    const c8 = Math.cos(rotation);
    const s9 = Math.sin(rotation);
    const w6 = Math.hypot(rx * c8, ry * s9);
    const h4 = Math.hypot(rx * s9, ry * c8);
    return {
      minX: x6 + rx - w6,
      minY: y5 + ry - h4,
      maxX: x6 + rx + w6,
      maxY: y5 + ry + h4,
      width: w6 * 2,
      height: h4 * 2
    };
  }
  static getExpandedBounds(a7, b7) {
    const minX = Math.min(a7.minX, b7.minX);
    const minY = Math.min(a7.minY, b7.minY);
    const maxX = Math.max(a7.maxX, b7.maxX);
    const maxY = Math.max(a7.maxY, b7.maxY);
    const width = Math.abs(maxX - minX);
    const height = Math.abs(maxY - minY);
    return { minX, minY, maxX, maxY, width, height };
  }
  static getCommonBounds(bounds) {
    if (bounds.length < 2)
      return bounds[0];
    let result = bounds[0];
    for (let i8 = 1; i8 < bounds.length; i8++) {
      result = _Utils.getExpandedBounds(result, bounds[i8]);
    }
    return result;
  }
  static getRotatedCorners(b7, rotation = 0) {
    const center = [b7.minX + b7.width / 2, b7.minY + b7.height / 2];
    return [
      [b7.minX, b7.minY],
      [b7.maxX, b7.minY],
      [b7.maxX, b7.maxY],
      [b7.minX, b7.maxY]
    ].map((point) => Vec.rotWith(point, center, rotation));
  }
  static getTransformedBoundingBox(bounds, handle, delta, rotation = 0, isAspectRatioLocked = false) {
    const [ax0, ay0] = [bounds.minX, bounds.minY];
    const [ax1, ay1] = [bounds.maxX, bounds.maxY];
    let [bx0, by0] = [bounds.minX, bounds.minY];
    let [bx1, by1] = [bounds.maxX, bounds.maxY];
    if (handle === "center") {
      return {
        minX: bx0 + delta[0],
        minY: by0 + delta[1],
        maxX: bx1 + delta[0],
        maxY: by1 + delta[1],
        width: bx1 - bx0,
        height: by1 - by0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const [dx, dy] = Vec.rot(delta, -rotation);
    switch (handle) {
      case "top_edge":
      case "top_left_corner":
      case "top_right_corner": {
        by0 += dy;
        break;
      }
      case "bottom_edge":
      case "bottom_left_corner":
      case "bottom_right_corner": {
        by1 += dy;
        break;
      }
    }
    switch (handle) {
      case "left_edge":
      case "top_left_corner":
      case "bottom_left_corner": {
        bx0 += dx;
        break;
      }
      case "right_edge":
      case "top_right_corner":
      case "bottom_right_corner": {
        bx1 += dx;
        break;
      }
    }
    const aw = ax1 - ax0;
    const ah = ay1 - ay0;
    const scaleX = (bx1 - bx0) / aw;
    const scaleY = (by1 - by0) / ah;
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    const bw = Math.abs(bx1 - bx0);
    const bh = Math.abs(by1 - by0);
    if (isAspectRatioLocked) {
      const ar = aw / ah;
      const isTall = ar < bw / bh;
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);
      const th = bh * (scaleX < 0 ? 1 : -1) * ar;
      switch (handle) {
        case "top_left_corner": {
          if (isTall)
            by0 = by1 + tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case "top_right_corner": {
          if (isTall)
            by0 = by1 + tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case "bottom_right_corner": {
          if (isTall)
            by1 = by0 - tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case "bottom_left_corner": {
          if (isTall)
            by1 = by0 - tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case "bottom_edge":
        case "top_edge": {
          const m8 = (bx0 + bx1) / 2;
          const w6 = bh * ar;
          bx0 = m8 - w6 / 2;
          bx1 = m8 + w6 / 2;
          break;
        }
        case "left_edge":
        case "right_edge": {
          const m8 = (by0 + by1) / 2;
          const h4 = bw / ar;
          by0 = m8 - h4 / 2;
          by1 = m8 + h4 / 2;
          break;
        }
      }
    }
    if (rotation % (Math.PI * 2) !== 0) {
      let cv = [0, 0];
      const c0 = Vec.med([ax0, ay0], [ax1, ay1]);
      const c1 = Vec.med([bx0, by0], [bx1, by1]);
      switch (handle) {
        case "top_left_corner": {
          cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation));
          break;
        }
        case "top_right_corner": {
          cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation));
          break;
        }
        case "bottom_right_corner": {
          cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation));
          break;
        }
        case "bottom_left_corner": {
          cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation));
          break;
        }
        case "top_edge": {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation));
          break;
        }
        case "left_edge": {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation));
          break;
        }
        case "bottom_edge": {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation));
          break;
        }
        case "right_edge": {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation));
          break;
        }
      }
      ;
      [bx0, by0] = Vec.sub([bx0, by0], cv);
      [bx1, by1] = Vec.sub([bx1, by1], cv);
    }
    if (bx1 < bx0) {
      ;
      [bx1, bx0] = [bx0, bx1];
    }
    if (by1 < by0) {
      ;
      [by1, by0] = [by0, by1];
    }
    return {
      minX: bx0,
      minY: by0,
      maxX: bx1,
      maxY: by1,
      width: bx1 - bx0,
      height: by1 - by0,
      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),
      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)
    };
  }
  static getTransformAnchor(type, isFlippedX, isFlippedY) {
    let anchor = type;
    switch (type) {
      case "top_left_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "bottom_right_corner";
        } else if (isFlippedX) {
          anchor = "top_right_corner";
        } else if (isFlippedY) {
          anchor = "bottom_left_corner";
        } else {
          anchor = "bottom_right_corner";
        }
        break;
      }
      case "top_right_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "bottom_left_corner";
        } else if (isFlippedX) {
          anchor = "top_left_corner";
        } else if (isFlippedY) {
          anchor = "bottom_right_corner";
        } else {
          anchor = "bottom_left_corner";
        }
        break;
      }
      case "bottom_right_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "top_left_corner";
        } else if (isFlippedX) {
          anchor = "bottom_left_corner";
        } else if (isFlippedY) {
          anchor = "top_right_corner";
        } else {
          anchor = "top_left_corner";
        }
        break;
      }
      case "bottom_left_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "top_right_corner";
        } else if (isFlippedX) {
          anchor = "bottom_right_corner";
        } else if (isFlippedY) {
          anchor = "top_left_corner";
        } else {
          anchor = "top_right_corner";
        }
        break;
      }
    }
    return anchor;
  }
  static getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {
    const nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;
    const ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;
    const nw = initialShapeBounds.width / initialBounds.width;
    const nh = initialShapeBounds.height / initialBounds.height;
    const minX = bounds.minX + bounds.width * nx;
    const minY = bounds.minY + bounds.height * ny;
    const width = bounds.width * nw;
    const height = bounds.height * nh;
    return {
      minX,
      minY,
      maxX: minX + width,
      maxY: minY + height,
      width,
      height
    };
  }
  static getRotatedSize(size, rotation) {
    const center = Vec.div(size, 2);
    const points = [[0, 0], [size[0], 0], size, [0, size[1]]].map((point) => Vec.rotWith(point, center, rotation));
    const bounds = _Utils.getBoundsFromPoints(points);
    return [bounds.width, bounds.height];
  }
  static getBoundsCenter(bounds) {
    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];
  }
  static getBoundsWithCenter(bounds) {
    const center = _Utils.getBoundsCenter(bounds);
    return __spreadProps3(__spreadValues3({}, bounds), {
      midX: center[0],
      midY: center[1]
    });
  }
  static getCommonTopLeft(points) {
    const min2 = [Infinity, Infinity];
    points.forEach((point) => {
      min2[0] = Math.min(min2[0], point[0]);
      min2[1] = Math.min(min2[1], point[1]);
    });
    return min2;
  }
  static getFromCache(cache, item, getNext) {
    let value = cache.get(item);
    if (value === void 0) {
      cache.set(item, getNext());
      value = cache.get(item);
      if (value === void 0) {
        throw Error("Cache did not include item!");
      }
    }
    return value;
  }
  static uniqueId(a7 = "") {
    return a7 ? ((Number(a7) ^ Math.random() * 16) >> Number(a7) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, _Utils.uniqueId);
  }
  static rotateArray(arr, offset) {
    return arr.map((_5, i8) => arr[(i8 + offset) % arr.length]);
  }
  static debounce(fn, ms = 0) {
    let timeoutId;
    return function(...args2) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(args2), ms);
    };
  }
  static getSvgPathFromStroke(points, closed = true) {
    if (!points.length) {
      return "";
    }
    const max2 = points.length - 1;
    return points.reduce((acc, point, i8, arr) => {
      if (i8 === max2) {
        if (closed)
          acc.push("Z");
      } else
        acc.push(point, Vec.med(point, arr[i8 + 1]));
      return acc;
    }, ["M", points[0], "Q"]).join(" ").replaceAll(this.TRIM_NUMBERS, "$1");
  }
  static getPerfectDashProps(length3, strokeWidth, style, snap = 1, outset = true, lengthRatio = 2) {
    let dashLength;
    let strokeDashoffset;
    let ratio;
    if (style.toLowerCase() === "dashed") {
      dashLength = strokeWidth * lengthRatio;
      ratio = 1;
      strokeDashoffset = outset ? (dashLength / 2).toString() : "0";
    } else if (style.toLowerCase() === "dotted") {
      dashLength = strokeWidth / 100;
      ratio = 100;
      strokeDashoffset = "0";
    } else {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
    let dashes = Math.floor(length3 / dashLength / (2 * ratio));
    dashes -= dashes % snap;
    dashes = Math.max(dashes, 4);
    const gapLength = Math.max(dashLength, (length3 - dashes * dashLength) / (outset ? dashes : dashes - 1));
    return {
      strokeDasharray: [dashLength, gapLength].join(" "),
      strokeDashoffset
    };
  }
  static isMobileSize() {
    if (typeof window === "undefined")
      return false;
    return window.innerWidth < 768;
  }
  static isMobileSafari() {
    if (typeof window === "undefined")
      return false;
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }
  static throttle(func, limit) {
    let inThrottle;
    let lastResult;
    return function(...args2) {
      if (!inThrottle) {
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
        lastResult = func(...args2);
      }
      return lastResult;
    };
  }
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  static metaKey(e11) {
    return _Utils.isDarwin() ? e11.metaKey : e11.ctrlKey;
  }
};
var Utils = _Utils;
__publicField2(Utils, "getSnapPoints", (bounds, others, snapDistance) => {
  const A3 = __spreadValues3({}, bounds);
  const offset = [0, 0];
  const snapLines = [];
  const snaps = {
    ["minX"]: { id: "minX", isSnapped: false },
    ["midX"]: { id: "midX", isSnapped: false },
    ["maxX"]: { id: "maxX", isSnapped: false },
    ["minY"]: { id: "minY", isSnapped: false },
    ["midY"]: { id: "midY", isSnapped: false },
    ["maxY"]: { id: "maxY", isSnapped: false }
  };
  const xs = ["midX", "minX", "maxX"];
  const ys = ["midY", "minY", "maxY"];
  const snapResults = others.map((B4) => {
    const rx = xs.flatMap((f10, i8) => xs.map((t12, k4) => {
      const gap = A3[f10] - B4[t12];
      const distance = Math.abs(gap);
      return {
        f: f10,
        t: t12,
        gap,
        distance,
        isCareful: i8 === 0 || i8 + k4 === 3
      };
    }));
    const ry = ys.flatMap((f10, i8) => ys.map((t12, k4) => {
      const gap = A3[f10] - B4[t12];
      const distance = Math.abs(gap);
      return {
        f: f10,
        t: t12,
        gap,
        distance,
        isCareful: i8 === 0 || i8 + k4 === 3
      };
    }));
    return [B4, rx, ry];
  });
  let gapX = Infinity;
  let gapY = Infinity;
  let minX = Infinity;
  let minY = Infinity;
  snapResults.forEach(([_5, rx, ry]) => {
    rx.forEach((r12) => {
      if (r12.distance < snapDistance && r12.distance < minX) {
        minX = r12.distance;
        gapX = r12.gap;
      }
    });
    ry.forEach((r12) => {
      if (r12.distance < snapDistance && r12.distance < minY) {
        minY = r12.distance;
        gapY = r12.gap;
      }
    });
  });
  snapResults.forEach(([B4, rx, ry]) => {
    if (gapX !== Infinity) {
      rx.forEach((r12) => {
        if (Math.abs(r12.gap - gapX) < 2) {
          snaps[r12.f] = __spreadProps3(__spreadValues3({}, snaps[r12.f]), {
            isSnapped: true,
            to: B4[r12.t],
            B: B4,
            distance: r12.distance
          });
        }
      });
    }
    if (gapY !== Infinity) {
      ry.forEach((r12) => {
        if (Math.abs(r12.gap - gapY) < 2) {
          snaps[r12.f] = __spreadProps3(__spreadValues3({}, snaps[r12.f]), {
            isSnapped: true,
            to: B4[r12.t],
            B: B4,
            distance: r12.distance
          });
        }
      });
    }
  });
  offset[0] = gapX === Infinity ? 0 : gapX;
  offset[1] = gapY === Infinity ? 0 : gapY;
  A3.minX -= offset[0];
  A3.midX -= offset[0];
  A3.maxX -= offset[0];
  A3.minY -= offset[1];
  A3.midY -= offset[1];
  A3.maxY -= offset[1];
  xs.forEach((from2) => {
    const snap = snaps[from2];
    if (!snap.isSnapped)
      return;
    const { id, B: B4 } = snap;
    const x6 = A3[id];
    snapLines.push(id === "minX" ? [
      [x6, A3.midY],
      [x6, B4.minY],
      [x6, B4.maxY]
    ] : [
      [x6, A3.minY],
      [x6, A3.maxY],
      [x6, B4.minY],
      [x6, B4.maxY]
    ]);
  });
  ys.forEach((from2) => {
    const snap = snaps[from2];
    if (!snap.isSnapped)
      return;
    const { id, B: B4 } = snap;
    const y5 = A3[id];
    snapLines.push(id === "midY" ? [
      [A3.midX, y5],
      [B4.minX, y5],
      [B4.maxX, y5]
    ] : [
      [A3.minX, y5],
      [A3.maxX, y5],
      [B4.minX, y5],
      [B4.maxX, y5]
    ]);
  });
  return { offset, snapLines };
});
__publicField2(Utils, "deepMerge", (target, patch) => {
  const result = __spreadValues3({}, target);
  const entries = Object.entries(patch);
  for (const [key, value] of entries)
    result[key] = value === Object(value) && !Array.isArray(value) ? _Utils.deepMerge(result[key], value) : value;
  return result;
});
__publicField2(Utils, "TRIM_NUMBERS", /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g);
var utils_default = Utils;
function useZoomEvents(zoom, ref) {
  const rOriginPoint = React22.useRef(void 0);
  const rPinchPoint = React22.useRef(void 0);
  const rDelta = React22.useRef([0, 0]);
  const { inputs: inputs2, bounds, callbacks } = useTLContext();
  React22.useEffect(() => {
    const preventGesture = (event) => event.preventDefault();
    document.addEventListener("gesturestart", preventGesture);
    document.addEventListener("gesturechange", preventGesture);
    return () => {
      document.removeEventListener("gesturestart", preventGesture);
      document.removeEventListener("gesturechange", preventGesture);
    };
  }, []);
  const handleWheel = React22.useCallback(({ event: e11 }) => {
    var _a2, _b, _c, _d;
    e11.preventDefault();
    if (inputs2.isPinching)
      return;
    const { offset } = normalizeWheel(e11);
    if ((e11.altKey || e11.ctrlKey || e11.metaKey) && e11.buttons === 0) {
      const point = (_b = (_a2 = inputs2.pointer) == null ? void 0 : _a2.point) != null ? _b : [bounds.width / 2, bounds.height / 2];
      const delta2 = [...point, offset[1]];
      const info2 = inputs2.pan(delta2, e11);
      (_c = callbacks.onZoom) == null ? void 0 : _c.call(callbacks, __spreadProps3(__spreadValues3({}, info2), { delta: delta2 }), e11);
      return;
    }
    const delta = Vec.mul(e11.shiftKey && !utils_default.isDarwin ? [offset[1], 0] : [...offset], 0.5);
    if (Vec.isEqual(delta, [0, 0]))
      return;
    const info = inputs2.pan(delta, e11);
    (_d = callbacks.onPan) == null ? void 0 : _d.call(callbacks, info, e11);
  }, [callbacks, inputs2, bounds]);
  const handlePinchStart = React22.useCallback(({ origin, event }) => {
    var _a2;
    if (event instanceof WheelEvent)
      return;
    const elm = ref.current;
    if (!elm || !(event.target === elm || elm.contains(event.target)))
      return;
    const info = inputs2.pinch(origin, origin);
    inputs2.isPinching = true;
    (_a2 = callbacks.onPinchStart) == null ? void 0 : _a2.call(callbacks, info, event);
    rPinchPoint.current = info.point;
    rOriginPoint.current = info.origin;
    rDelta.current = [0, 0];
  }, [callbacks, inputs2, bounds]);
  const handlePinch = React22.useCallback(({ origin, offset, event }) => {
    var _a2;
    if (event instanceof WheelEvent)
      return;
    const elm = ref.current;
    if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
      return;
    if (!rOriginPoint.current)
      return;
    const info = inputs2.pinch(origin, rOriginPoint.current);
    const trueDelta = Vec.sub(info.delta, rDelta.current);
    rDelta.current = info.delta;
    (_a2 = callbacks.onPinch) == null ? void 0 : _a2.call(callbacks, __spreadProps3(__spreadValues3({}, info), {
      point: info.point,
      origin: rOriginPoint.current,
      delta: [...trueDelta, offset[0]]
    }), event);
    rPinchPoint.current = origin;
  }, [callbacks, inputs2, bounds]);
  const handlePinchEnd = React22.useCallback(({ origin, event }) => {
    var _a2;
    const elm = ref.current;
    if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
      return;
    const info = inputs2.pinch(origin, origin);
    inputs2.isPinching = false;
    (_a2 = callbacks.onPinchEnd) == null ? void 0 : _a2.call(callbacks, info, event);
    rPinchPoint.current = void 0;
    rOriginPoint.current = void 0;
    rDelta.current = [0, 0];
  }, []);
  useGesture({
    onWheel: handleWheel,
    onPinchStart: handlePinchStart,
    onPinch: handlePinch,
    onPinchEnd: handlePinchEnd
  }, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: zoom,
      scaleBounds: () => ({ from: inputs2.zoom, max: 5, min: 0.1 })
    }
  });
}
var PIXEL_STEP = 10;
var LINE_HEIGHT2 = 40;
var PAGE_HEIGHT2 = 800;
function normalizeWheel(event) {
  let sX = 0, sY = 0, pX = 0, pY = 0;
  if ("detail" in event)
    sY = event.detail;
  if ("wheelDelta" in event)
    sY = -event.wheelDelta / 120;
  if ("wheelDeltaY" in event)
    sY = -event.wheelDeltaY / 120;
  if ("wheelDeltaX" in event)
    sX = -event.wheelDeltaX / 120;
  if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = "deltaX" in event ? event.deltaX : sX * PIXEL_STEP;
  pY = "deltaY" in event ? event.deltaY : sY * PIXEL_STEP;
  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {
      pX *= LINE_HEIGHT2;
      pY *= LINE_HEIGHT2;
    } else {
      pX *= PAGE_HEIGHT2;
      pY *= PAGE_HEIGHT2;
    }
  }
  if (pX && !sX)
    sX = pX < 1 ? -1 : 1;
  if (pY && !sY)
    sY = pY < 1 ? -1 : 1;
  return { spin: [sX, sY], offset: [pX, pY] };
}
function useSafariFocusOutFix() {
  const { callbacks } = useTLContext();
  (0, import_react9.useEffect)(() => {
    function handleFocusOut() {
      var _a2;
      (_a2 = callbacks.onShapeBlur) == null ? void 0 : _a2.call(callbacks);
    }
    if (utils_default.isMobileSafari()) {
      document.addEventListener("focusout", handleFocusOut);
      return () => document.removeEventListener("focusout", handleFocusOut);
    }
    return () => null;
  }, [callbacks]);
}
function useCanvasEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  return React32.useMemo(() => {
    return {
      onPointerDown: (e11) => {
        var _a2, _b;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        if (e11.button !== 0 && e11.button !== 1)
          return;
        if (!inputs2.pointerIsValid(e11))
          return;
        e11.currentTarget.setPointerCapture(e11.pointerId);
        const info = inputs2.pointerDown(e11, "canvas");
        if (e11.button === 0 || e11.button === 1) {
          (_a2 = callbacks.onPointCanvas) == null ? void 0 : _a2.call(callbacks, info, e11);
          (_b = callbacks.onPointerDown) == null ? void 0 : _b.call(callbacks, info, e11);
        }
      },
      onPointerMove: (e11) => {
        var _a2, _b;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        const info = inputs2.pointerMove(e11, "canvas");
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = callbacks.onDragCanvas) == null ? void 0 : _a2.call(callbacks, info, e11);
        }
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e11);
      },
      onPointerUp: (e11) => {
        var _a2, _b, _c, _d;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (e11.button !== 0 && e11.button !== 1)
          return;
        inputs2.activePointer = void 0;
        if (!inputs2.pointerIsValid(e11))
          return;
        const isDoubleClick = inputs2.isDoubleClick();
        const info = inputs2.pointerUp(e11, "canvas");
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = e11.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e11.pointerId);
        }
        if (isDoubleClick && !(info.altKey || info.metaKey)) {
          (_b = callbacks.onDoubleClickCanvas) == null ? void 0 : _b.call(callbacks, info, e11);
        }
        (_c = callbacks.onReleaseCanvas) == null ? void 0 : _c.call(callbacks, info, e11);
        (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e11);
      },
      onDrop: callbacks.onDrop,
      onDragOver: callbacks.onDragOver
    };
  }, [callbacks, inputs2]);
}
function useShapeEvents(id) {
  const { rPageState, rSelectionBounds, callbacks, inputs: inputs2 } = React4.useContext(TLContext);
  return React4.useMemo(() => ({
    onPointerDown: (e11) => {
      var _a2, _b, _c, _d, _e, _f, _g;
      if (e11.dead)
        return;
      else
        e11.dead = true;
      if (!inputs2.pointerIsValid(e11))
        return;
      if (e11.button === 2) {
        (_a2 = callbacks.onRightPointShape) == null ? void 0 : _a2.call(callbacks, inputs2.pointerDown(e11, id), e11);
        return;
      }
      if (e11.button !== 0)
        return;
      const info = inputs2.pointerDown(e11, id);
      (_b = e11.currentTarget) == null ? void 0 : _b.setPointerCapture(e11.pointerId);
      if (rSelectionBounds.current && Utils.pointInBounds(info.point, rSelectionBounds.current) && !rPageState.current.selectedIds.includes(id)) {
        (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, inputs2.pointerDown(e11, "bounds"), e11);
        (_d = callbacks.onPointShape) == null ? void 0 : _d.call(callbacks, info, e11);
        (_e = callbacks.onPointerDown) == null ? void 0 : _e.call(callbacks, info, e11);
        return;
      }
      (_f = callbacks.onPointShape) == null ? void 0 : _f.call(callbacks, info, e11);
      (_g = callbacks.onPointerDown) == null ? void 0 : _g.call(callbacks, info, e11);
    },
    onPointerUp: (e11) => {
      var _a2, _b, _c, _d;
      if (e11.dead)
        return;
      else
        e11.dead = true;
      if (e11.button !== 0)
        return;
      inputs2.activePointer = void 0;
      if (!inputs2.pointerIsValid(e11))
        return;
      const isDoubleClick = inputs2.isDoubleClick();
      const info = inputs2.pointerUp(e11, id);
      if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
        (_a2 = e11.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e11.pointerId);
      }
      if (isDoubleClick && !(info.altKey || info.metaKey)) {
        (_b = callbacks.onDoubleClickShape) == null ? void 0 : _b.call(callbacks, info, e11);
      }
      (_c = callbacks.onReleaseShape) == null ? void 0 : _c.call(callbacks, info, e11);
      (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e11);
    },
    onPointerMove: (e11) => {
      var _a2, _b;
      if (e11.dead)
        return;
      else
        e11.dead = true;
      if (!inputs2.pointerIsValid(e11))
        return;
      if (inputs2.pointer && e11.pointerId !== inputs2.pointer.pointerId)
        return;
      const info = inputs2.pointerMove(e11, id);
      if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
        (_a2 = callbacks.onDragShape) == null ? void 0 : _a2.call(callbacks, info, e11);
      }
      (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e11);
    },
    onPointerEnter: (e11) => {
      var _a2;
      if (!inputs2.pointerIsValid(e11))
        return;
      const info = inputs2.pointerEnter(e11, id);
      (_a2 = callbacks.onHoverShape) == null ? void 0 : _a2.call(callbacks, info, e11);
    },
    onPointerLeave: (e11) => {
      var _a2;
      if (!inputs2.pointerIsValid(e11))
        return;
      const info = inputs2.pointerEnter(e11, id);
      (_a2 = callbacks.onUnhoverShape) == null ? void 0 : _a2.call(callbacks, info, e11);
    }
  }), [inputs2, callbacks, id]);
}
function addToShapeTree(shape, branch, shapes, pageState, assets, isChildOfGhost = false, isChildOfSelected = false, meta) {
  const node = {
    shape,
    asset: shape.assetId ? assets[shape.assetId] : void 0,
    meta,
    isChildOfSelected,
    isGhost: shape.isGhost || isChildOfGhost,
    isEditing: pageState.editingId === shape.id,
    isBinding: pageState.bindingTargetId === shape.id,
    isSelected: pageState.selectedIds.includes(shape.id),
    isHovered: pageState.hoveredId === shape.id || shape.children !== void 0 && (pageState.hoveredId && shape.children.includes(pageState.hoveredId) || shape.children.some((childId) => pageState.selectedIds.includes(childId)))
  };
  branch.push(node);
  if (shape.children) {
    node.children = [];
    shape.children.map((id) => shapes[id]).filter(Boolean).sort((a7, b7) => a7.childIndex - b7.childIndex).forEach((childShape) => addToShapeTree(childShape, node.children, shapes, pageState, assets, node.isGhost, node.isSelected || node.isChildOfSelected, meta));
  }
}
function shapeIsInViewport(bounds, viewport) {
  return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds);
}
function useShapeTree(page, pageState, assets, meta) {
  const { callbacks, shapeUtils: shapeUtils2, bounds } = useTLContext();
  const rTimeout = React5.useRef();
  const rPreviousCount = React5.useRef(-1);
  const rShapesIdsToRender = React5.useRef(/* @__PURE__ */ new Set());
  const rShapesToRender = React5.useRef(/* @__PURE__ */ new Set());
  const { selectedIds, camera } = pageState;
  const [minX, minY] = Vec.sub(Vec.div([0, 0], camera.zoom), camera.point);
  const [maxX, maxY] = Vec.sub(Vec.div([bounds.width, bounds.height], camera.zoom), camera.point);
  const viewport = {
    minX,
    minY,
    maxX,
    maxY,
    height: maxX - minX,
    width: maxY - minY
  };
  const shapesToRender = rShapesToRender.current;
  const shapesIdsToRender = rShapesIdsToRender.current;
  shapesToRender.clear();
  shapesIdsToRender.clear();
  const allShapes = Object.values(page.shapes);
  allShapes.filter((shape) => shapeUtils2[shape.type].isStateful || selectedIds.includes(shape.id) || shapeIsInViewport(shapeUtils2[shape.type].getBounds(shape), viewport)).forEach((shape) => {
    if (shape.parentId === page.id) {
      shapesIdsToRender.add(shape.id);
      shapesToRender.add(shape);
      return;
    }
    shapesIdsToRender.add(shape.parentId);
    shapesToRender.add(page.shapes[shape.parentId]);
  });
  if (shapesToRender.size !== rPreviousCount.current) {
    if (rTimeout.current) {
      clearTimeout(rTimeout.current);
    }
    rTimeout.current = requestAnimationFrame(() => {
      var _a2;
      (_a2 = callbacks.onRenderCountChange) == null ? void 0 : _a2.call(callbacks, Array.from(shapesIdsToRender.values()));
    });
    rPreviousCount.current = shapesToRender.size;
  }
  const bindingTargetId = pageState.bindingId ? page.bindings[pageState.bindingId].toId : void 0;
  const tree = [];
  shapesToRender.forEach((shape) => addToShapeTree(shape, tree, page.shapes, __spreadProps3(__spreadValues3({}, pageState), { bindingTargetId }), assets, shape.isGhost, false, meta));
  tree.sort((a7, b7) => a7.shape.childIndex - b7.shape.childIndex);
  return tree;
}
var styles = /* @__PURE__ */ new Map();
function makeCssTheme(prefix, theme) {
  return Object.keys(theme).reduce((acc, key) => {
    const value = theme[key];
    if (value) {
      return acc + `${`--${prefix}-${key}`}: ${value};
`;
    }
    return acc;
  }, "");
}
function useTheme(prefix, theme, selector = ":root") {
  React6.useLayoutEffect(() => {
    const style = document.createElement("style");
    const cssTheme = makeCssTheme(prefix, theme);
    style.setAttribute("id", `${prefix}-theme`);
    style.setAttribute("data-selector", selector);
    style.innerHTML = `
        ${selector} {
          ${cssTheme}
        }
      `;
    document.head.appendChild(style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
      }
    };
  }, [prefix, theme, selector]);
}
function useStyle(uid, rules) {
  React6.useLayoutEffect(() => {
    if (styles.get(uid)) {
      return () => void 0;
    }
    const style = document.createElement("style");
    style.innerHTML = rules;
    style.setAttribute("id", uid);
    document.head.appendChild(style);
    styles.set(uid, style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
        styles.delete(uid);
      }
    };
  }, [uid, rules]);
}
var css = (strings, ...args2) => strings.reduce((acc, string, index2) => acc + string + (index2 < args2.length ? args2[index2] : ""), "");
var defaultTheme = {
  accent: "rgb(255, 0, 0)",
  brushFill: "rgba(0,0,0,.05)",
  brushStroke: "rgba(0,0,0,.25)",
  brushDashStroke: "rgba(0,0,0,.6)",
  selectStroke: "rgb(66, 133, 244)",
  selectFill: "rgba(65, 132, 244, 0.05)",
  binding: "rgba(65, 132, 244, 0.12)",
  background: "rgb(248, 249, 250)",
  foreground: "rgb(51, 51, 51)",
  grid: "rgba(144, 144, 144, 1)"
};
var tlcss = css`
  @font-face {
    font-family: 'Recursive';
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImKsvxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  @font-face {
    font-family: 'Recursive';
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImKsvxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  @font-face {
    font-family: 'Recursive Mono';
    font-style: normal;
    font-weight: 420;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImqvTxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  .tl-container {
    --tl-zoom: 1;
    --tl-scale: calc(1 / var(--tl-zoom));
    --tl-padding: calc(64px * max(1, var(--tl-scale)));
    --tl-performance-all: auto;
    --tl-performance-selected: auto;
    position: relative;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    padding: 0px;
    margin: 0px;
    z-index: 100;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background-color: var(--tl-background);
  }

  .tl-container * {
    box-sizing: border-box;
  }

  .tl-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
  }

  .tl-grid {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
    user-select: none;
  }

  .tl-snap-line {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }

  .tl-snap-point {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }

  .tl-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: all;
    overflow: clip;
  }

  .tl-layer {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 0px;
    width: 0px;
    contain: layout style size;
  }

  .tl-absolute {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    contain: layout style size;
  }

  .tl-positioned {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    contain: layout style size;
    will-change: var(--tl-performance-all);
  }

  .tl-positioned-svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
    contain: layout style size;
  }

  .tl-positioned-div {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--tl-padding);
    overflow: hidden;
    contain: layout style size;
  }

  .tl-positioned-selected {
    will-change: var(--tl-performance-selected);
  }

  .tl-inner-div {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .tl-stroke-hitarea {
    fill: none;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: stroke;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .tl-fill-hitarea {
    fill: transparent;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: all;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .tl-counter-scaled {
    transform: scale(var(--tl-scale));
  }

  .tl-dashed {
    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
  }

  .tl-transparent {
    fill: transparent;
    stroke: transparent;
  }

  .tl-cursor-ns {
    cursor: ns-resize;
  }

  .tl-cursor-ew {
    cursor: ew-resize;
  }

  .tl-cursor-nesw {
    cursor: nesw-resize;
  }

  .tl-cursor-nwse {
    cursor: nwse-resize;
  }

  .tl-corner-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
  }

  .tl-rotate-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
    cursor: grab;
  }

  .tl-binding {
    fill: var(--tl-selectFill);
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }

  .tl-user {
    left: calc(-15px * var(--tl-scale));
    top: calc(-15px * var(--tl-scale));
    height: calc(35px * var(--tl-scale));
    width: calc(35px * var(--tl-scale));
    transform: scale(var(--tl-scale));
    pointer-events: none;
    will-change: transform;
  }

  .tl-indicator {
    fill: transparent;
    stroke-width: calc(1.5px * var(--tl-scale));
    pointer-events: none;
  }

  .tl-user-indicator-bounds {
    border-style: solid;
    border-width: calc(1px * var(--tl-scale));
  }

  .tl-hovered {
    stroke: var(--tl-selectStroke);
  }

  .tl-selected {
    stroke: var(--tl-selectStroke);
  }

  .tl-editing {
    stroke-width: calc(2.5px * min(5, var(--tl-scale)));
  }

  .tl-performance {
    will-change: transform, contents;
  }

  .tl-clone-target {
    pointer-events: all;
  }

  .tl-clone-target:hover .tl-clone-button {
    opacity: 1;
  }

  .tl-clone-button-target {
    cursor: pointer;
    pointer-events: all;
  }

  .tl-clone-button-target:hover .tl-clone-button {
    fill: var(--tl-selectStroke);
  }

  .tl-clone-button {
    opacity: 0;
    r: calc(8px * var(--tl-scale));
    stroke-width: calc(1.5px * var(--tl-scale));
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
  }

  .tl-bounds {
    pointer-events: none;
    contain: layout style size;
  }

  .tl-bounds-bg {
    stroke: none;
    fill: var(--tl-selectFill);
    pointer-events: all;
    contain: layout style size;
  }

  .tl-bounds-center {
    fill: transparent;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1.5px * var(--tl-scale));
  }

  .tl-brush {
    fill: var(--tl-brushFill);
    stroke: var(--tl-brushStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
    contain: layout style size;
  }

  .tl-dashed-brush-line {
    fill: none;
    stroke: var(--tl-brushDashStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }

  .tl-brush.dashed {
    stroke: none;
  }

  .tl-dot {
    fill: var(--tl-background);
    stroke: var(--tl-foreground);
    stroke-width: 2px;
  }

  .tl-handle {
    pointer-events: all;
    cursor: grab;
  }

  .tl-handle:hover .tl-handle-bg {
    fill: var(--tl-selectFill);
  }

  .tl-handle:hover .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }

  .tl-handle:active .tl-handle-bg {
    cursor: grabbing;
    fill: var(--tl-selectFill);
  }

  .tl-handle:active .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }

  .tl-handle {
    fill: var(--tl-background);
    stroke: var(--tl-selectStroke);
    stroke-width: 1.5px;
  }

  .tl-handle-bg {
    fill: transparent;
    stroke: none;
    pointer-events: all;
    r: calc(16px / max(1, var(--tl-zoom)));
  }

  .tl-binding-indicator {
    fill: transparent;
    stroke: var(--tl-binding);
  }

  .tl-centered-g {
    transform: translate(var(--tl-padding), var(--tl-padding));
  }

  .tl-current-parent > *[data-shy='true'] {
    opacity: 1;
  }

  .tl-binding {
    fill: none;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(2px * var(--tl-scale));
  }

  .tl-grid-dot {
    fill: var(--tl-grid);
  }
`;
function useTLTheme(theme, selector) {
  const tltheme = React6.useMemo(() => __spreadValues3(__spreadValues3({}, defaultTheme), theme), [theme]);
  useTheme("tl", tltheme, selector);
  useStyle("tl-canvas", tlcss);
}
function useBoundsHandleEvents(id) {
  const { callbacks, inputs: inputs2 } = useTLContext();
  const onPointerDown = React7.useCallback((e11) => {
    var _a2, _b, _c;
    if (e11.dead)
      return;
    else
      e11.dead = true;
    if (e11.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e11))
      return;
    const info = inputs2.pointerDown(e11, id);
    if (inputs2.isDoubleClick() && !(info.altKey || info.metaKey)) {
      (_a2 = callbacks.onDoubleClickBoundsHandle) == null ? void 0 : _a2.call(callbacks, info, e11);
    }
    (_b = callbacks.onPointBoundsHandle) == null ? void 0 : _b.call(callbacks, info, e11);
    (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e11);
  }, [inputs2, callbacks, id]);
  const onPointerUp = React7.useCallback((e11) => {
    var _a2, _b;
    if (e11.dead)
      return;
    else
      e11.dead = true;
    if (e11.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e11))
      return;
    const info = inputs2.pointerUp(e11, id);
    (_a2 = callbacks.onReleaseBoundsHandle) == null ? void 0 : _a2.call(callbacks, info, e11);
    (_b = callbacks.onPointerUp) == null ? void 0 : _b.call(callbacks, info, e11);
  }, [inputs2, callbacks, id]);
  const onPointerMove = React7.useCallback((e11) => {
    var _a2, _b;
    if (e11.dead)
      return;
    else
      e11.dead = true;
    if (!inputs2.pointerIsValid(e11))
      return;
    if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
      (_a2 = callbacks.onDragBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerMove(e11, id), e11);
    }
    const info = inputs2.pointerMove(e11, id);
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e11);
  }, [inputs2, callbacks, id]);
  const onPointerEnter = React7.useCallback((e11) => {
    var _a2;
    if (!inputs2.pointerIsValid(e11))
      return;
    (_a2 = callbacks.onHoverBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e11, id), e11);
  }, [inputs2, callbacks, id]);
  const onPointerLeave = React7.useCallback((e11) => {
    var _a2;
    if (!inputs2.pointerIsValid(e11))
      return;
    (_a2 = callbacks.onUnhoverBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e11, id), e11);
  }, [inputs2, callbacks, id]);
  return {
    onPointerDown,
    onPointerUp,
    onPointerEnter,
    onPointerMove,
    onPointerLeave
  };
}
function useCameraCss(layerRef, containerRef, pageState) {
  const rZoom = React8.useRef();
  const rPoint = React8.useRef();
  React8.useLayoutEffect(() => {
    return autorun(() => {
      const { zoom, point } = pageState.camera;
      const didZoom = zoom !== rZoom.current;
      const didPan = point !== rPoint.current;
      rZoom.current = zoom;
      rPoint.current = point;
      if (didZoom || didPan) {
        const layer = layerRef.current;
        if (containerRef && "current" in containerRef) {
          const container = containerRef.current;
          if (didZoom) {
            if (container) {
              container.style.setProperty("--tl-zoom", zoom.toString());
            }
          }
          if (layer) {
            layer.style.setProperty("transform", `scale(${zoom}) translateX(${point[0]}px) translateY(${point[1]}px)`);
          }
        }
      }
    });
  }, [pageState]);
}
function canvasToScreen(point, camera) {
  return [(point[0] + camera.point[0]) * camera.zoom, (point[1] + camera.point[1]) * camera.zoom];
}
function getShapeUtils(shapeUtils2, shape) {
  return shapeUtils2[shape.type];
}
function useSelection(page, pageState, shapeUtils2) {
  const { rSelectionBounds } = useTLContext();
  const { selectedIds } = pageState;
  const rPrevBounds = React9.useRef();
  let bounds = void 0;
  let rotation = 0;
  let isLocked = false;
  let isLinked = false;
  if (selectedIds.length === 1) {
    const id = selectedIds[0];
    const shape = page.shapes[id];
    rotation = shape.rotation || 0;
    isLocked = shape.isLocked || false;
    const utils = getShapeUtils(shapeUtils2, shape);
    bounds = utils.hideBounds ? void 0 : utils.getBounds(shape);
  } else if (selectedIds.length > 1) {
    const selectedShapes = selectedIds.map((id) => page.shapes[id]);
    rotation = 0;
    isLocked = selectedShapes.every((shape) => shape.isLocked);
    bounds = selectedShapes.reduce((acc, shape, i8) => {
      if (i8 === 0) {
        return getShapeUtils(shapeUtils2, shape).getRotatedBounds(shape);
      }
      return utils_default.getExpandedBounds(acc, getShapeUtils(shapeUtils2, shape).getRotatedBounds(shape));
    }, {});
  }
  if (bounds) {
    const [minX, minY] = canvasToScreen([bounds.minX, bounds.minY], pageState.camera);
    const [maxX, maxY] = canvasToScreen([bounds.maxX, bounds.maxY], pageState.camera);
    isLinked = !!Object.values(page.bindings).find((binding) => selectedIds.includes(binding.toId) || selectedIds.includes(binding.fromId));
    rSelectionBounds.current = {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  } else {
    rSelectionBounds.current = null;
  }
  const prevBounds = rPrevBounds.current;
  if (!prevBounds || !bounds) {
    rPrevBounds.current = bounds;
  } else if (bounds) {
    if (prevBounds.minX === bounds.minX && prevBounds.minY === bounds.minY && prevBounds.maxX === bounds.maxX && prevBounds.maxY === bounds.maxY) {
      bounds = rPrevBounds.current;
    }
  }
  return { bounds, rotation, isLocked, isLinked };
}
function useHandleEvents(id) {
  const { inputs: inputs2, callbacks } = useTLContext();
  return React10.useMemo(() => {
    return {
      onPointerDown: (e11) => {
        var _a2, _b, _c;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        if (e11.button !== 0)
          return;
        if (!inputs2.pointerIsValid(e11))
          return;
        (_a2 = e11.currentTarget) == null ? void 0 : _a2.setPointerCapture(e11.pointerId);
        const info = inputs2.pointerDown(e11, id);
        (_b = callbacks.onPointHandle) == null ? void 0 : _b.call(callbacks, info, e11);
        (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e11);
      },
      onPointerUp: (e11) => {
        var _a2, _b, _c, _d;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (e11.button !== 0)
          return;
        if (!inputs2.pointerIsValid(e11))
          return;
        const isDoubleClick = inputs2.isDoubleClick();
        const info = inputs2.pointerUp(e11, id);
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = e11.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e11.pointerId);
          if (isDoubleClick && !(info.altKey || info.metaKey)) {
            (_b = callbacks.onDoubleClickHandle) == null ? void 0 : _b.call(callbacks, info, e11);
          }
          (_c = callbacks.onReleaseHandle) == null ? void 0 : _c.call(callbacks, info, e11);
        }
        (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e11);
      },
      onPointerMove: (e11) => {
        var _a2, _b;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        const info = inputs2.pointerMove(e11, id);
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = callbacks.onDragHandle) == null ? void 0 : _a2.call(callbacks, info, e11);
        }
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e11);
      },
      onPointerEnter: (e11) => {
        var _a2;
        if (!inputs2.pointerIsValid(e11))
          return;
        const info = inputs2.pointerEnter(e11, id);
        (_a2 = callbacks.onHoverHandle) == null ? void 0 : _a2.call(callbacks, info, e11);
      },
      onPointerLeave: (e11) => {
        var _a2;
        if (!inputs2.pointerIsValid(e11))
          return;
        const info = inputs2.pointerEnter(e11, id);
        (_a2 = callbacks.onUnhoverHandle) == null ? void 0 : _a2.call(callbacks, info, e11);
      }
    };
  }, [inputs2, callbacks, id]);
}
function usePreventNavigationCss(rCanvas) {
  const { bounds } = useTLContext();
  React11.useEffect(() => {
    const preventGestureNavigation = (event) => {
      event.preventDefault();
    };
    const preventNavigation = (event) => {
      const touchXPosition = event.touches[0].pageX;
      const touchXRadius = event.touches[0].radiusX || 0;
      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > bounds.width - 10) {
        event.preventDefault();
      }
    };
    const elm = rCanvas.current;
    if (!elm)
      return () => void 0;
    elm.addEventListener("touchstart", preventGestureNavigation);
    elm.addEventListener("gestureend", preventGestureNavigation);
    elm.addEventListener("gesturechange", preventGestureNavigation);
    elm.addEventListener("gesturestart", preventGestureNavigation);
    elm.addEventListener("touchstart", preventNavigation);
    return () => {
      if (elm) {
        elm.removeEventListener("touchstart", preventGestureNavigation);
        elm.removeEventListener("gestureend", preventGestureNavigation);
        elm.removeEventListener("gesturechange", preventGestureNavigation);
        elm.removeEventListener("gesturestart", preventGestureNavigation);
        elm.removeEventListener("touchstart", preventNavigation);
      }
    };
  }, [rCanvas, bounds.width]);
}
function useBoundsEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  return React12.useMemo(() => {
    return {
      onPointerDown: (e11) => {
        var _a2, _b, _c, _d;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        if (e11.button === 2) {
          (_a2 = callbacks.onRightPointBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerDown(e11, "bounds"), e11);
          return;
        }
        if (e11.button !== 0)
          return;
        (_b = e11.currentTarget) == null ? void 0 : _b.setPointerCapture(e11.pointerId);
        const info = inputs2.pointerDown(e11, "bounds");
        (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, info, e11);
        (_d = callbacks.onPointerDown) == null ? void 0 : _d.call(callbacks, info, e11);
      },
      onPointerUp: (e11) => {
        var _a2, _b, _c, _d;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (e11.button !== 0)
          return;
        inputs2.activePointer = void 0;
        if (!inputs2.pointerIsValid(e11))
          return;
        const isDoubleClick = inputs2.isDoubleClick();
        const info = inputs2.pointerUp(e11, "bounds");
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = e11.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e11.pointerId);
        }
        if (isDoubleClick && !(info.altKey || info.metaKey)) {
          (_b = callbacks.onDoubleClickBounds) == null ? void 0 : _b.call(callbacks, info, e11);
        }
        (_c = callbacks.onReleaseBounds) == null ? void 0 : _c.call(callbacks, info, e11);
        (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e11);
      },
      onPointerMove: (e11) => {
        var _a2, _b;
        if (e11.dead)
          return;
        else
          e11.dead = true;
        if (!inputs2.pointerIsValid(e11))
          return;
        if (e11.currentTarget.hasPointerCapture(e11.pointerId)) {
          (_a2 = callbacks.onDragBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerMove(e11, "bounds"), e11);
        }
        const info = inputs2.pointerMove(e11, "bounds");
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e11);
      },
      onPointerEnter: (e11) => {
        var _a2;
        if (!inputs2.pointerIsValid(e11))
          return;
        (_a2 = callbacks.onHoverBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e11, "bounds"), e11);
      },
      onPointerLeave: (e11) => {
        var _a2;
        if (!inputs2.pointerIsValid(e11))
          return;
        (_a2 = callbacks.onUnhoverBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e11, "bounds"), e11);
      }
    };
  }, [inputs2, callbacks]);
}
function usePosition(bounds, rotation = 0) {
  const rBounds = React13.useRef(null);
  React13.useLayoutEffect(() => {
    return autorun(() => {
      const elm = rBounds.current;
      const transform = `
    translate(
      calc(${bounds.minX}px - var(--tl-padding)),
      calc(${bounds.minY}px - var(--tl-padding))
    )
    rotate(${rotation + (bounds.rotation || 0)}rad)`;
      elm.style.setProperty("transform", transform);
      elm.style.setProperty("width", `calc(${Math.floor(bounds.width)}px + (var(--tl-padding) * 2))`);
      elm.style.setProperty("height", `calc(${Math.floor(bounds.height)}px + (var(--tl-padding) * 2))`);
    });
  }, [bounds, rotation]);
  return rBounds;
}
function useKeyEvents() {
  const { inputs: inputs2, callbacks } = useTLContext();
  React14.useEffect(() => {
    const handleKeyDown = (e11) => {
      var _a2;
      (_a2 = callbacks.onKeyDown) == null ? void 0 : _a2.call(callbacks, e11.key, inputs2.keydown(e11), e11);
    };
    const handleKeyUp = (e11) => {
      var _a2;
      inputs2.keyup(e11);
      (_a2 = callbacks.onKeyUp) == null ? void 0 : _a2.call(callbacks, e11.key, inputs2.keyup(e11), e11);
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [inputs2, callbacks]);
}
function useCursorAnimation(ref, point) {
  const rState = React15.useRef("idle");
  const rPrevPoint = React15.useRef(point);
  const rQueue = React15.useRef([]);
  const rTimestamp = React15.useRef(performance.now());
  const rLastRequestId = React15.useRef(0);
  const rTimeoutId = React15.useRef(0);
  const [spline] = React15.useState(() => new Spline());
  const animateNext = React15.useCallback((animation) => {
    const start = performance.now();
    function loop() {
      const t12 = (performance.now() - start) / animation.duration;
      if (t12 <= 1) {
        const elm = ref.current;
        if (!elm)
          return;
        const point2 = animation.curve ? spline.getSplinePoint(t12 + animation.start) : src_default.lrp(animation.from, animation.to, t12);
        elm.style.setProperty("transform", `translate(${point2[0]}px, ${point2[1]}px)`);
        rLastRequestId.current = requestAnimationFrame(loop);
        return;
      }
      const next = rQueue.current.shift();
      if (next) {
        rState.current = "animating";
        animateNext(next);
      } else {
        rState.current = "idle";
        rTimeoutId.current = setTimeout(() => {
          rState.current = "stopped";
        }, 250);
      }
    }
    loop();
  }, [spline]);
  React15.useLayoutEffect(() => {
    const now = performance.now();
    if (rState.current === "stopped") {
      rTimestamp.current = now;
      rPrevPoint.current = point;
      spline.clear();
    }
    spline.addPoint(point);
    const animation = {
      distance: spline.totalLength,
      curve: spline.points.length > 3,
      start: spline.points.length - 3,
      from: rPrevPoint.current,
      to: point,
      timeStamp: now,
      duration: Math.min(now - rTimestamp.current, 300)
    };
    rPrevPoint.current = point;
    rTimestamp.current = now;
    switch (rState.current) {
      case "stopped": {
        rPrevPoint.current = point;
        rState.current = "idle";
        break;
      }
      case "idle": {
        rState.current = "animating";
        animateNext(animation);
        break;
      }
      case "animating": {
        rQueue.current.push(animation);
        break;
      }
    }
    return () => clearTimeout(rTimeoutId.current);
  }, [point, spline]);
}
var Spline = class {
  constructor() {
    __publicField2(this, "points", []);
    __publicField2(this, "lengths", []);
    __publicField2(this, "totalLength", 0);
    __publicField2(this, "prev");
  }
  addPoint(point) {
    if (this.prev) {
      const length3 = src_default.dist(this.prev, point);
      this.lengths.push(length3);
      this.totalLength += length3;
      this.points.push(point);
    }
    this.prev = point;
  }
  getSplinePoint(t12) {
    const { points } = this;
    const l9 = points.length - 1;
    const d7 = Math.trunc(t12);
    const p1 = Math.min(d7 + 1, l9);
    const p22 = Math.min(p1 + 1, l9);
    const p32 = Math.min(p22 + 1, l9);
    const p0 = p1 - 1;
    t12 = t12 - d7;
    const tt = t12 * t12, ttt = tt * t12, q1 = -ttt + 2 * tt - t12, q22 = 3 * ttt - 5 * tt + 2, q3 = -3 * ttt + 4 * tt + t12, q4 = ttt - tt;
    return [
      0.5 * (points[p0][0] * q1 + points[p1][0] * q22 + points[p22][0] * q3 + points[p32][0] * q4),
      0.5 * (points[p0][1] * q1 + points[p1][1] * q22 + points[p22][1] * q3 + points[p32][1] * q4)
    ];
  }
  clear() {
    this.points = [];
    this.totalLength = 0;
  }
};
function usePerformanceCss(performanceMode, rContainer) {
  React16.useLayoutEffect(() => {
    if (rContainer && "current" in rContainer) {
      const container = rContainer == null ? void 0 : rContainer.current;
      if (!container)
        return;
      switch (performanceMode) {
        case "transform_selected": {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "transform_all": {
          container.style.setProperty("--tl-performance-all", "transform, contents");
          container.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "translate_selected": {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        case "translate_all": {
          container.style.setProperty("--tl-performance-all", "transform");
          container.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        default: {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "auto");
        }
      }
    }
  }, [performanceMode]);
}
var Container = observer(function Container2(_a2) {
  var _b = _a2, {
    id,
    bounds,
    rotation = 0,
    isGhost = false,
    isSelected = false,
    children
  } = _b, props = __objRest2(_b, [
    "id",
    "bounds",
    "rotation",
    "isGhost",
    "isSelected",
    "children"
  ]);
  const rPositioned = usePosition(bounds, rotation);
  return /* @__PURE__ */ React17.createElement("div", __spreadValues3({
    id,
    ref: rPositioned,
    className: `tl-positioned${isGhost ? " tl-ghost" : ""}${isSelected ? ` tl-positioned-selected` : ""}`,
    "aria-label": "container",
    "data-testid": "container"
  }, props), children);
});
var Brush = observer(function Brush2({ brush, zoom, dashed }) {
  return /* @__PURE__ */ React18.createElement(Container, {
    bounds: brush,
    rotation: 0
  }, /* @__PURE__ */ React18.createElement(SVGContainer, null, /* @__PURE__ */ React18.createElement("rect", {
    className: "tl-brush" + (dashed ? " dashed" : ""),
    opacity: 1,
    x: 0,
    y: 0,
    width: brush.width,
    height: brush.height,
    "aria-label": "brush"
  }), dashed && /* @__PURE__ */ React18.createElement("g", {
    className: "tl-dashed-brush-line"
  }, /* @__PURE__ */ React18.createElement(PerfectDashLine, {
    x1: 0,
    y1: 0,
    x2: brush.width,
    y2: 0,
    zoom
  }), /* @__PURE__ */ React18.createElement(PerfectDashLine, {
    x1: brush.width,
    y1: 0,
    x2: brush.width,
    y2: brush.height,
    zoom
  }), /* @__PURE__ */ React18.createElement(PerfectDashLine, {
    x1: 0,
    y1: brush.height,
    x2: brush.width,
    y2: brush.height,
    zoom
  }), /* @__PURE__ */ React18.createElement(PerfectDashLine, {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: brush.height,
    zoom
  }))));
});
function PerfectDashLine({ x1, y1, x2: x22, y2: y22, zoom }) {
  const dash = utils_default.getPerfectDashProps(Math.hypot(x22 - x1, y22 - y1), 1 / zoom, "dashed", 1, true, 3);
  return /* @__PURE__ */ React18.createElement("line", {
    x1,
    y1,
    x2: x22,
    y2: y22,
    strokeWidth: 1 / zoom,
    strokeDasharray: dash.strokeDasharray,
    strokeDashoffset: dash.strokeDashoffset
  });
}
var CenterHandle = observer(function CenterHandle2({
  bounds,
  isLocked,
  isHidden
}) {
  return /* @__PURE__ */ React19.createElement("rect", {
    className: ["tl-bounds-center", isLocked ? "tl-dashed" : ""].join(" "),
    x: -1,
    y: -1,
    width: bounds.width + 2,
    height: bounds.height + 2,
    opacity: isHidden ? 0 : 1,
    pointerEvents: "none",
    "aria-label": "center handle"
  });
});
var RotateHandle = observer(function RotateHandle2({
  bounds,
  targetSize,
  size,
  isHidden
}) {
  const events = useBoundsHandleEvents("rotate");
  return /* @__PURE__ */ React20.createElement("g", {
    cursor: "grab",
    opacity: isHidden ? 0 : 1
  }, /* @__PURE__ */ React20.createElement("circle", __spreadValues3({
    className: "tl-transparent",
    "aria-label": "rotate handle transparent",
    cx: bounds.width / 2,
    cy: size * -2,
    r: targetSize,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), /* @__PURE__ */ React20.createElement("circle", {
    className: "tl-rotate-handle",
    "aria-label": "rotate handle",
    cx: bounds.width / 2,
    cy: size * -2,
    r: size / 2,
    pointerEvents: "none"
  }));
});
var cornerBgClassnames = {
  ["top_left_corner"]: "tl-cursor-nwse",
  ["top_right_corner"]: "tl-cursor-nesw",
  ["bottom_right_corner"]: "tl-cursor-nwse",
  ["bottom_left_corner"]: "tl-cursor-nesw"
};
var CornerHandle = observer(function CornerHandle2({
  size,
  targetSize,
  isHidden,
  corner,
  bounds
}) {
  const events = useBoundsHandleEvents(corner);
  const isTop = corner === "top_left_corner" || corner === "top_right_corner";
  const isLeft = corner === "top_left_corner" || corner === "bottom_left_corner";
  return /* @__PURE__ */ React21.createElement("g", {
    opacity: isHidden ? 0 : 1
  }, /* @__PURE__ */ React21.createElement("rect", __spreadValues3({
    className: "tl-transparent " + (isHidden ? "" : cornerBgClassnames[corner]),
    "aria-label": "corner transparent",
    x: (isLeft ? -1 : bounds.width + 1) - targetSize,
    y: (isTop ? -1 : bounds.height + 1) - targetSize,
    width: targetSize * 2,
    height: targetSize * 2,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), /* @__PURE__ */ React21.createElement("rect", {
    className: "tl-corner-handle",
    "aria-label": "corner handle",
    x: (isLeft ? -1 : bounds.width + 1) - size / 2,
    y: (isTop ? -1 : bounds.height + 1) - size / 2,
    width: size,
    height: size,
    pointerEvents: "none"
  }));
});
function LinkHandle({ size, bounds, isHidden }) {
  const leftEvents = useBoundsHandleEvents("left");
  const centerEvents = useBoundsHandleEvents("center");
  const rightEvents = useBoundsHandleEvents("right");
  return /* @__PURE__ */ React222.createElement("g", {
    cursor: "grab",
    transform: `translate(${bounds.width / 2 - size * 4}, ${bounds.height + size * 2})`,
    "aria-label": "link handle"
  }, /* @__PURE__ */ React222.createElement("g", {
    className: "tl-transparent",
    pointerEvents: isHidden ? "none" : "all"
  }, /* @__PURE__ */ React222.createElement("rect", __spreadValues3({
    x: 0,
    y: 0,
    width: size * 2,
    height: size * 2
  }, leftEvents)), /* @__PURE__ */ React222.createElement("rect", __spreadValues3({
    x: size * 3,
    y: 0,
    width: size * 2,
    height: size * 2
  }, centerEvents)), /* @__PURE__ */ React222.createElement("rect", __spreadValues3({
    x: size * 6,
    y: 0,
    width: size * 2,
    height: size * 2
  }, rightEvents))), /* @__PURE__ */ React222.createElement("g", {
    className: "tl-rotate-handle",
    transform: `translate(${size / 2}, ${size / 2})`,
    "aria-label": "link rotate handle"
  }, /* @__PURE__ */ React222.createElement("path", {
    d: `M 0,${size / 2} L ${size},${size} ${size},0 Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), /* @__PURE__ */ React222.createElement("path", {
    transform: `translate(${size * 3}, 0)`,
    d: `M 0,0 L ${size},0 ${size / 2},${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), /* @__PURE__ */ React222.createElement("path", {
    transform: `translate(${size * 6}, 0)`,
    d: `M ${size},${size / 2} L 0,0 0,${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  })));
}
var edgeClassnames = {
  ["top_edge"]: "tl-cursor-ns",
  ["right_edge"]: "tl-cursor-ew",
  ["bottom_edge"]: "tl-cursor-ns",
  ["left_edge"]: "tl-cursor-ew"
};
var EdgeHandle = observer(function EdgeHandle2({
  size,
  isHidden,
  bounds,
  edge
}) {
  const events = useBoundsHandleEvents(edge);
  const isHorizontal = edge === "top_edge" || edge === "bottom_edge";
  const isFarEdge = edge === "right_edge" || edge === "bottom_edge";
  const { height, width } = bounds;
  return /* @__PURE__ */ React23.createElement("rect", __spreadValues3({
    pointerEvents: isHidden ? "none" : "all",
    className: "tl-transparent tl-edge-handle " + (isHidden ? "" : edgeClassnames[edge]),
    "aria-label": `${edge} handle`,
    opacity: isHidden ? 0 : 1,
    x: isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2,
    y: isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2,
    width: isHorizontal ? Math.max(0, width + 1 - size) : size,
    height: isHorizontal ? size : Math.max(0, height + 1 - size)
  }, events));
});
var ROTATIONS = {
  right: 0,
  bottomRight: 45,
  bottom: 90,
  bottomLeft: 135,
  left: 180,
  topLeft: 225,
  top: 270,
  topRight: 315
};
var CloneButton = observer(function CloneButton2({
  bounds,
  side,
  targetSize,
  size
}) {
  const s9 = targetSize * 2;
  const x6 = {
    left: -s9,
    topLeft: -s9,
    bottomLeft: -s9,
    right: bounds.width,
    topRight: bounds.width,
    bottomRight: bounds.width,
    top: bounds.width / 2 - s9 / 2,
    bottom: bounds.width / 2 - s9 / 2
  }[side];
  const y5 = {
    left: bounds.height / 2 - s9 / 2,
    right: bounds.height / 2 - s9 / 2,
    top: -s9 * 2,
    topLeft: -s9,
    topRight: -s9,
    bottom: bounds.height,
    bottomLeft: bounds.height,
    bottomRight: bounds.height
  }[side];
  const { callbacks, inputs: inputs2 } = useTLContext();
  const handleClick = React24.useCallback((e11) => {
    var _a2;
    e11.stopPropagation();
    const info = inputs2.pointerDown(e11, side);
    (_a2 = callbacks.onShapeClone) == null ? void 0 : _a2.call(callbacks, info, e11);
  }, [callbacks.onShapeClone]);
  return /* @__PURE__ */ React24.createElement("g", {
    className: "tl-clone-target",
    transform: `translate(${x6}, ${y5})`,
    "aria-label": "clone button"
  }, /* @__PURE__ */ React24.createElement("rect", {
    className: "tl-transparent",
    width: targetSize * 2,
    height: targetSize * 2
  }), /* @__PURE__ */ React24.createElement("g", {
    className: "tl-clone-button-target",
    onPointerDown: handleClick,
    transform: `translate(${targetSize}, ${targetSize}) rotate(${ROTATIONS[side]})`
  }, /* @__PURE__ */ React24.createElement("circle", {
    className: "tl-transparent ",
    r: targetSize
  }), /* @__PURE__ */ React24.createElement("path", {
    className: "tl-clone-button",
    d: `M -${size / 2},-${size / 2} L ${size / 2},0 -${size / 2},${size / 2} Z`,
    strokeLinejoin: "round"
  })));
});
function CloneButtons({ targetSize, size, bounds }) {
  return /* @__PURE__ */ React25.createElement(React25.Fragment, null, /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "top"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "right"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottom"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "left"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topLeft"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topRight"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomLeft"
  }), /* @__PURE__ */ React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomRight"
  }));
}
var SVGContainer = React26.forwardRef(function SVGContainer2(_a2, ref) {
  var _b = _a2, { id, className = "", children } = _b, rest = __objRest2(_b, ["id", "className", "children"]);
  return /* @__PURE__ */ React26.createElement(ObserverComponent, null, () => /* @__PURE__ */ React26.createElement("svg", __spreadValues3({
    ref,
    className: `tl-positioned-svg ${className}`
  }, rest), /* @__PURE__ */ React26.createElement("g", {
    id,
    className: "tl-centered-g"
  }, children)));
});
var Bounds = observer(function Bounds2({
  zoom,
  bounds,
  viewportWidth,
  rotation,
  isHidden,
  isLocked,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideBindingHandles
}) {
  const targetSize = (viewportWidth < 768 ? 16 : 8) / zoom;
  const size = 8 / zoom;
  const smallDimension = Math.min(bounds.width, bounds.height) * zoom;
  const showRotateHandle = !hideRotateHandle && !isHidden && !isLocked && smallDimension > 32;
  const showEdgeHandles = !isHidden && !isLocked && smallDimension > 24;
  const showCornerHandles = !isHidden && !isLocked && smallDimension > 20;
  const showCloneHandles = !hideCloneHandles && smallDimension > 24;
  const showResizeHandles = !hideResizeHandles && !isLocked;
  return /* @__PURE__ */ React27.createElement(Container, {
    bounds,
    rotation
  }, /* @__PURE__ */ React27.createElement(SVGContainer, null, /* @__PURE__ */ React27.createElement(CenterHandle, {
    bounds,
    isLocked,
    isHidden
  }), showResizeHandles && /* @__PURE__ */ React27.createElement(React27.Fragment, null, /* @__PURE__ */ React27.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "top_edge",
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ React27.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "right_edge",
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ React27.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "bottom_edge",
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ React27.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "left_edge",
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ React27.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "top_left_corner"
  }), /* @__PURE__ */ React27.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "top_right_corner"
  }), /* @__PURE__ */ React27.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "bottom_right_corner"
  }), /* @__PURE__ */ React27.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "bottom_left_corner"
  })), showRotateHandle && /* @__PURE__ */ React27.createElement(RotateHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  }), showCloneHandles && /* @__PURE__ */ React27.createElement(CloneButtons, {
    bounds,
    targetSize,
    size
  }), !hideBindingHandles && /* @__PURE__ */ React27.createElement(LinkHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  })));
});
var BoundsBg = observer(function BoundsBg2({
  bounds,
  rotation,
  isHidden
}) {
  const events = useBoundsEvents();
  return /* @__PURE__ */ React28.createElement(Container, {
    bounds,
    rotation
  }, /* @__PURE__ */ React28.createElement(SVGContainer, null, /* @__PURE__ */ React28.createElement("rect", __spreadValues3({
    className: "tl-bounds-bg",
    "aria-label": "bounds bg",
    width: bounds.width,
    height: bounds.height,
    opacity: isHidden ? 0 : 1
  }, events))));
});
var Handle = observer(function Handle2({ id, point }) {
  const events = useHandleEvents(id);
  return /* @__PURE__ */ React29.createElement(Container, {
    bounds: utils_default.translateBounds({
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    }, point)
  }, /* @__PURE__ */ React29.createElement(SVGContainer, null, /* @__PURE__ */ React29.createElement("g", __spreadValues3({
    className: "tl-handle",
    "aria-label": "handle"
  }, events), /* @__PURE__ */ React29.createElement("circle", {
    className: "tl-handle-bg",
    pointerEvents: "all"
  }), /* @__PURE__ */ React29.createElement("circle", {
    className: "tl-counter-scaled tl-handle",
    pointerEvents: "none",
    r: 4
  }))));
});
var Handles = observer(function Handles2({
  shape,
  zoom
}) {
  if (shape.handles === void 0) {
    return null;
  }
  let prev = null;
  const handlesToShow = Object.values(shape.handles).reduce((acc, cur) => {
    const point = Vec.add(cur.point, shape.point);
    if (!prev || Vec.dist(point, prev) * zoom >= 32) {
      acc.push(cur);
      prev = point;
    }
    return acc;
  }, []);
  if (handlesToShow.length === 1)
    return null;
  return /* @__PURE__ */ React30.createElement(React30.Fragment, null, handlesToShow.map((handle) => /* @__PURE__ */ React30.createElement(Handle, {
    key: shape.id + "_" + handle.id,
    id: handle.id,
    point: Vec.add(handle.point, shape.point)
  })));
});
var _RenderedShape = observer(function RenderedShape(props) {
  const ref = props.utils.getRef(props.shape);
  return /* @__PURE__ */ React31.createElement(props.utils.Component, __spreadValues3({
    ref
  }, props));
});
var RenderedShape2 = React31.memo(_RenderedShape, (prev, next) => {
  if (prev.isHovered !== next.isHovered || prev.isSelected !== next.isSelected || prev.isEditing !== next.isEditing || prev.isBinding !== next.isBinding || prev.isGhost !== next.isGhost || prev.meta !== next.meta) {
    return false;
  }
  if (next.shape !== prev.shape) {
    return !next.utils.shouldRender(next.shape, prev.shape);
  }
  return true;
});
var Shape = observer(function Shape2(_a2) {
  var _b = _a2, {
    shape,
    utils,
    meta
  } = _b, rest = __objRest2(_b, [
    "shape",
    "utils",
    "meta"
  ]);
  const { callbacks } = useTLContext();
  const bounds = utils.getBounds(shape);
  const events = useShapeEvents(shape.id);
  return /* @__PURE__ */ React322.createElement(Container, {
    id: shape.id,
    bounds,
    rotation: shape.rotation,
    "data-shape": shape.type,
    isGhost: rest.isGhost,
    isSelected: rest.isSelected
  }, /* @__PURE__ */ React322.createElement(RenderedShape2, __spreadValues3({
    shape,
    utils,
    meta,
    events,
    bounds,
    onShapeChange: callbacks.onShapeChange,
    onShapeBlur: callbacks.onShapeBlur
  }, rest)));
});
var ShapeNode = observer(function ShapeNode2(_a2) {
  var _b = _a2, {
    shape,
    utils,
    meta,
    children
  } = _b, rest = __objRest2(_b, [
    "shape",
    "utils",
    "meta",
    "children"
  ]);
  return /* @__PURE__ */ React33.createElement(React33.Fragment, null, /* @__PURE__ */ React33.createElement(Shape, __spreadValues3({
    shape,
    utils: utils[shape.type],
    meta
  }, rest)), children && children.map((childNode) => /* @__PURE__ */ React33.createElement(ShapeNode2, __spreadValues3({
    key: childNode.shape.id,
    utils
  }, childNode))));
});
var ShapeIndicator = observer(function ShapeIndicator2({
  isHovered = false,
  isSelected = false,
  isEditing = false,
  shape,
  user,
  meta
}) {
  const { shapeUtils: shapeUtils2 } = useTLContext();
  const utils = shapeUtils2[shape.type];
  const bounds = utils.getBounds(shape);
  const rPositioned = usePosition(bounds, shape.rotation);
  return /* @__PURE__ */ React34.createElement("div", {
    ref: rPositioned,
    draggable: false,
    className: [
      "tl-indicator",
      "tl-absolute",
      isSelected && !user ? "tl-selected" : "tl-hovered",
      isEditing ? "tl-editing" : ""
    ].join(" ")
  }, /* @__PURE__ */ React34.createElement("svg", {
    width: "100%",
    height: "100%"
  }, /* @__PURE__ */ React34.createElement("g", {
    className: "tl-centered-g",
    stroke: user == null ? void 0 : user.color
  }, /* @__PURE__ */ React34.createElement(utils.Indicator, {
    shape,
    meta,
    user,
    bounds,
    isSelected,
    isHovered
  }))));
});
var Page = observer(function _Page({
  page,
  pageState,
  assets,
  hideBounds,
  hideHandles,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideRotateHandle,
  hideResizeHandles,
  meta
}) {
  const { bounds: rendererBounds, shapeUtils: shapeUtils2 } = useTLContext();
  const shapeTree = useShapeTree(page, pageState, assets, meta);
  const { bounds, isLinked, isLocked, rotation } = useSelection(page, pageState, shapeUtils2);
  const {
    selectedIds,
    hoveredId,
    editingId,
    camera: { zoom }
  } = pageState;
  let _hideIndicators = hideIndicators;
  let _hideCloneHandles = true;
  let _isEditing = false;
  let shapeWithHandles = void 0;
  const selectedShapes = selectedIds.map((id) => page.shapes[id]);
  if (selectedShapes.length === 1) {
    const shape = selectedShapes[0];
    _isEditing = editingId === shape.id;
    if (_isEditing)
      _hideIndicators = true;
    const utils = shapeUtils2[shape.type];
    _hideCloneHandles = hideCloneHandles || !utils.showCloneHandles;
    if (shape.handles !== void 0 && !_isEditing) {
      shapeWithHandles = shape;
    }
  }
  return /* @__PURE__ */ React35.createElement(React35.Fragment, null, bounds && /* @__PURE__ */ React35.createElement(BoundsBg, {
    bounds,
    rotation,
    isHidden: hideBounds
  }), shapeTree.map((node) => /* @__PURE__ */ React35.createElement(ShapeNode, __spreadValues3({
    key: node.shape.id,
    utils: shapeUtils2
  }, node))), !_hideIndicators && selectedShapes.map((shape) => /* @__PURE__ */ React35.createElement(ShapeIndicator, {
    key: "selected_" + shape.id,
    shape,
    meta,
    isSelected: true,
    isEditing: _isEditing
  })), !_hideIndicators && hoveredId && hoveredId !== editingId && /* @__PURE__ */ React35.createElement(ShapeIndicator, {
    key: "hovered_" + hoveredId,
    shape: page.shapes[hoveredId],
    meta,
    isHovered: true
  }), bounds && /* @__PURE__ */ React35.createElement(Bounds, {
    zoom,
    bounds,
    viewportWidth: rendererBounds.width,
    isLocked,
    rotation,
    isHidden: hideBounds,
    hideRotateHandle,
    hideResizeHandles,
    hideBindingHandles: hideBindingHandles || !isLinked,
    hideCloneHandles: _hideCloneHandles
  }), !hideHandles && shapeWithHandles && /* @__PURE__ */ React35.createElement(Handles, {
    shape: shapeWithHandles,
    zoom
  }));
});
function User({ user }) {
  const rCursor = React36.useRef(null);
  useCursorAnimation(rCursor, user.point);
  return /* @__PURE__ */ React36.createElement("svg", {
    ref: rCursor,
    className: "tl-absolute tl-user tl-counter-scaled",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 50 50",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React36.createElement("g", {
    fill: "rgba(0,0,0,.2)",
    transform: "translate(1,1)"
  }, /* @__PURE__ */ React36.createElement("path", {
    d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
  }), /* @__PURE__ */ React36.createElement("path", {
    d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
  })), /* @__PURE__ */ React36.createElement("g", {
    fill: "white"
  }, /* @__PURE__ */ React36.createElement("path", {
    d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
  }), /* @__PURE__ */ React36.createElement("path", {
    d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
  })), /* @__PURE__ */ React36.createElement("g", {
    fill: user.color
  }, /* @__PURE__ */ React36.createElement("path", {
    d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z"
  }), /* @__PURE__ */ React36.createElement("path", {
    d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z"
  })), /* @__PURE__ */ React36.createElement("text", {
    fill: user.color,
    "font-size": "1em",
    x: "",
    y: "45"
  }, user.name));
}
function Users({ userId, users }) {
  return /* @__PURE__ */ React37.createElement(React37.Fragment, null, Object.values(users).filter((user) => user && user.id !== userId).map((user) => /* @__PURE__ */ React37.createElement(User, {
    key: user.id,
    user
  })));
}
function useResizeObserver(ref, onBoundsChange) {
  const { inputs: inputs2, callbacks } = useTLContext();
  const rIsMounted = React38.useRef(false);
  const updateBounds = React38.useCallback(() => {
    var _a2, _b;
    if (rIsMounted.current) {
      const rect = (_a2 = ref.current) == null ? void 0 : _a2.getBoundingClientRect();
      if (rect) {
        const bounds = {
          minX: rect.left,
          maxX: rect.left + rect.width,
          minY: rect.top,
          maxY: rect.top + rect.height,
          width: rect.width,
          height: rect.height
        };
        inputs2.bounds = bounds;
        onBoundsChange(bounds);
        (_b = callbacks.onBoundsChange) == null ? void 0 : _b.call(callbacks, bounds);
      }
    } else {
      rIsMounted.current = true;
    }
  }, [ref, inputs2, callbacks.onBoundsChange]);
  React38.useEffect(() => {
    const debouncedupdateBounds = Utils.debounce(updateBounds, 100);
    window.addEventListener("scroll", debouncedupdateBounds);
    window.addEventListener("resize", debouncedupdateBounds);
    return () => {
      window.removeEventListener("scroll", debouncedupdateBounds);
      window.removeEventListener("resize", debouncedupdateBounds);
    };
  }, []);
  React38.useEffect(() => {
    const resizeObserver = new ResizeObserver_es_default((entries) => {
      if (inputs2.isPinching) {
        return;
      }
      if (entries[0].contentRect) {
        updateBounds();
      }
    });
    if (ref.current) {
      resizeObserver.observe(ref.current);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref, inputs2]);
  React38.useEffect(() => {
    updateBounds();
  }, [ref]);
}
var DOUBLE_CLICK_DURATION = 250;
var Inputs = class {
  constructor() {
    __publicField2(this, "pointer");
    __publicField2(this, "keyboard");
    __publicField2(this, "keys", {});
    __publicField2(this, "isPinching", false);
    __publicField2(this, "bounds", {
      minX: 0,
      maxX: 640,
      minY: 0,
      maxY: 480,
      width: 640,
      height: 480
    });
    __publicField2(this, "zoom", 1);
    __publicField2(this, "pointerUpTime", 0);
    __publicField2(this, "activePointer");
    __publicField2(this, "panStart", (e11) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e11;
      const info = {
        target: "wheel",
        pointerId: ((_a2 = this.pointer) == null ? void 0 : _a2.pointerId) || 0,
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        delta: [0, 0],
        pressure: 0.5,
        point: Inputs.getPoint(e11, this.bounds),
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      };
      this.pointer = info;
      return info;
    });
    __publicField2(this, "pan", (delta, e11) => {
      if (!this.pointer || this.pointer.target !== "wheel") {
        return this.panStart(e11);
      }
      const { shiftKey, ctrlKey, metaKey, altKey } = e11;
      const prev = this.pointer;
      const point = Inputs.getPoint(e11, this.bounds);
      const info = __spreadProps3(__spreadValues3({}, prev), {
        target: "wheel",
        delta,
        point,
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      });
      this.pointer = info;
      return info;
    });
    __publicField2(this, "keydown", (e11) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e11;
      this.keys[e11.key] = true;
      return {
        point: ((_a2 = this.pointer) == null ? void 0 : _a2.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e11.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
    __publicField2(this, "keyup", (e11) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e11;
      delete this.keys[e11.key];
      return {
        point: ((_a2 = this.pointer) == null ? void 0 : _a2.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e11.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
  }
  pointerIsValid(e11) {
    if ("pointerId" in e11) {
      if (this.activePointer && this.activePointer !== e11.pointerId) {
        return false;
      }
    }
    if ("touches" in e11) {
      const touch = e11.changedTouches[0];
      if (this.activePointer && this.activePointer !== touch.identifier) {
        return false;
      }
    }
    return true;
  }
  touchStart(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const touch = e11.changedTouches[0];
    this.activePointer = touch.identifier;
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  touchEnd(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const touch = e11.changedTouches[0];
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    this.activePointer = void 0;
    return info;
  }
  touchMove(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const touch = e11.changedTouches[0];
    const prev = this.pointer;
    const point = Inputs.getPoint(touch, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: touch.identifier,
      point,
      delta,
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerDown(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const point = Inputs.getPoint(e11, this.bounds);
    this.activePointer = e11.pointerId;
    const info = {
      target,
      pointerId: e11.pointerId,
      origin: point,
      point,
      delta: [0, 0],
      pressure: Inputs.getPressure(e11),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerEnter(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const point = Inputs.getPoint(e11, this.bounds);
    const info = {
      target,
      pointerId: e11.pointerId,
      origin: point,
      delta: [0, 0],
      point,
      pressure: Inputs.getPressure(e11),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerMove(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const prev = this.pointer;
    const point = Inputs.getPoint(e11, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: e11.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e11),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerUp(e11, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e11;
    const prev = this.pointer;
    const point = Inputs.getPoint(e11, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    this.activePointer = void 0;
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: e11.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e11),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    this.pointerUpTime = performance.now();
    return info;
  }
  isDoubleClick() {
    if (!this.pointer)
      return false;
    const { origin, point } = this.pointer;
    const isDoubleClick = performance.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && Vec.dist(origin, point) < 4;
    if (isDoubleClick)
      this.activePointer = void 0;
    return isDoubleClick;
  }
  clear() {
    this.pointer = void 0;
  }
  resetDoubleClick() {
    this.pointerUpTime = 0;
  }
  pinch(point, origin) {
    const { shiftKey, ctrlKey, metaKey, altKey } = this.keys;
    const delta = Vec.sub(origin, point);
    const info = {
      pointerId: 0,
      target: "pinch",
      origin,
      delta,
      point: Vec.sub(Vec.toFixed(point), [this.bounds.minX, this.bounds.minY]),
      pressure: 0.5,
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  reset() {
    this.pointerUpTime = 0;
    this.pointer = void 0;
    this.keyboard = void 0;
    this.activePointer = void 0;
    this.keys = {};
  }
  static getPoint(e11, bounds) {
    return [+e11.clientX.toFixed(2) - bounds.minX, +e11.clientY.toFixed(2) - bounds.minY];
  }
  static getPressure(e11) {
    return "pressure" in e11 ? +e11.pressure.toFixed(2) || 0.5 : 0.5;
  }
  static commandKey() {
    return Utils.isDarwin() ? "\u2318" : "Ctrl";
  }
};
var inputs = new Inputs();
function UsersIndicators({
  userId,
  users,
  meta,
  page
}) {
  const { shapeUtils: shapeUtils2 } = useTLContext();
  return /* @__PURE__ */ React39.createElement(React39.Fragment, null, Object.values(users).filter(Boolean).filter((user) => user.id !== userId && user.selectedIds.length > 0).map((user) => {
    const shapes = user.selectedIds.map((id) => page.shapes[id]).filter(Boolean);
    if (shapes.length === 0)
      return null;
    const bounds = utils_default.getCommonBounds(shapes.map((shape) => shapeUtils2[shape.type].getBounds(shape)));
    return /* @__PURE__ */ React39.createElement(React39.Fragment, {
      key: user.id + "_shapes"
    }, /* @__PURE__ */ React39.createElement("div", {
      className: "tl-absolute tl-user-indicator-bounds",
      style: {
        backgroundColor: user.color + "0d",
        borderColor: user.color + "78",
        transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,
        width: bounds.width,
        height: bounds.height,
        pointerEvents: "none"
      }
    }), shapes.map((shape) => /* @__PURE__ */ React39.createElement(ShapeIndicator, {
      key: `${user.id}_${shape.id}_indicator`,
      shape,
      user,
      meta,
      isHovered: true
    })));
  }));
}
var SnapLines = observer(function SnapLines2({ snapLines }) {
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, snapLines.map((snapLine, i8) => /* @__PURE__ */ React40.createElement(SnapLine, {
    key: i8,
    snapLine
  })));
});
var SnapLine = observer(function SnapLine2({ snapLine }) {
  const bounds = utils_default.getBoundsFromPoints(snapLine);
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("line", {
    className: "tl-snap-line",
    x1: bounds.minX,
    y1: bounds.minY,
    x2: bounds.maxX,
    y2: bounds.maxY
  }), snapLine.map(([x6, y5], i8) => /* @__PURE__ */ React40.createElement("use", {
    key: i8,
    href: "#tl-snap-point",
    x: x6,
    y: y5
  })));
});
var STEPS = [
  [-1, 0.15, 64],
  [0.05, 0.375, 16],
  [0.15, 1, 4],
  [0.7, 2.5, 1]
];
function Grid({ grid, camera }) {
  return /* @__PURE__ */ React41.createElement("svg", {
    className: "tl-grid",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React41.createElement("defs", null, STEPS.map(([min2, mid, size], i8) => {
    const s9 = size * grid * camera.zoom;
    const xo = camera.point[0] * camera.zoom;
    const yo = camera.point[1] * camera.zoom;
    const gxo = xo > 0 ? xo % s9 : s9 + xo % s9;
    const gyo = yo > 0 ? yo % s9 : s9 + yo % s9;
    const opacity = camera.zoom < mid ? utils_default.modulate(camera.zoom, [min2, mid], [0, 1]) : 1;
    return /* @__PURE__ */ React41.createElement("pattern", {
      key: `grid-pattern-${i8}`,
      id: `grid-${i8}`,
      width: s9,
      height: s9,
      patternUnits: "userSpaceOnUse"
    }, /* @__PURE__ */ React41.createElement("circle", {
      className: `tl-grid-dot`,
      cx: gxo,
      cy: gyo,
      r: 1,
      opacity
    }));
  })), STEPS.map((_5, i8) => /* @__PURE__ */ React41.createElement("rect", {
    key: `grid-rect-${i8}`,
    width: "100%",
    height: "100%",
    fill: `url(#grid-${i8})`
  })));
}
var Overlay = observer(function Overlay2({ camera: { zoom, point }, children }) {
  const l9 = 2.5 / zoom;
  return /* @__PURE__ */ React42.createElement("svg", {
    className: "tl-overlay"
  }, /* @__PURE__ */ React42.createElement("defs", null, /* @__PURE__ */ React42.createElement("g", {
    id: "tl-snap-point"
  }, /* @__PURE__ */ React42.createElement("path", {
    className: "tl-snap-point",
    d: `M ${-l9},${-l9} L ${l9},${l9} M ${-l9},${l9} L ${l9},${-l9}`
  }))), /* @__PURE__ */ React42.createElement("g", {
    transform: `scale(${zoom}) translate(${point})`
  }, children));
});
var Canvas = observer(function _Canvas({
  id,
  page,
  pageState,
  assets,
  snapLines,
  grid,
  users,
  userId,
  meta,
  performanceMode,
  externalContainerRef,
  showDashedBrush,
  hideHandles,
  hideBounds,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideGrid,
  onBoundsChange
}) {
  const rCanvas = React43.useRef(null);
  const rContainer = React43.useRef(null);
  const rLayer = React43.useRef(null);
  inputs.zoom = pageState.camera.zoom;
  useResizeObserver(rCanvas, onBoundsChange);
  useZoomEvents(pageState.camera.zoom, externalContainerRef || rCanvas);
  useSafariFocusOutFix();
  usePreventNavigationCss(rCanvas);
  useCameraCss(rLayer, rContainer, pageState);
  usePerformanceCss(performanceMode, rContainer);
  useKeyEvents();
  const events = useCanvasEvents();
  return /* @__PURE__ */ React43.createElement("div", {
    id,
    className: "tl-container",
    ref: rContainer
  }, /* @__PURE__ */ React43.createElement("div", __spreadValues3({
    id: "canvas",
    className: "tl-absolute tl-canvas",
    ref: rCanvas
  }, events), !hideGrid && grid && /* @__PURE__ */ React43.createElement(Grid, {
    grid,
    camera: pageState.camera
  }), /* @__PURE__ */ React43.createElement("div", {
    ref: rLayer,
    className: "tl-absolute tl-layer",
    "data-testid": "layer"
  }, /* @__PURE__ */ React43.createElement(Page, {
    page,
    pageState,
    assets,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideBindingHandles,
    hideCloneHandles,
    hideResizeHandles,
    hideRotateHandle,
    meta
  }), users && userId && /* @__PURE__ */ React43.createElement(UsersIndicators, {
    userId,
    users,
    page,
    meta
  }), pageState.brush && /* @__PURE__ */ React43.createElement(Brush, {
    brush: pageState.brush,
    dashed: showDashedBrush,
    zoom: pageState.camera.zoom
  }), users && /* @__PURE__ */ React43.createElement(Users, {
    userId,
    users
  })), /* @__PURE__ */ React43.createElement(Overlay, {
    camera: pageState.camera
  }, snapLines && /* @__PURE__ */ React43.createElement(SnapLines, {
    snapLines
  }))));
});
var Renderer = observer(function _Renderer(_a2) {
  var _b = _a2, {
    id = "tl",
    shapeUtils: shapeUtils2,
    page,
    pageState,
    assets = EMPTY_OBJECT2,
    users,
    userId,
    theme,
    meta,
    snapLines,
    grid,
    containerRef,
    performanceMode,
    hideHandles = false,
    hideIndicators = false,
    hideCloneHandles = false,
    hideBindingHandles = false,
    hideResizeHandles = false,
    hideRotateHandles = false,
    hideBounds = false,
    hideGrid = true,
    showDashedBrush = false
  } = _b, rest = __objRest2(_b, [
    "id",
    "shapeUtils",
    "page",
    "pageState",
    "assets",
    "users",
    "userId",
    "theme",
    "meta",
    "snapLines",
    "grid",
    "containerRef",
    "performanceMode",
    "hideHandles",
    "hideIndicators",
    "hideCloneHandles",
    "hideBindingHandles",
    "hideResizeHandles",
    "hideRotateHandles",
    "hideBounds",
    "hideGrid",
    "showDashedBrush"
  ]);
  useTLTheme(theme, "#" + id);
  const rSelectionBounds = React44.useRef(null);
  const rPageState = React44.useRef(pageState);
  React44.useEffect(() => {
    rPageState.current = pageState;
  }, [pageState]);
  const [context, setContext] = React44.useState(() => ({
    callbacks: rest,
    shapeUtils: shapeUtils2,
    rSelectionBounds,
    rPageState,
    bounds: {
      minX: 0,
      minY: 0,
      maxX: Infinity,
      maxY: Infinity,
      width: Infinity,
      height: Infinity
    },
    inputs: new Inputs()
  }));
  const onBoundsChange = React44.useCallback((bounds) => {
    setContext((context2) => __spreadProps3(__spreadValues3({}, context2), {
      bounds
    }));
  }, []);
  return /* @__PURE__ */ React44.createElement(TLContext.Provider, {
    value: context
  }, /* @__PURE__ */ React44.createElement(Canvas, {
    id,
    page,
    pageState,
    assets,
    snapLines,
    grid,
    users,
    userId,
    externalContainerRef: containerRef,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideCloneHandles,
    hideBindingHandles,
    hideRotateHandle: hideRotateHandles,
    hideResizeHandles,
    hideGrid,
    showDashedBrush,
    onBoundsChange,
    performanceMode,
    meta
  }));
});
var EMPTY_OBJECT2 = {};
var HTMLContainer = React45.forwardRef(function HTMLContainer2(_a2, ref) {
  var _b = _a2, { children, className = "" } = _b, rest = __objRest2(_b, ["children", "className"]);
  return /* @__PURE__ */ React45.createElement(ObserverComponent, null, () => /* @__PURE__ */ React45.createElement("div", __spreadValues3({
    ref,
    className: `tl-positioned-div ${className}`,
    draggable: false
  }, rest), /* @__PURE__ */ React45.createElement("div", {
    className: "tl-inner-div"
  }, children)));
});
var TLShapeUtil = class {
  constructor() {
    __publicField2(this, "refMap", /* @__PURE__ */ new Map());
    __publicField2(this, "boundsCache", /* @__PURE__ */ new WeakMap());
    __publicField2(this, "showCloneHandles", false);
    __publicField2(this, "hideBounds", false);
    __publicField2(this, "isStateful", false);
    __publicField2(this, "shouldRender", (prev, next) => true);
    __publicField2(this, "getRef", (shape) => {
      if (!this.refMap.has(shape.id)) {
        this.refMap.set(shape.id, React46.createRef());
      }
      return this.refMap.get(shape.id);
    });
    __publicField2(this, "hitTestBounds", (shape, bounds) => {
      const shapeBounds = this.getBounds(shape);
      const corners = utils_default.getRotatedCorners(shapeBounds, shape.rotation);
      return corners.every((point) => utils_default.pointInBounds(point, bounds)) || intersectPolygonBounds(corners, bounds).length > 0;
    });
    __publicField2(this, "getRotatedBounds", (shape) => {
      return utils_default.getBoundsFromPoints(utils_default.getRotatedCorners(this.getBounds(shape), shape.rotation));
    });
  }
};
__publicField2(TLShapeUtil, "Component", (component) => {
  return React46.forwardRef(component);
});
__publicField2(TLShapeUtil, "Indicator", (component) => component);

// ../../node_modules/@stitches/react/dist/index.mjs
var import_react10 = __toESM(require_react(), 1);
var e = "colors";
var t = "sizes";
var r = "space";
var n = { gap: r, gridGap: r, columnGap: r, gridColumnGap: r, rowGap: r, gridRowGap: r, inset: r, insetBlock: r, insetBlockEnd: r, insetBlockStart: r, insetInline: r, insetInlineEnd: r, insetInlineStart: r, margin: r, marginTop: r, marginRight: r, marginBottom: r, marginLeft: r, marginBlock: r, marginBlockEnd: r, marginBlockStart: r, marginInline: r, marginInlineEnd: r, marginInlineStart: r, padding: r, paddingTop: r, paddingRight: r, paddingBottom: r, paddingLeft: r, paddingBlock: r, paddingBlockEnd: r, paddingBlockStart: r, paddingInline: r, paddingInlineEnd: r, paddingInlineStart: r, top: r, right: r, bottom: r, left: r, scrollMargin: r, scrollMarginTop: r, scrollMarginRight: r, scrollMarginBottom: r, scrollMarginLeft: r, scrollMarginX: r, scrollMarginY: r, scrollMarginBlock: r, scrollMarginBlockEnd: r, scrollMarginBlockStart: r, scrollMarginInline: r, scrollMarginInlineEnd: r, scrollMarginInlineStart: r, scrollPadding: r, scrollPaddingTop: r, scrollPaddingRight: r, scrollPaddingBottom: r, scrollPaddingLeft: r, scrollPaddingX: r, scrollPaddingY: r, scrollPaddingBlock: r, scrollPaddingBlockEnd: r, scrollPaddingBlockStart: r, scrollPaddingInline: r, scrollPaddingInlineEnd: r, scrollPaddingInlineStart: r, fontSize: "fontSizes", background: e, backgroundColor: e, backgroundImage: e, borderImage: e, border: e, borderBlock: e, borderBlockEnd: e, borderBlockStart: e, borderBottom: e, borderBottomColor: e, borderColor: e, borderInline: e, borderInlineEnd: e, borderInlineStart: e, borderLeft: e, borderLeftColor: e, borderRight: e, borderRightColor: e, borderTop: e, borderTopColor: e, caretColor: e, color: e, columnRuleColor: e, fill: e, outline: e, outlineColor: e, stroke: e, textDecorationColor: e, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t, minBlockSize: t, maxBlockSize: t, inlineSize: t, minInlineSize: t, maxInlineSize: t, width: t, minWidth: t, maxWidth: t, height: t, minHeight: t, maxHeight: t, flexBasis: t, gridTemplateColumns: t, gridTemplateRows: t, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var i = (e11, t12) => typeof t12 == "function" ? { "()": Function.prototype.toString.call(t12) } : t12;
var o = () => {
  const e11 = /* @__PURE__ */ Object.create(null);
  return (t12, r12, ...n6) => {
    const o11 = ((e12) => JSON.stringify(e12, i))(t12);
    return o11 in e11 ? e11[o11] : e11[o11] = r12(t12, ...n6);
  };
};
var l = Symbol.for("sxs.internal");
var s = (e11, t12) => Object.defineProperties(e11, Object.getOwnPropertyDescriptors(t12));
var a = (e11) => {
  for (const t12 in e11)
    return true;
  return false;
};
var { hasOwnProperty: c } = Object.prototype;
var d = (e11) => e11.includes("-") ? e11 : e11.replace(/[A-Z]/g, (e12) => "-" + e12.toLowerCase());
var g = /\s+(?![^()]*\))/;
var p = (e11) => (t12) => e11(...typeof t12 == "string" ? String(t12).split(g) : [t12]);
var u = { appearance: (e11) => ({ WebkitAppearance: e11, appearance: e11 }), backfaceVisibility: (e11) => ({ WebkitBackfaceVisibility: e11, backfaceVisibility: e11 }), backdropFilter: (e11) => ({ WebkitBackdropFilter: e11, backdropFilter: e11 }), backgroundClip: (e11) => ({ WebkitBackgroundClip: e11, backgroundClip: e11 }), boxDecorationBreak: (e11) => ({ WebkitBoxDecorationBreak: e11, boxDecorationBreak: e11 }), clipPath: (e11) => ({ WebkitClipPath: e11, clipPath: e11 }), content: (e11) => ({ content: e11.includes('"') || e11.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e11) ? e11 : `"${e11}"` }), hyphens: (e11) => ({ WebkitHyphens: e11, hyphens: e11 }), maskImage: (e11) => ({ WebkitMaskImage: e11, maskImage: e11 }), maskSize: (e11) => ({ WebkitMaskSize: e11, maskSize: e11 }), tabSize: (e11) => ({ MozTabSize: e11, tabSize: e11 }), textSizeAdjust: (e11) => ({ WebkitTextSizeAdjust: e11, textSizeAdjust: e11 }), userSelect: (e11) => ({ WebkitUserSelect: e11, userSelect: e11 }), marginBlock: p((e11, t12) => ({ marginBlockStart: e11, marginBlockEnd: t12 || e11 })), marginInline: p((e11, t12) => ({ marginInlineStart: e11, marginInlineEnd: t12 || e11 })), maxSize: p((e11, t12) => ({ maxBlockSize: e11, maxInlineSize: t12 || e11 })), minSize: p((e11, t12) => ({ minBlockSize: e11, minInlineSize: t12 || e11 })), paddingBlock: p((e11, t12) => ({ paddingBlockStart: e11, paddingBlockEnd: t12 || e11 })), paddingInline: p((e11, t12) => ({ paddingInlineStart: e11, paddingInlineEnd: t12 || e11 })) };
var h = /([\d.]+)([^]*)/;
var f = (e11, t12) => e11.length ? e11.reduce((e12, r12) => (e12.push(...t12.map((e13) => e13.includes("&") ? e13.replace(/&/g, /[ +>|~]/.test(r12) && /&.*&/.test(e13) ? `:is(${r12})` : r12) : r12 + " " + e13)), e12), []) : t12;
var m = (e11, t12) => e11 in b && typeof t12 == "string" ? t12.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t13, r12, n6, i8) => r12 + (n6 === "stretch" ? `-moz-available${i8};${d(e11)}:${r12}-webkit-fill-available` : `-moz-fit-content${i8};${d(e11)}:${r12}fit-content`) + i8) : String(t12);
var b = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var S = (e11) => e11 ? e11 + "-" : "";
var k = (e11, t12, r12) => e11.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e12, n6, i8, o11, l9) => o11 == "$" == !!i8 ? e12 : (n6 || o11 == "--" ? "calc(" : "") + "var(--" + (o11 === "$" ? S(t12) + (l9.includes("$") ? "" : S(r12)) + l9.replace(/\$/g, "-") : l9) + ")" + (n6 || o11 == "--" ? "*" + (n6 || "") + (i8 || "1") + ")" : ""));
var y = /\s*,\s*(?![^()]*\))/;
var B = Object.prototype.toString;
var $ = (e11, t12, r12, n6, i8) => {
  let o11, l9, s9;
  const a7 = (e12, t13, r13) => {
    let c8, g6;
    const p7 = (e13) => {
      for (c8 in e13) {
        const R5 = c8.charCodeAt(0) === 64, z3 = R5 && Array.isArray(e13[c8]) ? e13[c8] : [e13[c8]];
        for (g6 of z3) {
          const e14 = /[A-Z]/.test($2 = c8) ? $2 : $2.replace(/-[^]/g, (e15) => e15[1].toUpperCase()), z4 = typeof g6 == "object" && g6 && g6.toString === B && (!n6.utils[e14] || !t13.length);
          if (e14 in n6.utils && !z4) {
            const t14 = n6.utils[e14];
            if (t14 !== l9) {
              l9 = t14, p7(t14(g6)), l9 = null;
              continue;
            }
          } else if (e14 in u) {
            const t14 = u[e14];
            if (t14 !== s9) {
              s9 = t14, p7(t14(g6)), s9 = null;
              continue;
            }
          }
          if (R5 && (b7 = c8.slice(1) in n6.media ? "@media " + n6.media[c8.slice(1)] : c8, c8 = b7.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e15, t14, r14, n7, i9, o12) => {
            const l10 = h.test(t14), s10 = 0.0625 * (l10 ? -1 : 1), [a8, c9] = l10 ? [n7, t14] : [t14, n7];
            return "(" + (r14[0] === "=" ? "" : r14[0] === ">" === l10 ? "max-" : "min-") + a8 + ":" + (r14[0] !== "=" && r14.length === 1 ? c9.replace(h, (e16, t15, n8) => Number(t15) + s10 * (r14 === ">" ? 1 : -1) + n8) : c9) + (i9 ? ") and (" + (i9[0] === ">" ? "min-" : "max-") + a8 + ":" + (i9.length === 1 ? o12.replace(h, (e16, t15, r15) => Number(t15) + s10 * (i9 === ">" ? -1 : 1) + r15) : o12) : "") + ")";
          })), z4) {
            const e15 = R5 ? r13.concat(c8) : [...r13], n7 = R5 ? [...t13] : f(t13, c8.split(y));
            o11 !== void 0 && i8(x(...o11)), o11 = void 0, a7(g6, n7, e15);
          } else
            o11 === void 0 && (o11 = [[], t13, r13]), c8 = R5 || c8.charCodeAt(0) !== 36 ? c8 : `--${S(n6.prefix)}${c8.slice(1).replace(/\$/g, "-")}`, g6 = z4 ? g6 : typeof g6 == "number" ? g6 && e14 in I ? String(g6) + "px" : String(g6) : k(m(e14, g6 == null ? "" : g6), n6.prefix, n6.themeMap[e14]), o11[0].push(`${R5 ? `${c8} ` : `${d(c8)}:`}${g6}`);
        }
      }
      var b7, $2;
    };
    p7(e12), o11 !== void 0 && i8(x(...o11)), o11 = void 0;
  };
  a7(e11, t12, r12);
};
var x = (e11, t12, r12) => `${r12.map((e12) => `${e12}{`).join("")}${t12.length ? `${t12.join(",")}{` : ""}${e11.join(";")}${t12.length ? "}" : ""}${Array(r12.length ? r12.length + 1 : 0).join("}")}`;
var I = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var R = (e11) => String.fromCharCode(e11 + (e11 > 25 ? 39 : 97));
var z = (e11) => ((e12) => {
  let t12, r12 = "";
  for (t12 = Math.abs(e12); t12 > 52; t12 = t12 / 52 | 0)
    r12 = R(t12 % 52) + r12;
  return R(t12 % 52) + r12;
})(((e12, t12) => {
  let r12 = t12.length;
  for (; r12; )
    e12 = 33 * e12 ^ t12.charCodeAt(--r12);
  return e12;
})(5381, JSON.stringify(e11)) >>> 0);
var W = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var j = (e11) => {
  if (e11.href && !e11.href.startsWith(location.origin))
    return false;
  try {
    return e11.cssRules, true;
  } catch (e12) {
    return false;
  }
};
var E = (e11) => {
  let t12;
  const r12 = () => {
    if (t12) {
      const { rules: e12, sheet: r13 } = t12;
      if (!r13.deleteRule) {
        for (; Object(Object(r13.cssRules)[0]).type === 3; )
          r13.cssRules.splice(0, 1);
        r13.cssRules = [];
      }
      for (const t13 in e12)
        delete e12[t13];
    }
    const n6 = Object(e11).styleSheets || [];
    for (const e12 of n6)
      if (j(e12)) {
        for (let n7 = 0, i9 = e12.cssRules; i9[n7]; ++n7) {
          const o12 = Object(i9[n7]);
          if (o12.type !== 1)
            continue;
          const l9 = Object(i9[n7 + 1]);
          if (l9.type !== 4)
            continue;
          ++n7;
          const { cssText: s9 } = o12;
          if (!s9.startsWith("--sxs"))
            continue;
          const a7 = s9.slice(14, -3).trim().split(/\s+/), c8 = W[a7[0]];
          c8 && (t12 || (t12 = { sheet: e12, reset: r12, rules: {} }), t12.rules[c8] = { group: l9, index: n7, cache: new Set(a7) });
        }
        if (t12)
          break;
      }
    if (!t12) {
      const n7 = (e12, t13) => ({ type: t13, cssRules: [], insertRule(e13, t14) {
        this.cssRules.splice(t14, 0, n7(e13, { import: 3, undefined: 1 }[(e13.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return e12 === "@media{}" ? `@media{${[].map.call(this.cssRules, (e13) => e13.cssText).join("")}}` : e12;
      } });
      t12 = { sheet: e11 ? (e11.head || e11).appendChild(document.createElement("style")).sheet : n7("", "text/css"), rules: {}, reset: r12, toString() {
        const { cssRules: e12 } = t12.sheet;
        return [].map.call(e12, (r13, n8) => {
          const { cssText: i9 } = r13;
          let o12 = "";
          if (i9.startsWith("--sxs"))
            return "";
          if (e12[n8 - 1] && (o12 = e12[n8 - 1].cssText).startsWith("--sxs")) {
            if (!r13.cssRules.length)
              return "";
            for (const e13 in t12.rules)
              if (t12.rules[e13].group === r13)
                return `--sxs{--sxs:${[...t12.rules[e13].cache].join(" ")}}${i9}`;
            return r13.cssRules.length ? `${o12}${i9}` : "";
          }
          return i9;
        }).join("");
      } };
    }
    const { sheet: i8, rules: o11 } = t12;
    for (let e12 = W.length - 1; e12 >= 0; --e12) {
      const t13 = W[e12];
      if (!o11[t13]) {
        const r13 = W[e12 + 1], n7 = o11[r13] ? o11[r13].index : i8.cssRules.length;
        i8.insertRule("@media{}", n7), i8.insertRule(`--sxs{--sxs:${e12}}`, n7), o11[t13] = { group: i8.cssRules[n7 + 1], index: n7, cache: /* @__PURE__ */ new Set([e12]) };
      }
      v(o11[t13]);
    }
  };
  return r12(), t12;
};
var v = (e11) => {
  const t12 = e11.group;
  let r12 = t12.cssRules.length;
  e11.apply = (e12) => {
    try {
      t12.insertRule(e12, r12), ++r12;
    } catch (e13) {
    }
  };
};
var T = Symbol();
var w = o();
var M = (e11, t12) => w(e11, () => (...r12) => {
  let n6 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t13 of r12)
    if (t13 != null)
      if (t13[l]) {
        n6.type == null && (n6.type = t13[l].type);
        for (const e12 of t13[l].composers)
          n6.composers.add(e12);
      } else
        t13.constructor !== Object || t13.$$typeof ? n6.type == null && (n6.type = t13) : n6.composers.add(C(t13, e11));
  return n6.type == null && (n6.type = "span"), n6.composers.size || n6.composers.add(["PJLV", {}, [], [], {}, []]), P(e11, n6, t12);
});
var C = (_a2, i8) => {
  var _b = _a2, { variants: e11, compoundVariants: t12, defaultVariants: r12 } = _b, n6 = __objRest(_b, ["variants", "compoundVariants", "defaultVariants"]);
  const o11 = `${S(i8.prefix)}c-${z(n6)}`, l9 = [], s9 = [], d7 = /* @__PURE__ */ Object.create(null), g6 = [];
  for (const e12 in r12)
    d7[e12] = String(r12[e12]);
  if (typeof e11 == "object" && e11)
    for (const t13 in e11) {
      p7 = d7, u4 = t13, c.call(p7, u4) || (d7[t13] = "undefined");
      const r13 = e11[t13];
      for (const e12 in r13) {
        const n7 = { [t13]: String(e12) };
        String(e12) === "undefined" && g6.push(t13);
        const i9 = r13[e12], o12 = [n7, i9, !a(i9)];
        l9.push(o12);
      }
    }
  var p7, u4;
  if (typeof t12 == "object" && t12)
    for (const e12 of t12) {
      let _a3 = e12, { css: t13 } = _a3, r13 = __objRest(_a3, ["css"]);
      t13 = typeof t13 == "object" && t13 || {};
      for (const e13 in r13)
        r13[e13] = String(r13[e13]);
      const n7 = [r13, t13, !a(t13)];
      s9.push(n7);
    }
  return [o11, n6, l9, s9, d7, g6];
};
var P = (e11, t12, r12) => {
  const [n6, i8, o11, a7] = L(t12.composers), c8 = typeof t12.type == "function" || t12.type.$$typeof ? ((e12) => {
    function t13() {
      for (let r13 = 0; r13 < t13[T].length; r13++) {
        const [n7, i9] = t13[T][r13];
        e12.rules[n7].apply(i9);
      }
      return t13[T] = [], null;
    }
    return t13[T] = [], t13.rules = {}, W.forEach((e13) => t13.rules[e13] = { apply: (r13) => t13[T].push([e13, r13]) }), t13;
  })(r12) : null, d7 = (c8 || r12).rules, g6 = `.${n6}${i8.length > 1 ? `:where(.${i8.slice(1).join(".")})` : ""}`, p7 = (l9) => {
    l9 = typeof l9 == "object" && l9 || A;
    const _a2 = l9, { css: s9 } = _a2, p8 = __objRest(_a2, ["css"]), u4 = {};
    for (const e12 in o11)
      if (delete p8[e12], e12 in l9) {
        let t13 = l9[e12];
        typeof t13 == "object" && t13 ? u4[e12] = __spreadValues({ "@initial": o11[e12] }, t13) : (t13 = String(t13), u4[e12] = t13 !== "undefined" || a7.has(e12) ? t13 : o11[e12]);
      } else
        u4[e12] = o11[e12];
    const h4 = /* @__PURE__ */ new Set([...i8]);
    for (const [n7, i9, o12, l10] of t12.composers) {
      r12.rules.styled.cache.has(n7) || (r12.rules.styled.cache.add(n7), $(i9, [`.${n7}`], [], e11, (e12) => {
        d7.styled.apply(e12);
      }));
      const t13 = O(o12, u4, e11.media), s10 = O(l10, u4, e11.media, true);
      for (const i10 of t13)
        if (i10 !== void 0)
          for (const [t14, o13, l11] of i10) {
            const i11 = `${n7}-${z(o13)}-${t14}`;
            h4.add(i11);
            const s11 = (l11 ? r12.rules.resonevar : r12.rules.onevar).cache, a8 = l11 ? d7.resonevar : d7.onevar;
            s11.has(i11) || (s11.add(i11), $(o13, [`.${i11}`], [], e11, (e12) => {
              a8.apply(e12);
            }));
          }
      for (const t14 of s10)
        if (t14 !== void 0)
          for (const [i10, o13] of t14) {
            const t15 = `${n7}-${z(o13)}-${i10}`;
            h4.add(t15), r12.rules.allvar.cache.has(t15) || (r12.rules.allvar.cache.add(t15), $(o13, [`.${t15}`], [], e11, (e12) => {
              d7.allvar.apply(e12);
            }));
          }
    }
    if (typeof s9 == "object" && s9) {
      const t13 = `${n6}-i${z(s9)}-css`;
      h4.add(t13), r12.rules.inline.cache.has(t13) || (r12.rules.inline.cache.add(t13), $(s9, [`.${t13}`], [], e11, (e12) => {
        d7.inline.apply(e12);
      }));
    }
    for (const e12 of String(l9.className || "").trim().split(/\s+/))
      e12 && h4.add(e12);
    const f10 = p8.className = [...h4].join(" ");
    return { type: t12.type, className: f10, selector: g6, props: p8, toString: () => f10, deferredInjector: c8 };
  };
  return s(p7, { className: n6, selector: g6, [l]: t12, toString: () => (r12.rules.styled.cache.has(n6) || p7(), n6) });
};
var L = (e11) => {
  let t12 = "";
  const r12 = [], n6 = {}, i8 = [];
  for (const [o11, , , , l9, s9] of e11) {
    t12 === "" && (t12 = o11), r12.push(o11), i8.push(...s9);
    for (const e12 in l9) {
      const t13 = l9[e12];
      (n6[e12] === void 0 || t13 !== "undefined" || s9.includes(t13)) && (n6[e12] = t13);
    }
  }
  return [t12, r12, n6, new Set(i8)];
};
var O = (e11, t12, r12, n6) => {
  const i8 = [];
  e:
    for (let [o11, l9, s9] of e11) {
      if (s9)
        continue;
      let e12, a7 = 0, c8 = false;
      for (e12 in o11) {
        const n7 = o11[e12];
        let i9 = t12[e12];
        if (i9 !== n7) {
          if (typeof i9 != "object" || !i9)
            continue e;
          {
            let e13, t13, o12 = 0;
            for (const l10 in i9) {
              if (n7 === String(i9[l10])) {
                if (l10 !== "@initial") {
                  const e14 = l10.slice(1);
                  (t13 = t13 || []).push(e14 in r12 ? r12[e14] : l10.replace(/^@media ?/, "")), c8 = true;
                }
                a7 += o12, e13 = true;
              }
              ++o12;
            }
            if (t13 && t13.length && (l9 = { ["@media " + t13.join(", ")]: l9 }), !e13)
              continue e;
          }
        }
      }
      (i8[a7] = i8[a7] || []).push([n6 ? "cv" : `${e12}-${o11[e12]}`, l9, c8]);
    }
  return i8;
};
var A = {};
var N = o();
var D = (e11, t12) => N(e11, () => (...r12) => {
  const n6 = () => {
    for (let n7 of r12) {
      n7 = typeof n7 == "object" && n7 || {};
      let r13 = z(n7);
      if (!t12.rules.global.cache.has(r13)) {
        if (t12.rules.global.cache.add(r13), "@import" in n7) {
          let e12 = [].indexOf.call(t12.sheet.cssRules, t12.rules.themed.group) - 1;
          for (let r14 of [].concat(n7["@import"]))
            r14 = r14.includes('"') || r14.includes("'") ? r14 : `"${r14}"`, t12.sheet.insertRule(`@import ${r14};`, e12++);
          delete n7["@import"];
        }
        $(n7, [], [], e11, (e12) => {
          t12.rules.global.apply(e12);
        });
      }
    }
    return "";
  };
  return s(n6, { toString: n6 });
});
var H = o();
var V2 = (e11, t12) => H(e11, () => (r12) => {
  const n6 = `${S(e11.prefix)}k-${z(r12)}`, i8 = () => {
    if (!t12.rules.global.cache.has(n6)) {
      t12.rules.global.cache.add(n6);
      const i9 = [];
      $(r12, [], [], e11, (e12) => i9.push(e12));
      const o11 = `@keyframes ${n6}{${i9.join("")}}`;
      t12.rules.global.apply(o11);
    }
    return n6;
  };
  return s(i8, { get name() {
    return i8();
  }, toString: i8 });
});
var G = class {
  constructor(e11, t12, r12, n6) {
    this.token = e11 == null ? "" : String(e11), this.value = t12 == null ? "" : String(t12), this.scale = r12 == null ? "" : String(r12), this.prefix = n6 == null ? "" : String(n6);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S(this.prefix) + S(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var F = o();
var J = (e11, t12) => F(e11, () => (r12, n6) => {
  n6 = typeof r12 == "object" && r12 || Object(n6);
  const i8 = `.${r12 = (r12 = typeof r12 == "string" ? r12 : "") || `${S(e11.prefix)}t-${z(n6)}`}`, o11 = {}, l9 = [];
  for (const t13 in n6) {
    o11[t13] = {};
    for (const r13 in n6[t13]) {
      const i9 = `--${S(e11.prefix)}${t13}-${r13}`, s10 = k(String(n6[t13][r13]), e11.prefix, t13);
      o11[t13][r13] = new G(r13, s10, t13, e11.prefix), l9.push(`${i9}:${s10}`);
    }
  }
  const s9 = () => {
    if (l9.length && !t12.rules.themed.cache.has(r12)) {
      t12.rules.themed.cache.add(r12);
      const i9 = `${n6 === e11.theme ? ":root," : ""}.${r12}{${l9.join(";")}}`;
      t12.rules.themed.apply(i9);
    }
    return r12;
  };
  return __spreadProps(__spreadValues({}, o11), { get className() {
    return s9();
  }, selector: i8, toString: s9 });
});
var U = o();
var X;
var Y = o();
var q = (e11) => {
  const t12 = ((e12) => {
    let t13 = false;
    const r12 = U(e12, (e13) => {
      t13 = true;
      const r13 = "prefix" in (e13 = typeof e13 == "object" && e13 || {}) ? String(e13.prefix) : "", i8 = typeof e13.media == "object" && e13.media || {}, o11 = typeof e13.root == "object" ? e13.root || null : globalThis.document || null, l9 = typeof e13.theme == "object" && e13.theme || {}, s9 = { prefix: r13, media: i8, theme: l9, themeMap: typeof e13.themeMap == "object" && e13.themeMap || __spreadValues({}, n), utils: typeof e13.utils == "object" && e13.utils || {} }, a7 = E(o11), c8 = { css: M(s9, a7), globalCss: D(s9, a7), keyframes: V2(s9, a7), createTheme: J(s9, a7), reset() {
        a7.reset(), c8.theme.toString();
      }, theme: {}, sheet: a7, config: s9, prefix: r13, getCssText: a7.toString, toString: a7.toString };
      return String(c8.theme = c8.createTheme(l9)), c8;
    });
    return t13 || r12.reset(), r12;
  })(e11);
  return t12.styled = (({ config: e12, sheet: t13 }) => Y(e12, () => {
    const r12 = M(e12, t13);
    return (...e13) => {
      const t14 = r12(...e13), n6 = t14[l].type, i8 = import_react10.default.forwardRef((e14, r13) => {
        const i9 = e14 && e14.as || n6, { props: o11, deferredInjector: l9 } = t14(e14);
        return delete o11.as, o11.ref = r13, l9 ? import_react10.default.createElement(import_react10.default.Fragment, null, import_react10.default.createElement(i9, o11), import_react10.default.createElement(l9, null)) : import_react10.default.createElement(i9, o11);
      });
      return i8.className = t14.className, i8.displayName = `Styled.${n6.displayName || n6.name || n6}`, i8.selector = t14.selector, i8.toString = () => t14.selector, i8[l] = t14[l], i8;
    };
  }))(t12), t12;
};
var K = () => X || (X = q());
var re = (...e11) => K().styled(...e11);

// ../../node_modules/safari-14-idb-fix/dist/index.js
function idbReady() {
  var isSafari2 = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari2 || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
var dist_default = idbReady;

// ../../node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject2) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject2(request.error);
  });
}
function createStore(dbName, storeName) {
  const dbp = dist_default().then(() => {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    return promisifyRequest(request);
  });
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get3(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set4(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}

// ../../packages/tldraw/dist/index.mjs
var React72 = __toESM(require_react(), 1);
var React310 = __toESM(require_react(), 1);
var React210 = __toESM(require_react(), 1);
var React53 = __toESM(require_react(), 1);

// ../../node_modules/perfect-freehand/dist/esm/index.js
function W2(e11, t12, s9, h4 = (b7) => b7) {
  return e11 * h4(0.5 - t12 * (0.5 - s9));
}
function re2(e11) {
  return [-e11[0], -e11[1]];
}
function l2(e11, t12) {
  return [e11[0] + t12[0], e11[1] + t12[1]];
}
function a2(e11, t12) {
  return [e11[0] - t12[0], e11[1] - t12[1]];
}
function f2(e11, t12) {
  return [e11[0] * t12, e11[1] * t12];
}
function le(e11, t12) {
  return [e11[0] / t12, e11[1] / t12];
}
function L2(e11) {
  return [e11[1], -e11[0]];
}
function ne(e11, t12) {
  return e11[0] * t12[0] + e11[1] * t12[1];
}
function oe(e11, t12) {
  return e11[0] === t12[0] && e11[1] === t12[1];
}
function fe(e11) {
  return Math.hypot(e11[0], e11[1]);
}
function be(e11) {
  return e11[0] * e11[0] + e11[1] * e11[1];
}
function Y2(e11, t12) {
  return be(a2(e11, t12));
}
function G2(e11) {
  return le(e11, fe(e11));
}
function ue(e11, t12) {
  return Math.hypot(e11[1] - t12[1], e11[0] - t12[0]);
}
function T2(e11, t12, s9) {
  let h4 = Math.sin(s9), b7 = Math.cos(s9), v6 = e11[0] - t12[0], n6 = e11[1] - t12[1], g6 = v6 * b7 - n6 * h4, E7 = v6 * h4 + n6 * b7;
  return [g6 + t12[0], E7 + t12[1]];
}
function V3(e11, t12, s9) {
  return l2(e11, f2(a2(t12, e11), s9));
}
function Z2(e11, t12, s9) {
  return l2(e11, f2(t12, s9));
}
var { min: _, PI: ge } = Math;
var se = 0.275;
var j2 = ge + 1e-4;
function ie(e11, t12 = {}) {
  let { size: s9 = 16, smoothing: h4 = 0.5, thinning: b7 = 0.5, simulatePressure: v6 = true, easing: n6 = (r12) => r12, start: g6 = {}, end: E7 = {}, last: z3 = false } = t12, { cap: d7 = true, taper: x6 = 0, easing: q3 = (r12) => r12 * (2 - r12) } = g6, { cap: m8 = true, taper: c8 = 0, easing: M3 = (r12) => --r12 * r12 * r12 + 1 } = E7;
  if (e11.length === 0 || s9 <= 0)
    return [];
  let H4 = e11[e11.length - 1].runningLength, $2 = Math.pow(s9 * h4, 2), D5 = [], R5 = [], N2 = e11.slice(0, 10).reduce((r12, i8) => {
    let o11 = i8.pressure;
    if (v6) {
      let u4 = _(1, i8.distance / s9), J4 = _(1, 1 - u4);
      o11 = _(1, r12 + (J4 - r12) * (u4 * se));
    }
    return (r12 + o11) / 2;
  }, e11[0].pressure), p7 = W2(s9, b7, e11[e11.length - 1].pressure, n6), U3, B4 = e11[0].vector, I4 = e11[0].point, C6 = I4, y5 = I4, O4 = C6;
  for (let r12 = 0; r12 < e11.length; r12++) {
    let { pressure: i8 } = e11[r12], { point: o11, vector: u4, distance: J4, runningLength: K3 } = e11[r12];
    if (r12 < e11.length - 1 && H4 - K3 < 3)
      continue;
    if (b7) {
      if (v6) {
        let P3 = _(1, J4 / s9), Q = _(1, 1 - P3);
        i8 = _(1, N2 + (Q - N2) * (P3 * se));
      }
      p7 = W2(s9, b7, i8, n6);
    } else
      p7 = s9 / 2;
    U3 === void 0 && (U3 = p7);
    let pe = K3 < x6 ? q3(K3 / x6) : 1, ae = H4 - K3 < c8 ? M3((H4 - K3) / c8) : 1;
    if (p7 = Math.max(0.01, p7 * Math.min(pe, ae)), r12 === e11.length - 1) {
      let P3 = f2(L2(u4), p7);
      D5.push(a2(o11, P3)), R5.push(l2(o11, P3));
      continue;
    }
    let A3 = e11[r12 + 1].vector, ee = ne(u4, A3);
    if (ee < 0) {
      let P3 = f2(L2(B4), p7);
      for (let Q = 1 / 13, w6 = 0; w6 <= 1; w6 += Q)
        y5 = T2(a2(o11, P3), o11, j2 * w6), D5.push(y5), O4 = T2(l2(o11, P3), o11, j2 * -w6), R5.push(O4);
      I4 = y5, C6 = O4;
      continue;
    }
    let te = f2(L2(V3(A3, u4, ee)), p7);
    y5 = a2(o11, te), (r12 <= 1 || Y2(I4, y5) > $2) && (D5.push(y5), I4 = y5), O4 = l2(o11, te), (r12 <= 1 || Y2(C6, O4) > $2) && (R5.push(O4), C6 = O4), N2 = i8, B4 = u4;
  }
  let S3 = e11[0].point.slice(0, 2), k4 = e11.length > 1 ? e11[e11.length - 1].point.slice(0, 2) : l2(e11[0].point, [1, 1]), X3 = [], F5 = [];
  if (e11.length === 1) {
    if (!(x6 || c8) || z3) {
      let r12 = Z2(S3, G2(L2(a2(S3, k4))), -(U3 || p7)), i8 = [];
      for (let o11 = 1 / 13, u4 = o11; u4 <= 1; u4 += o11)
        i8.push(T2(r12, S3, j2 * 2 * u4));
      return i8;
    }
  } else {
    if (!(x6 || c8 && e11.length === 1))
      if (d7)
        for (let i8 = 1 / 13, o11 = i8; o11 <= 1; o11 += i8) {
          let u4 = T2(R5[0], S3, j2 * o11);
          X3.push(u4);
        }
      else {
        let i8 = a2(D5[0], R5[0]), o11 = f2(i8, 0.5), u4 = f2(i8, 0.51);
        X3.push(a2(S3, o11), a2(S3, u4), l2(S3, u4), l2(S3, o11));
      }
    let r12 = L2(re2(e11[e11.length - 1].vector));
    if (c8 || x6 && e11.length === 1)
      F5.push(k4);
    else if (m8) {
      let i8 = Z2(k4, r12, p7);
      for (let o11 = 1 / 29, u4 = o11; u4 < 1; u4 += o11)
        F5.push(T2(i8, k4, j2 * 3 * u4));
    } else
      F5.push(l2(k4, f2(r12, p7)), l2(k4, f2(r12, p7 * 0.99)), a2(k4, f2(r12, p7 * 0.99)), a2(k4, f2(r12, p7)));
  }
  return D5.concat(F5, R5.reverse(), X3);
}
function ce(e11, t12 = {}) {
  var q3;
  let { streamline: s9 = 0.5, size: h4 = 16, last: b7 = false } = t12;
  if (e11.length === 0)
    return [];
  let v6 = 0.15 + (1 - s9) * 0.85, n6 = Array.isArray(e11[0]) ? e11 : e11.map(({ x: m8, y: c8, pressure: M3 = 0.5 }) => [m8, c8, M3]);
  if (n6.length === 2) {
    let m8 = n6[1];
    n6 = n6.slice(0, -1);
    for (let c8 = 1; c8 < 5; c8++)
      n6.push(V3(n6[0], m8, c8 / 4));
  }
  n6.length === 1 && (n6 = [...n6, [...l2(n6[0], [1, 1]), ...n6[0].slice(2)]]);
  let g6 = [{ point: [n6[0][0], n6[0][1]], pressure: n6[0][2] >= 0 ? n6[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], E7 = false, z3 = 0, d7 = g6[0], x6 = n6.length - 1;
  for (let m8 = 1; m8 < n6.length; m8++) {
    let c8 = b7 && m8 === x6 ? n6[m8].slice(0, 2) : V3(d7.point, n6[m8], v6);
    if (oe(d7.point, c8))
      continue;
    let M3 = ue(c8, d7.point);
    if (z3 += M3, m8 < x6 && !E7) {
      if (z3 < h4)
        continue;
      E7 = true;
    }
    d7 = { point: c8, pressure: n6[m8][2] >= 0 ? n6[m8][2] : 0.5, vector: G2(a2(d7.point, c8)), distance: M3, runningLength: z3 }, g6.push(d7);
  }
  return g6[0].vector = ((q3 = g6[1]) == null ? void 0 : q3.vector) || [0, 0], g6;
}
function me(e11, t12 = {}) {
  return ie(ce(e11, t12), t12);
}
var Te = me;

// ../../packages/tldraw/dist/index.mjs
var React410 = __toESM(require_react(), 1);
var React54 = __toESM(require_react(), 1);
var React62 = __toESM(require_react(), 1);
var React112 = __toESM(require_react(), 1);
var React82 = __toESM(require_react(), 1);
var React92 = __toESM(require_react(), 1);
var React102 = __toESM(require_react(), 1);
var React142 = __toESM(require_react(), 1);
var React122 = __toESM(require_react(), 1);
var React132 = __toESM(require_react(), 1);
var React192 = __toESM(require_react(), 1);
var React162 = __toESM(require_react(), 1);
var React152 = __toESM(require_react(), 1);
var React172 = __toESM(require_react(), 1);
var React182 = __toESM(require_react(), 1);
var React202 = __toESM(require_react(), 1);
var React212 = __toESM(require_react(), 1);
var React223 = __toESM(require_react(), 1);
var React232 = __toESM(require_react(), 1);
var React242 = __toESM(require_react(), 1);
var React252 = __toESM(require_react(), 1);

// ../../node_modules/zustand/esm/vanilla.mjs
function createStore2(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace2 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribeWithSelector = (listener, selector = getState2, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe2 = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState: getState2, subscribe: subscribe2, destroy };
  state = createState(setState, getState2, api);
  return api;
}

// ../../node_modules/zustand/esm/index.mjs
var import_react11 = __toESM(require_react(), 1);
function createStore3(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace2 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribeWithSelector = (listener, selector = getState2, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe2 = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState: getState2, subscribe: subscribe2, destroy };
  state = createState(setState, getState2, api);
  return api;
}
var isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var useIsomorphicLayoutEffect = isSSR ? import_react11.useEffect : import_react11.useLayoutEffect;
function create(createState) {
  const api = typeof createState === "function" ? createStore3(createState) : createState;
  const useStore = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = (0, import_react11.useReducer)((c8) => c8 + 1, 0);
    const state = api.getState();
    const stateRef = (0, import_react11.useRef)(state);
    const selectorRef = (0, import_react11.useRef)(selector);
    const equalityFnRef = (0, import_react11.useRef)(equalityFn);
    const erroredRef = (0, import_react11.useRef)(false);
    const currentSliceRef = (0, import_react11.useRef)();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = (0, import_react11.useRef)(state);
    useIsomorphicLayoutEffect(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe2 = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe2;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    (0, import_react11.useDebugValue)(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore, api);
  useStore[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore, api];
    return {
      next() {
        const done = items.length <= 0;
        return { value: items.shift(), done };
      }
    };
  };
  return useStore;
}

// ../../packages/tldraw/dist/index.mjs
var React262 = __toESM(require_react(), 1);

// ../../node_modules/hotkeys-js/dist/hotkeys.esm.js
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object2, event, method) {
  if (object2.addEventListener) {
    object2.addEventListener(event, method, false);
  } else if (object2.attachEvent) {
    object2.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i8 = 0; i8 < mods.length; i8++) {
    mods[i8] = modifier[mods[i8].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys2 = key.split(",");
  var index2 = keys2.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys2[index2 - 1] += ",";
    keys2.splice(index2, 1);
    index2 = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray(a1, a22) {
  var arr1 = a1.length >= a22.length ? a1 : a22;
  var arr2 = a1.length >= a22.length ? a22 : a1;
  var isIndex = true;
  for (var i8 = 0; i8 < arr1.length; i8++) {
    if (arr2.indexOf(arr1[i8]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (k4 = 1; k4 < 20; k4++) {
  _keyMap["f".concat(k4)] = 111 + k4;
}
var k4;
var _downKeys = [];
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x6) {
  return _keyMap[x6.toLowerCase()] || _modifier[x6.toLowerCase()] || x6.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i8;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i8 = 0; i8 < handlers.length; ) {
        if (handlers[i8].scope === scope)
          handlers.splice(i8, 1);
        else
          i8++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i8 = _downKeys.indexOf(key);
  if (i8 >= 0) {
    _downKeys.splice(i8, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k4 in _modifier) {
      if (_modifier[k4] === key)
        hotkeys[k4] = false;
    }
  }
}
function unbind(keysInfo) {
  if (!keysInfo) {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args2[_key - 1] = arguments[_key];
    }
    var scope = args2[0], method = args2[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].map(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
        return {};
      }
      return record;
    });
  });
};
function eventHandler(event, handler, scope) {
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y5 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y5)) {
        if (!_mods[y5] && handler.mods.indexOf(+y5) > -1 || _mods[y5] && handler.mods.indexOf(+y5) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k4 in _modifier) {
      if (_modifier[k4] === key)
        hotkeys[k4] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e11 in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e11)) {
      _mods[e11] = event[modifierMap[e11]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i8 = 0; i8 < asterisk.length; i8++) {
      if (asterisk[i8].scope === scope && (event.type === "keydown" && asterisk[i8].keydown || event.type === "keyup" && asterisk[i8].keyup)) {
        eventHandler(event, asterisk[i8], scope);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a7 = 0; a7 < keyShortcut.length; a7++) {
          _downKeysCurrent.push(code(keyShortcut[a7]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope);
        }
      }
    }
  }
}
function isElementBind(element2) {
  return elementHasBindEvent.indexOf(element2) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys2 = getKeys(key);
  var mods = [];
  var scope = "all";
  var element2 = document;
  var i8 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element2 = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i8 < keys2.length; i8++) {
    key = keys2[i8].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i8],
      method,
      key: keys2[i8],
      splitKey
    });
  }
  if (typeof element2 !== "undefined" && !isElementBind(element2) && window) {
    elementHasBindEvent.push(element2);
    addEvent(element2, "keydown", function(e11) {
      dispatch(e11);
    });
    addEvent(window, "focus", function() {
      _downKeys = [];
    });
    addEvent(element2, "keyup", function(e11) {
      dispatch(e11);
      clearModifier(e11);
    });
  }
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  unbind
};
for (a7 in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a7)) {
    hotkeys[a7] = _api[a7];
  }
}
var a7;
if (typeof window !== "undefined") {
  _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var _hotkeys;
var hotkeys_esm_default = hotkeys;

// ../../node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js
var import_react12 = __toESM(require_react());
hotkeys_esm_default.filter = function() {
  return true;
};
var tagFilter = function tagFilter2(_ref, enableOnTags) {
  var target = _ref.target;
  var targetTagName = target && target.tagName;
  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));
};
var isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput2(ev) {
  return tagFilter(ev, ["INPUT", "TEXTAREA", "SELECT"]);
};
function useHotkeys(keys2, callback, options2, deps) {
  if (options2 instanceof Array) {
    deps = options2;
    options2 = void 0;
  }
  var _ref2 = options2 || {}, enableOnTags = _ref2.enableOnTags, filter2 = _ref2.filter, keyup = _ref2.keyup, keydown = _ref2.keydown, _ref2$filterPreventDe = _ref2.filterPreventDefault, filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe, _ref2$enabled = _ref2.enabled, enabled = _ref2$enabled === void 0 ? true : _ref2$enabled, _ref2$enableOnContent = _ref2.enableOnContentEditable, enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;
  var ref = (0, import_react12.useRef)(null);
  var memoisedCallback = (0, import_react12.useCallback)(function(keyboardEvent, hotkeysEvent) {
    var _keyboardEvent$target;
    if (filter2 && !filter2(keyboardEvent)) {
      return !filterPreventDefault;
    }
    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {
      return true;
    }
    if (ref.current === null || document.activeElement === ref.current) {
      callback(keyboardEvent, hotkeysEvent);
      return true;
    }
    return false;
  }, deps ? [ref, enableOnTags, filter2].concat(deps) : [ref, enableOnTags, filter2]);
  (0, import_react12.useEffect)(function() {
    if (!enabled) {
      hotkeys_esm_default.unbind(keys2, memoisedCallback);
      return;
    }
    if (keyup && keydown !== true) {
      options2.keydown = false;
    }
    hotkeys_esm_default(keys2, options2 || {}, memoisedCallback);
    return function() {
      return hotkeys_esm_default.unbind(keys2, memoisedCallback);
    };
  }, [memoisedCallback, keys2, enabled]);
  return ref;
}
var isHotkeyPressed = hotkeys_esm_default.isPressed;

// ../../packages/tldraw/dist/index.mjs
var React272 = __toESM(require_react(), 1);
var React282 = __toESM(require_react(), 1);
var React292 = __toESM(require_react(), 1);
var React302 = __toESM(require_react(), 1);
var React63 = __toESM(require_react(), 1);
var React312 = __toESM(require_react(), 1);
var React342 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
var o2 = __toESM(require_react());
var useLayoutEffect8 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? o2.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
var t2 = __toESM(require_react());
var r2 = t2["useId".toString()] || (() => {
});
var i2 = 0;
function useId(n6) {
  const [o11, s9] = t2.useState(r2());
  return useLayoutEffect8(() => {
    n6 || s9((e11) => e11 != null ? e11 : String(i2++));
  }, [n6]), n6 || (o11 ? `radix-${o11}` : "");
}

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
var e2 = __toESM(require_react());
var t3 = 0;
function useFocusGuards() {
  e2.useEffect(() => {
    var e11, n6;
    const r12 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e11 = r12[0]) !== null && e11 !== void 0 ? e11 : o3()), document.body.insertAdjacentElement("beforeend", (n6 = r12[1]) !== null && n6 !== void 0 ? n6 : o3()), t3++, () => {
      t3 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e12) => e12.remove()), t3--;
    };
  }, []);
}
function o3() {
  const e11 = document.createElement("span");
  return e11.setAttribute("data-radix-focus-guard", ""), e11.tabIndex = 0, e11.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e11;
}

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
var e3 = __toESM(require_react());
function useCallbackRef(r12) {
  const t12 = e3.useRef(r12);
  return e3.useEffect(() => {
    t12.current = r12;
  }), e3.useMemo(() => (...e11) => {
    var r13;
    return (r13 = t12.current) === null || r13 === void 0 ? void 0 : r13.call(t12, ...e11);
  }, []);
}

// ../../node_modules/@radix-ui/react-use-direction/dist/index.module.js
var e4 = __toESM(require_react());
function useDirection(t12, n6) {
  const [r12, o11] = e4.useState("ltr"), [i8, u4] = e4.useState(), c8 = e4.useRef(0);
  return e4.useEffect(() => {
    if (n6 === void 0 && t12 != null && t12.parentElement) {
      const e11 = getComputedStyle(t12.parentElement);
      u4(e11);
    }
  }, [t12, n6]), e4.useEffect(() => (n6 === void 0 && function e11() {
    c8.current = requestAnimationFrame(() => {
      const t13 = i8 == null ? void 0 : i8.direction;
      t13 && o11(t13), e11();
    });
  }(), () => cancelAnimationFrame(c8.current)), [i8, n6, o11]), n6 || r12;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
var t4 = __toESM(require_react());
function useControllableState({ prop: o11, defaultProp: r12, onChange: n6 = () => {
} }) {
  const [a7, u4] = function({ defaultProp: o12, onChange: r13 }) {
    const n7 = t4.useState(o12), [a8] = n7, u5 = t4.useRef(a8), c9 = useCallbackRef(r13);
    return t4.useEffect(() => {
      u5.current !== a8 && (c9(a8), u5.current = a8);
    }, [a8, u5, c9]), n7;
  }({ defaultProp: r12, onChange: n6 }), c8 = o11 !== void 0, f10 = c8 ? o11 : a7, l9 = useCallbackRef(n6);
  return [f10, t4.useCallback((e11) => {
    if (c8) {
      const t12 = e11, r13 = typeof e11 == "function" ? t12(o11) : e11;
      r13 !== o11 && l9(r13);
    } else
      u4(e11);
  }, [c8, o11, u4, l9])];
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
var o4 = __toESM(require_react());
function composeRefs(...o11) {
  return (e11) => o11.forEach((o12) => function(o13, e12) {
    typeof o13 == "function" ? o13(e12) : o13 != null && (o13.current = e12);
  }(o12, e11));
}
function useComposedRefs(...e11) {
  return o4.useCallback(composeRefs(...e11), e11);
}

// ../../node_modules/@radix-ui/react-slot/dist/index.module.js
var t5 = __toESM(require_react());

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// ../../node_modules/@radix-ui/react-slot/dist/index.module.js
var Slot = /* @__PURE__ */ t5.forwardRef((e11, o11) => {
  const _a2 = e11, { children: a7 } = _a2, s9 = __objRest(_a2, ["children"]);
  return t5.Children.toArray(a7).some(l3) ? /* @__PURE__ */ t5.createElement(t5.Fragment, null, t5.Children.map(a7, (e12) => l3(e12) ? /* @__PURE__ */ t5.createElement(n2, _extends2({}, s9, { ref: o11 }), e12.props.children) : e12)) : /* @__PURE__ */ t5.createElement(n2, _extends2({}, s9, { ref: o11 }), a7);
});
Slot.displayName = "Slot";
var n2 = /* @__PURE__ */ t5.forwardRef((r12, n6) => {
  const _a2 = r12, { children: l9 } = _a2, a7 = __objRest(_a2, ["children"]);
  return t5.isValidElement(l9) ? /* @__PURE__ */ t5.cloneElement(l9, __spreadProps(__spreadValues({}, o5(a7, l9.props)), { ref: composeRefs(n6, l9.ref) })) : t5.Children.count(l9) > 1 ? t5.Children.only(null) : null;
});
n2.displayName = "SlotClone";
var Slottable = ({ children: e11 }) => /* @__PURE__ */ t5.createElement(t5.Fragment, null, e11);
function l3(e11) {
  return t5.isValidElement(e11) && e11.type === Slottable;
}
function o5(e11, t12) {
  const r12 = __spreadValues({}, t12);
  for (const n6 in t12) {
    const l9 = e11[n6], o11 = t12[n6];
    /^on[A-Z]/.test(n6) ? r12[n6] = (...e12) => {
      o11 == null || o11(...e12), l9 == null || l9(...e12);
    } : n6 === "style" ? r12[n6] = __spreadValues(__spreadValues({}, l9), o11) : n6 === "className" && (r12[n6] = [l9, o11].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, e11), r12);
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
var r3 = __toESM(require_react());
var Primitive = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "p", "span", "svg", "ul"].reduce((t12, s9) => __spreadProps(__spreadValues({}, t12), { [s9]: /* @__PURE__ */ r3.forwardRef((t13, n6) => {
  const _a2 = t13, { asChild: a7 } = _a2, m8 = __objRest(_a2, ["asChild"]), d7 = a7 ? Slot : s9;
  return r3.useEffect(() => {
    window[Symbol.for("radix-ui")] = true;
  }, []), t13.as && console.error(o6), /* @__PURE__ */ r3.createElement(d7, _extends2({}, m8, { ref: n6 }));
}) }), {});
var o6 = "Warning: The `as` prop has been removed in favour of `asChild`. For details, see https://radix-ui.com/docs/primitives/overview/styling#changing-the-rendered-element";

// ../../node_modules/@radix-ui/react-context/dist/index.module.js
var e5 = __toESM(require_react());
function createContext3(t12, n6) {
  const o11 = /* @__PURE__ */ e5.createContext(n6);
  function r12(t13) {
    const _a2 = t13, { children: n7 } = _a2, r13 = __objRest(_a2, ["children"]), c8 = e5.useMemo(() => r13, Object.values(r13));
    return e5.createElement(o11.Provider, { value: c8 }, n7);
  }
  return r12.displayName = t12 + "Provider", [r12, function(r13) {
    const c8 = e5.useContext(o11);
    if (c8)
      return c8;
    if (n6 !== void 0)
      return n6;
    throw new Error(`\`${r13}\` must be used within \`${t12}\``);
  }];
}
function createContextScope(n6, o11 = []) {
  let r12 = [];
  const c8 = () => {
    const t12 = r12.map((t13) => /* @__PURE__ */ e5.createContext(t13));
    return function(o12) {
      const r13 = (o12 == null ? void 0 : o12[n6]) || t12;
      return e5.useMemo(() => ({ [`__scope${n6}`]: __spreadProps(__spreadValues({}, o12), { [n6]: r13 }) }), [o12, r13]);
    };
  };
  return c8.scopeName = n6, [function(t12, o12) {
    const c9 = /* @__PURE__ */ e5.createContext(o12), u4 = r12.length;
    function s9(t13) {
      const _a2 = t13, { scope: o13, children: r13 } = _a2, s10 = __objRest(_a2, ["scope", "children"]), i8 = (o13 == null ? void 0 : o13[n6][u4]) || c9, a7 = e5.useMemo(() => s10, Object.values(s10));
      return e5.createElement(i8.Provider, { value: a7 }, r13);
    }
    return r12 = [...r12, o12], s9.displayName = t12 + "Provider", [s9, function(r13, s10) {
      const i8 = (s10 == null ? void 0 : s10[n6][u4]) || c9, a7 = e5.useContext(i8);
      if (a7)
        return a7;
      if (o12 !== void 0)
        return o12;
      throw new Error(`\`${r13}\` must be used within \`${t12}\``);
    }];
  }, t6(c8, ...o11)];
}
function t6(...t12) {
  const n6 = t12[0];
  if (t12.length === 1)
    return n6;
  const o11 = () => {
    const o12 = t12.map((e11) => ({ useScope: e11(), scopeName: e11.scopeName }));
    return function(t13) {
      const r12 = o12.reduce((e11, { useScope: n7, scopeName: o13 }) => __spreadValues(__spreadValues({}, e11), n7(t13)[`__scope${o13}`]), {});
      return e5.useMemo(() => ({ [`__scope${n6.scopeName}`]: r12 }), [r12]);
    };
  };
  return o11.scopeName = n6.scopeName, o11;
}

// ../../node_modules/@radix-ui/react-collection/dist/index.module.js
var import_react13 = __toESM(require_react());
function createCollection(c8) {
  const n6 = c8 + "CollectionProvider", [l9, i8] = createContextScope(n6), [f10, a7] = l9(n6, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }), u4 = (e11) => {
    const { scope: r12, children: t12 } = e11, c9 = import_react13.default.useRef(null), n7 = import_react13.default.useRef(/* @__PURE__ */ new Map()).current;
    return import_react13.default.createElement(f10, { scope: r12, itemMap: n7, collectionRef: c9 }, t12);
  }, m8 = c8 + "CollectionSlot", s9 = /* @__PURE__ */ import_react13.default.forwardRef((t12, c9) => {
    const { scope: n7, children: l10 } = t12, i9 = a7(m8, n7), f11 = useComposedRefs(c9, i9.collectionRef);
    return import_react13.default.createElement(Slot, { ref: f11 }, l10);
  }), p7 = c8 + "CollectionItemSlot", d7 = "data-radix-collection-item", R5 = /* @__PURE__ */ import_react13.default.forwardRef((t12, c9) => {
    const _a2 = t12, { scope: n7, children: l10 } = _a2, i9 = __objRest(_a2, ["scope", "children"]), f11 = import_react13.default.useRef(null), u5 = useComposedRefs(c9, f11), m9 = a7(p7, n7);
    return import_react13.default.useEffect(() => (m9.itemMap.set(f11, __spreadValues({ ref: f11 }, i9)), () => {
      m9.itemMap.delete(f11);
    })), /* @__PURE__ */ import_react13.default.createElement(Slot, { [d7]: "", ref: u5 }, l10);
  });
  return [{ Provider: u4, Slot: s9, ItemSlot: R5 }, function(e11) {
    const r12 = a7(c8 + "CollectionConsumer", e11);
    return import_react13.default.useCallback(() => {
      const e12 = r12.collectionRef.current;
      if (!e12)
        return [];
      const t12 = Array.from(e12.querySelectorAll(`[${d7}]`));
      return Array.from(r12.itemMap.values()).sort((e13, r13) => t12.indexOf(e13.ref.current) - t12.indexOf(r13.ref.current));
    }, [r12.collectionRef, r12.itemMap]);
  }, i8];
}

// ../../node_modules/@radix-ui/primitive/dist/index.module.js
function composeEventHandlers(e11, n6, { checkForDefaultPrevented: t12 = true } = {}) {
  return function(r12) {
    if (e11 == null || e11(r12), t12 === false || !r12.defaultPrevented)
      return n6 == null ? void 0 : n6(r12);
  };
}

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
var s2 = __toESM(require_react());
var f3 = { bubbles: false, cancelable: true };
var [p2, l4, m2] = createCollection("RovingFocusGroup");
var [d2, v2] = createContextScope("RovingFocusGroup", [m2]);
var [g2, F2] = d2("RovingFocusGroup");
var RovingFocusGroup = /* @__PURE__ */ s2.forwardRef((e11, o11) => /* @__PURE__ */ s2.createElement(p2.Provider, { scope: e11.__scopeRovingFocusGroup }, /* @__PURE__ */ s2.createElement(p2.Slot, { scope: e11.__scopeRovingFocusGroup }, /* @__PURE__ */ s2.createElement(w2, _extends2({}, e11, { ref: o11 })))));
var w2 = /* @__PURE__ */ s2.forwardRef((t12, n6) => {
  const _a2 = t12, { __scopeRovingFocusGroup: c8, orientation: p7, dir: m8 = "ltr", loop: d7 = false, currentTabStopId: v6, defaultCurrentTabStopId: F5, onCurrentTabStopIdChange: w6, onEntryFocus: b7 } = _a2, x6 = __objRest(_a2, ["__scopeRovingFocusGroup", "orientation", "dir", "loop", "currentTabStopId", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus"]), E7 = s2.useRef(null), I4 = useComposedRefs(n6, E7), [G4 = null, h4] = useControllableState({ prop: v6, defaultProp: F5, onChange: w6 }), [T5, A3] = s2.useState(false), y5 = useCallbackRef(b7), D5 = l4(c8), S3 = s2.useRef(false);
  return s2.useEffect(() => {
    const e11 = E7.current;
    if (e11)
      return e11.addEventListener("rovingFocusGroup.onEntryFocus", y5), () => e11.removeEventListener("rovingFocusGroup.onEntryFocus", y5);
  }, [y5]), /* @__PURE__ */ s2.createElement(g2, { scope: c8, orientation: p7, dir: m8, loop: d7, currentTabStopId: G4, onItemFocus: s2.useCallback((e11) => h4(e11), [h4]), onItemShiftTab: s2.useCallback(() => A3(true), []) }, /* @__PURE__ */ s2.createElement(Primitive.div, _extends2({ tabIndex: T5 ? -1 : 0, "data-orientation": p7 }, x6, { ref: I4, style: __spreadValues({ outline: "none" }, t12.style), onMouseDown: composeEventHandlers(t12.onMouseDown, () => {
    S3.current = true;
  }), onFocus: composeEventHandlers(t12.onFocus, (e11) => {
    const o11 = !S3.current;
    if (e11.target === e11.currentTarget && o11 && !T5) {
      const o12 = new Event("rovingFocusGroup.onEntryFocus", f3);
      if (e11.currentTarget.dispatchEvent(o12), !o12.defaultPrevented) {
        const e12 = D5().filter((e13) => e13.focusable);
        R2([e12.find((e13) => e13.active), e12.find((e13) => e13.id === G4), ...e12].filter(Boolean).map((e13) => e13.ref.current));
      }
    }
    S3.current = false;
  }), onBlur: composeEventHandlers(t12.onBlur, () => A3(false)) })));
});
var RovingFocusGroupItem = /* @__PURE__ */ s2.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeRovingFocusGroup: n6, focusable: i8 = true, active: c8 = false } = _a2, f10 = __objRest(_a2, ["__scopeRovingFocusGroup", "focusable", "active"]), m8 = useId(), d7 = F2("RovingFocusGroupItem", n6), v6 = d7.currentTabStopId === m8, g6 = l4(n6);
  return s2.createElement(p2.ItemSlot, { scope: n6, id: m8, focusable: i8, active: c8 }, /* @__PURE__ */ s2.createElement(Primitive.span, _extends2({ tabIndex: v6 ? 0 : -1, "data-orientation": d7.orientation }, f10, { ref: o11, onMouseDown: composeEventHandlers(e11.onMouseDown, (e12) => {
    i8 ? d7.onItemFocus(m8) : e12.preventDefault();
  }), onFocus: composeEventHandlers(e11.onFocus, () => d7.onItemFocus(m8)), onKeyDown: composeEventHandlers(e11.onKeyDown, (e12) => {
    if (e12.key === "Tab" && e12.shiftKey)
      return void d7.onItemShiftTab();
    if (e12.target !== e12.currentTarget)
      return;
    const o12 = function(e13, o13, r13) {
      const t13 = function(e14, o14) {
        return o14 !== "rtl" ? e14 : e14 === "ArrowLeft" ? "ArrowRight" : e14 === "ArrowRight" ? "ArrowLeft" : e14;
      }(e13.key, r13);
      return o13 === "vertical" && ["ArrowLeft", "ArrowRight"].includes(t13) || o13 === "horizontal" && ["ArrowUp", "ArrowDown"].includes(t13) ? void 0 : b2[t13];
    }(e12, d7.orientation, d7.dir);
    if (o12 !== void 0) {
      e12.preventDefault();
      let n7 = g6().filter((e13) => e13.focusable).map((e13) => e13.ref.current);
      if (o12 === "last")
        n7.reverse();
      else if (o12 === "prev" || o12 === "next") {
        o12 === "prev" && n7.reverse();
        const i9 = n7.indexOf(e12.currentTarget);
        n7 = d7.loop ? (t12 = i9 + 1, (r12 = n7).map((e13, o13) => r12[(t12 + o13) % r12.length])) : n7.slice(i9 + 1);
      }
      setTimeout(() => R2(n7));
    }
    var r12, t12;
  }) })));
});
var b2 = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" };
function R2(e11) {
  const o11 = document.activeElement;
  for (const r12 of e11) {
    if (r12 === o11)
      return;
    if (r12.focus(), document.activeElement !== o11)
      return;
  }
}
var Root = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// ../../node_modules/@radix-ui/react-portal/dist/index.module.js
var import_react_dom2 = __toESM(require_react_dom());
var r4 = __toESM(require_react());
var Portal = /* @__PURE__ */ r4.forwardRef((a7, i8) => {
  var n6, d7;
  const _a2 = a7, { containerRef: s9, style: u4 } = _a2, c8 = __objRest(_a2, ["containerRef", "style"]), m8 = (n6 = s9 == null ? void 0 : s9.current) !== null && n6 !== void 0 ? n6 : globalThis === null || globalThis === void 0 || (d7 = globalThis.document) === null || d7 === void 0 ? void 0 : d7.body, [, f10] = r4.useState({});
  return useLayoutEffect8(() => {
    f10({});
  }, []), m8 ? /* @__PURE__ */ import_react_dom2.default.createPortal(/* @__PURE__ */ r4.createElement(Primitive.div, _extends2({ "data-radix-portal": "" }, c8, { ref: i8, style: m8 === document.body ? __spreadValues({ position: "absolute", top: 0, left: 0, zIndex: 2147483647 }, u4) : void 0 })), m8) : null;
});
var UnstablePortal = /* @__PURE__ */ r4.forwardRef((t12, a7) => {
  var i8;
  const _a2 = t12, { container: n6 = globalThis === null || globalThis === void 0 || (i8 = globalThis.document) === null || i8 === void 0 ? void 0 : i8.body } = _a2, d7 = __objRest(_a2, ["container"]);
  return n6 ? /* @__PURE__ */ import_react_dom2.default.createPortal(/* @__PURE__ */ r4.createElement(Primitive.div, _extends2({}, d7, { ref: a7 })), n6) : null;
});

// ../../node_modules/@radix-ui/react-arrow/dist/index.module.js
var r5 = __toESM(require_react());
var Arrow = /* @__PURE__ */ r5.forwardRef((o11, i8) => {
  const _a2 = o11, { children: n6, width: s9 = 10, height: m8 = 5 } = _a2, p7 = __objRest(_a2, ["children", "width", "height"]);
  return r5.createElement(Primitive.svg, _extends2({}, p7, { ref: i8, width: s9, height: m8, viewBox: "0 0 30 10", preserveAspectRatio: "none" }), o11.asChild ? n6 : /* @__PURE__ */ r5.createElement("polygon", { points: "0,0 30,0 15,10" }));
});
var Root2 = Arrow;

// ../../node_modules/@radix-ui/react-use-size/dist/index.module.js
var e7 = __toESM(require_react());
function useSize(r12) {
  const [i8, t12] = e7.useState(void 0);
  return e7.useEffect(() => {
    if (r12) {
      const e11 = new ResizeObserver((e12) => {
        if (!Array.isArray(e12))
          return;
        if (!e12.length)
          return;
        const i9 = e12[0];
        let o11, n6;
        if ("borderBoxSize" in i9) {
          const e13 = i9.borderBoxSize, r13 = Array.isArray(e13) ? e13[0] : e13;
          o11 = r13.inlineSize, n6 = r13.blockSize;
        } else {
          const e13 = r12.getBoundingClientRect();
          o11 = e13.width, n6 = e13.height;
        }
        t12({ width: o11, height: n6 });
      });
      return e11.observe(r12, { box: "border-box" }), () => {
        t12(void 0), e11.unobserve(r12);
      };
    }
  }, [r12]), i8;
}

// ../../node_modules/@radix-ui/rect/dist/index.module.js
function observeElementRect(n6, o11) {
  const i8 = e8.get(n6);
  return i8 === void 0 ? (e8.set(n6, { rect: {}, callbacks: [o11] }), e8.size === 1 && (t7 = requestAnimationFrame(c2))) : (i8.callbacks.push(o11), o11(n6.getBoundingClientRect())), () => {
    const c8 = e8.get(n6);
    if (c8 === void 0)
      return;
    const i9 = c8.callbacks.indexOf(o11);
    i9 > -1 && c8.callbacks.splice(i9, 1), c8.callbacks.length === 0 && (e8.delete(n6), e8.size === 0 && cancelAnimationFrame(t7));
  };
}
var t7;
var e8 = /* @__PURE__ */ new Map();
function c2() {
  const n6 = [];
  e8.forEach((t12, e11) => {
    const c8 = e11.getBoundingClientRect();
    var o11, i8;
    o11 = t12.rect, i8 = c8, (o11.width !== i8.width || o11.height !== i8.height || o11.top !== i8.top || o11.right !== i8.right || o11.bottom !== i8.bottom || o11.left !== i8.left) && (t12.rect = c8, n6.push(t12));
  }), n6.forEach((t12) => {
    t12.callbacks.forEach((e11) => e11(t12.rect));
  }), t7 = requestAnimationFrame(c2);
}

// ../../node_modules/@radix-ui/react-use-rect/dist/index.module.js
var r6 = __toESM(require_react());
function useRect(e11) {
  const [o11, c8] = r6.useState();
  return r6.useEffect(() => {
    if (e11) {
      const r12 = observeElementRect(e11, c8);
      return () => {
        c8(void 0), r12();
      };
    }
  }, [e11]), o11;
}

// ../../node_modules/@radix-ui/popper/dist/index.module.js
function getPlacementData({ anchorRect: p7, popperSize: c8, arrowSize: f10, arrowOffset: l9 = 0, side: d7, sideOffset: h4 = 0, align: x6, alignOffset: g6 = 0, shouldAvoidCollisions: u4 = true, collisionBoundariesRect: w6, collisionTolerance: m8 = 0 }) {
  if (!p7 || !c8 || !w6)
    return { popperStyles: o8, arrowStyles: n3 };
  const y5 = function(e11, r12, o11 = 0, n6 = 0, i8) {
    const p8 = i8 ? i8.height : 0, a7 = t8(r12, e11, "x"), s9 = t8(r12, e11, "y"), c9 = s9.before - o11 - p8, f11 = s9.after + o11 + p8, l10 = a7.before - o11 - p8, d8 = a7.after + o11 + p8;
    return { top: { start: { x: a7.start + n6, y: c9 }, center: { x: a7.center, y: c9 }, end: { x: a7.end - n6, y: c9 } }, right: { start: { x: d8, y: s9.start + n6 }, center: { x: d8, y: s9.center }, end: { x: d8, y: s9.end - n6 } }, bottom: { start: { x: a7.start + n6, y: f11 }, center: { x: a7.center, y: f11 }, end: { x: a7.end - n6, y: f11 } }, left: { start: { x: l10, y: s9.start + n6 }, center: { x: l10, y: s9.center }, end: { x: l10, y: s9.end - n6 } } };
  }(c8, p7, h4, g6, f10), b7 = y5[d7][x6];
  if (u4 === false) {
    const t12 = e9(b7);
    let o11 = n3;
    f10 && (o11 = i3({ popperSize: c8, arrowSize: f10, arrowOffset: l9, side: d7, align: x6 }));
    return { popperStyles: __spreadProps(__spreadValues({}, t12), { "--radix-popper-transform-origin": r7(c8, d7, x6, l9, f10) }), arrowStyles: o11, placedSide: d7, placedAlign: x6 };
  }
  const S3 = DOMRect.fromRect(__spreadValues(__spreadValues({}, c8), b7)), $2 = (O4 = w6, z3 = m8, DOMRect.fromRect({ width: O4.width - 2 * z3, height: O4.height - 2 * z3, x: O4.left + z3, y: O4.top + z3 }));
  var O4, z3;
  const R5 = s3(S3, $2), M3 = y5[a3(d7)][x6], D5 = function(t12, e11, r12) {
    const o11 = a3(t12);
    return e11[t12] && !r12[o11] ? o11 : t12;
  }(d7, R5, s3(DOMRect.fromRect(__spreadValues(__spreadValues({}, c8), M3)), $2)), A3 = function(t12, e11, r12, o11, n6) {
    const i8 = r12 === "top" || r12 === "bottom", p8 = i8 ? "left" : "top", a7 = i8 ? "right" : "bottom", s9 = i8 ? "width" : "height", c9 = e11[s9] > t12[s9];
    if ((o11 === "start" || o11 === "center") && (n6[p8] && c9 || n6[a7] && !c9))
      return "end";
    if ((o11 === "end" || o11 === "center") && (n6[a7] && c9 || n6[p8] && !c9))
      return "start";
    return o11;
  }(c8, p7, d7, x6, R5), I4 = e9(y5[D5][A3]);
  let C6 = n3;
  f10 && (C6 = i3({ popperSize: c8, arrowSize: f10, arrowOffset: l9, side: D5, align: A3 }));
  return { popperStyles: __spreadProps(__spreadValues({}, I4), { "--radix-popper-transform-origin": r7(c8, D5, A3, l9, f10) }), arrowStyles: C6, placedSide: D5, placedAlign: A3 };
}
function t8(t12, e11, r12) {
  const o11 = t12[r12 === "x" ? "left" : "top"], n6 = r12 === "x" ? "width" : "height", i8 = t12[n6], p7 = e11[n6];
  return { before: o11 - p7, start: o11, center: o11 + (i8 - p7) / 2, end: o11 + i8 - p7, after: o11 + i8 };
}
function e9(t12) {
  return { position: "absolute", top: 0, left: 0, minWidth: "max-content", willChange: "transform", transform: `translate3d(${Math.round(t12.x + window.scrollX)}px, ${Math.round(t12.y + window.scrollY)}px, 0)` };
}
function r7(t12, e11, r12, o11, n6) {
  const i8 = e11 === "top" || e11 === "bottom", p7 = n6 ? n6.width : 0, a7 = n6 ? n6.height : 0, s9 = p7 / 2 + o11;
  let c8 = "", f10 = "";
  return i8 ? (c8 = { start: `${s9}px`, center: "center", end: t12.width - s9 + "px" }[r12], f10 = e11 === "top" ? `${t12.height + a7}px` : -a7 + "px") : (c8 = e11 === "left" ? `${t12.width + a7}px` : -a7 + "px", f10 = { start: `${s9}px`, center: "center", end: t12.height - s9 + "px" }[r12]), `${c8} ${f10}`;
}
var o8 = { position: "fixed", top: 0, left: 0, opacity: 0, transform: "translate3d(0, -200%, 0)" };
var n3 = { position: "absolute", opacity: 0 };
function i3({ popperSize: t12, arrowSize: e11, arrowOffset: r12, side: o11, align: n6 }) {
  const i8 = (t12.width - e11.width) / 2, a7 = (t12.height - e11.width) / 2, s9 = { top: 0, right: 90, bottom: 180, left: -90 }[o11], c8 = Math.max(e11.width, e11.height), f10 = { width: `${c8}px`, height: `${c8}px`, transform: `rotate(${s9}deg)`, willChange: "transform", position: "absolute", [o11]: "100%", direction: p3(o11, n6) };
  return o11 !== "top" && o11 !== "bottom" || (n6 === "start" && (f10.left = `${r12}px`), n6 === "center" && (f10.left = `${i8}px`), n6 === "end" && (f10.right = `${r12}px`)), o11 !== "left" && o11 !== "right" || (n6 === "start" && (f10.top = `${r12}px`), n6 === "center" && (f10.top = `${a7}px`), n6 === "end" && (f10.bottom = `${r12}px`)), f10;
}
function p3(t12, e11) {
  return (t12 !== "top" && t12 !== "right" || e11 !== "end") && (t12 !== "bottom" && t12 !== "left" || e11 === "end") ? "ltr" : "rtl";
}
function a3(t12) {
  return { top: "bottom", right: "left", bottom: "top", left: "right" }[t12];
}
function s3(t12, e11) {
  return { top: t12.top < e11.top, right: t12.right > e11.right, bottom: t12.bottom > e11.bottom, left: t12.left < e11.left };
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
var s4 = __toESM(require_react());
var [c3, l5] = createContextScope("Popper");
var [f4, d3] = c3("Popper");
var Popper = (e11) => {
  const { __scopePopper: o11, children: r12 } = e11, [t12, n6] = s4.useState(null);
  return s4.createElement(f4, { scope: o11, anchor: t12, onAnchorChange: n6 }, r12);
};
var PopperAnchor = /* @__PURE__ */ s4.forwardRef((e11, r12) => {
  const _a2 = e11, { __scopePopper: t12, virtualRef: n6 } = _a2, p7 = __objRest(_a2, ["__scopePopper", "virtualRef"]), c8 = d3("PopperAnchor", t12), l9 = s4.useRef(null), f10 = useComposedRefs(r12, l9);
  return s4.useEffect(() => {
    c8.onAnchorChange((n6 == null ? void 0 : n6.current) || l9.current);
  }), n6 ? null : /* @__PURE__ */ s4.createElement(Primitive.div, _extends2({}, p7, { ref: f10 }));
});
var [u2, m3] = c3("PopperContent");
var PopperContent = /* @__PURE__ */ s4.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopePopper: c8, side: l9 = "bottom", sideOffset: f10, align: m8 = "center", alignOffset: w6, collisionTolerance: h4, avoidCollisions: x6 = true } = _a2, v6 = __objRest(_a2, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "collisionTolerance", "avoidCollisions"]), P3 = d3("PopperContent", c8), [A3, g6] = s4.useState(), E7 = useRect(P3.anchor), [y5, C6] = s4.useState(null), S3 = useSize(y5), [R5, O4] = s4.useState(null), _5 = useSize(R5), b7 = useComposedRefs(n6, (e12) => C6(e12)), z3 = function() {
    const [e12, o11] = s4.useState(void 0);
    return s4.useEffect(() => {
      let e13;
      function r12() {
        o11({ width: window.innerWidth, height: window.innerHeight });
      }
      function t12() {
        window.clearTimeout(e13), e13 = window.setTimeout(r12, 100);
      }
      return r12(), window.addEventListener("resize", t12), () => window.removeEventListener("resize", t12);
    }, []), e12;
  }(), T5 = z3 ? DOMRect.fromRect(__spreadProps(__spreadValues({}, z3), { x: 0, y: 0 })) : void 0, { popperStyles: k4, arrowStyles: L4, placedSide: B4, placedAlign: D5 } = getPlacementData({ anchorRect: E7, popperSize: S3, arrowSize: _5, arrowOffset: A3, side: l9, sideOffset: f10, align: m8, alignOffset: w6, shouldAvoidCollisions: x6, collisionBoundariesRect: T5, collisionTolerance: h4 }), H4 = B4 !== void 0;
  return s4.createElement("div", { style: k4, "data-radix-popper-content-wrapper": "" }, /* @__PURE__ */ s4.createElement(u2, { scope: c8, arrowStyles: L4, onArrowChange: O4, onArrowOffsetChange: g6 }, /* @__PURE__ */ s4.createElement(Primitive.div, _extends2({ "data-side": B4, "data-align": D5 }, v6, { style: __spreadProps(__spreadValues({}, v6.style), { animation: H4 ? void 0 : "none" }), ref: b7 }))));
});
var PopperArrow = /* @__PURE__ */ s4.forwardRef(function(o11, r12) {
  const _a2 = o11, { __scopePopper: t12, offset: n6 } = _a2, i8 = __objRest(_a2, ["__scopePopper", "offset"]), p7 = m3("PopperArrow", t12), { onArrowOffsetChange: c8 } = p7;
  return s4.useEffect(() => c8(n6), [c8, n6]), /* @__PURE__ */ s4.createElement("span", { style: __spreadProps(__spreadValues({}, p7.arrowStyles), { pointerEvents: "none" }) }, /* @__PURE__ */ s4.createElement("span", { ref: p7.onArrowChange, style: { display: "inline-block", verticalAlign: "top", pointerEvents: "auto" } }, /* @__PURE__ */ s4.createElement(Root2, _extends2({}, i8, { ref: r12, style: __spreadProps(__spreadValues({}, i8.style), { display: "block" }) }))));
});
var Root3 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// ../../node_modules/@radix-ui/react-presence/dist/index.module.js
var t9 = __toESM(require_react());
var Presence = (u4) => {
  const { present: o11, children: i8 } = u4, s9 = function(n6) {
    const [u5, o12] = t9.useState(), i9 = t9.useRef({}), s10 = t9.useRef(n6), c9 = t9.useRef("none"), a8 = n6 ? "mounted" : "unmounted", [d7, m8] = function(e11, n7) {
      return t9.useReducer((e12, t12) => {
        const r12 = n7[e12][t12];
        return r12 != null ? r12 : e12;
      }, e11);
    }(a8, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } });
    return t9.useEffect(() => {
      const e11 = r8(i9.current);
      c9.current = d7 === "mounted" ? e11 : "none";
    }, [d7]), useLayoutEffect8(() => {
      const e11 = i9.current, t12 = s10.current;
      if (t12 !== n6) {
        const u6 = c9.current, o13 = r8(e11);
        if (n6)
          m8("MOUNT");
        else if (o13 === "none" || (e11 == null ? void 0 : e11.display) === "none")
          m8("UNMOUNT");
        else {
          const e12 = u6 !== o13;
          m8(t12 && e12 ? "ANIMATION_OUT" : "UNMOUNT");
        }
        s10.current = n6;
      }
    }, [n6, m8]), useLayoutEffect8(() => {
      if (u5) {
        const e11 = (e12) => {
          const n8 = r8(i9.current).includes(e12.animationName);
          e12.target === u5 && n8 && m8("ANIMATION_END");
        }, n7 = (e12) => {
          e12.target === u5 && (c9.current = r8(i9.current));
        };
        return u5.addEventListener("animationstart", n7), u5.addEventListener("animationcancel", e11), u5.addEventListener("animationend", e11), () => {
          u5.removeEventListener("animationstart", n7), u5.removeEventListener("animationcancel", e11), u5.removeEventListener("animationend", e11);
        };
      }
    }, [u5, m8]), { isPresent: ["mounted", "unmountSuspended"].includes(d7), ref: t9.useCallback((e11) => {
      e11 && (i9.current = getComputedStyle(e11)), o12(e11);
    }, []) };
  }(o11), c8 = typeof i8 == "function" ? i8({ present: s9.isPresent }) : t9.Children.only(i8), a7 = useComposedRefs(s9.ref, c8.ref);
  return typeof i8 == "function" || s9.isPresent ? /* @__PURE__ */ t9.cloneElement(c8, { ref: a7 }) : null;
};
function r8(e11) {
  return (e11 == null ? void 0 : e11.animationName) || "none";
}
Presence.displayName = "Presence";

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
var o9 = __toESM(require_react());
var c4 = { bubbles: false, cancelable: true };
var FocusScope = /* @__PURE__ */ o9.forwardRef((i8, f10) => {
  const _a2 = i8, { loop: l9 = false, trapped: m8 = false, onMountAutoFocus: p7, onUnmountAutoFocus: v6 } = _a2, E7 = __objRest(_a2, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]), [F5, S3] = o9.useState(null), b7 = useCallbackRef(p7), T5 = useCallbackRef(v6), y5 = o9.useRef(null), L4 = useComposedRefs(f10, (e11) => S3(e11)), h4 = o9.useRef({ paused: false, pause() {
    this.paused = true;
  }, resume() {
    this.paused = false;
  } }).current;
  o9.useEffect(() => {
    if (m8) {
      let e11 = function(e12) {
        if (h4.paused || !F5)
          return;
        const t13 = e12.target;
        F5.contains(t13) ? y5.current = t13 : a4(y5.current, { select: true });
      }, t12 = function(e12) {
        !h4.paused && F5 && (F5.contains(e12.relatedTarget) || a4(y5.current, { select: true }));
      };
      return document.addEventListener("focusin", e11), document.addEventListener("focusout", t12), () => {
        document.removeEventListener("focusin", e11), document.removeEventListener("focusout", t12);
      };
    }
  }, [m8, F5, h4.paused]), o9.useEffect(() => {
    if (F5) {
      d4.add(h4);
      const t12 = document.activeElement;
      if (!F5.contains(t12)) {
        const n6 = new Event("focusScope.autoFocusOnMount", c4);
        F5.addEventListener("focusScope.autoFocusOnMount", b7), F5.dispatchEvent(n6), n6.defaultPrevented || (!function(e12, { select: t13 = false } = {}) {
          const n7 = document.activeElement;
          for (const o11 of e12)
            if (a4(o11, { select: t13 }), document.activeElement !== n7)
              return;
        }((e11 = r9(F5), e11.filter((e12) => e12.tagName !== "A")), { select: true }), document.activeElement === t12 && a4(F5));
      }
      return () => {
        F5.removeEventListener("focusScope.autoFocusOnMount", b7), setTimeout(() => {
          const e12 = new Event("focusScope.autoFocusOnUnmount", c4);
          F5.addEventListener("focusScope.autoFocusOnUnmount", T5), F5.dispatchEvent(e12), e12.defaultPrevented || a4(t12 != null ? t12 : document.body, { select: true }), F5.removeEventListener("focusScope.autoFocusOnUnmount", T5), d4.remove(h4);
        }, 0);
      };
    }
    var e11;
  }, [F5, b7, T5, h4]);
  const N2 = o9.useCallback((e11) => {
    if (!l9 && !m8)
      return;
    if (h4.paused)
      return;
    const t12 = e11.key === "Tab" && !e11.altKey && !e11.ctrlKey && !e11.metaKey, n6 = document.activeElement;
    if (t12 && n6) {
      const t13 = e11.currentTarget, [o11, u4] = function(e12) {
        const t14 = r9(e12), n7 = s5(t14, e12), o12 = s5(t14.reverse(), e12);
        return [n7, o12];
      }(t13);
      o11 && u4 ? e11.shiftKey || n6 !== u4 ? e11.shiftKey && n6 === o11 && (e11.preventDefault(), l9 && a4(u4, { select: true })) : (e11.preventDefault(), l9 && a4(o11, { select: true })) : n6 === t13 && e11.preventDefault();
    }
  }, [l9, m8, h4.paused]);
  return o9.createElement(Primitive.div, _extends2({ tabIndex: -1 }, E7, { ref: L4, onKeyDown: N2 }));
});
function r9(e11) {
  const t12 = [], n6 = document.createTreeWalker(e11, NodeFilter.SHOW_ELEMENT, { acceptNode: (e12) => {
    const t13 = e12.tagName === "INPUT" && e12.type === "hidden";
    return e12.disabled || e12.hidden || t13 ? NodeFilter.FILTER_SKIP : e12.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n6.nextNode(); )
    t12.push(n6.currentNode);
  return t12;
}
function s5(e11, t12) {
  for (const n6 of e11)
    if (!i4(n6, { upTo: t12 }))
      return n6;
}
function i4(e11, { upTo: t12 }) {
  if (getComputedStyle(e11).visibility === "hidden")
    return true;
  for (; e11; ) {
    if (t12 !== void 0 && e11 === t12)
      return false;
    if (getComputedStyle(e11).display === "none")
      return true;
    e11 = e11.parentElement;
  }
  return false;
}
function a4(e11, { select: t12 = false } = {}) {
  if (e11 && e11.focus) {
    const n6 = document.activeElement;
    e11.focus({ preventScroll: true }), e11 !== n6 && function(e12) {
      return e12 instanceof HTMLInputElement && "select" in e12;
    }(e11) && t12 && e11.select();
  }
}
var d4 = function() {
  let e11 = [];
  return { add(t12) {
    const n6 = e11[0];
    t12 !== n6 && (n6 == null || n6.pause()), e11 = f5(e11, t12), e11.unshift(t12);
  }, remove(t12) {
    var n6;
    e11 = f5(e11, t12), (n6 = e11[0]) === null || n6 === void 0 || n6.resume();
  } };
}();
function f5(e11, t12) {
  const n6 = [...e11], o11 = n6.indexOf(t12);
  return o11 !== -1 && n6.splice(o11, 1), n6;
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
var t10 = __toESM(require_react());
function useEscapeKeydown(n6) {
  const o11 = useCallbackRef(n6);
  t10.useEffect(() => {
    const e11 = (e12) => {
      e12.key === "Escape" && o11(e12);
    };
    return document.addEventListener("keydown", e11), () => document.removeEventListener("keydown", e11);
  }, [o11]);
}

// ../../node_modules/@radix-ui/react-use-body-pointer-events/dist/index.module.js
var t11 = __toESM(require_react());
var n4;
var o10 = 0;
function useBodyPointerEvents({ disabled: r12 }) {
  const u4 = t11.useRef(false), c8 = t11.useRef(false);
  t11.useEffect(() => {
    const e11 = (e12) => {
      const t13 = e12.pointerType === "mouse";
      u4.current = !t13, c8.current = t13 && e12.button === 0;
    }, t12 = () => {
      u4.current = false, c8.current = false;
    };
    return document.addEventListener("pointerdown", e11), document.addEventListener("pointerup", t12), () => {
      document.removeEventListener("pointerdown", e11), document.removeEventListener("pointerup", t12);
    };
  }, []), useLayoutEffect8(() => {
    if (r12) {
      let e11 = function() {
        o10--, o10 === 0 && (document.body.style.pointerEvents = n4);
      };
      return o10 === 0 && (n4 = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", o10++, () => {
        u4.current ? document.addEventListener("click", e11, { once: true }) : c8.current ? document.addEventListener("pointerup", e11, { once: true }) : e11();
      };
    }
  }, [r12]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var i5 = __toESM(require_react());
var [a5, c5] = C2();
var [l6, d5] = b3();
var [m4, f6] = C2("TotalLayerCountWithDisabledOutsidePointerEventsProvider");
var [p4, v3] = b3("RunningLayerCountWithDisabledOutsidePointerEventsProvider");
var DismissableLayer = /* @__PURE__ */ i5.forwardRef((e11, t12) => {
  const n6 = d5() === 0, r12 = /* @__PURE__ */ i5.createElement(E2, _extends2({}, e11, { ref: t12 }));
  return n6 ? /* @__PURE__ */ i5.createElement(a5, null, /* @__PURE__ */ i5.createElement(m4, null, r12)) : r12;
});
var E2 = /* @__PURE__ */ i5.forwardRef((r12, a7) => {
  const _a2 = r12, { disableOutsidePointerEvents: m8 = false, onEscapeKeyDown: E7, onPointerDownOutside: C6, onFocusOutside: b7, onInteractOutside: w6, onDismiss: L4 } = _a2, y5 = __objRest(_a2, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]), D5 = c5(), P3 = d5() + 1, T5 = P3 === D5, g6 = f6(m8), x6 = v3() + (m8 ? 1 : 0), O4 = x6 < g6;
  useBodyPointerEvents({ disabled: m8 }), useEscapeKeydown((e11) => {
    T5 && (E7 == null || E7(e11), e11.defaultPrevented || L4 == null || L4());
  });
  const { onPointerDownCapture: R5 } = function(e11) {
    const n6 = useCallbackRef(e11), r13 = i5.useRef(false);
    return i5.useEffect(() => {
      const e12 = (e13) => {
        const t13 = e13.target;
        if (t13 && !r13.current) {
          const r14 = new CustomEvent("dismissableLayer.pointerDownOutside", { bubbles: false, cancelable: true, detail: { originalEvent: e13 } });
          t13.addEventListener("dismissableLayer.pointerDownOutside", n6, { once: true }), t13.dispatchEvent(r14);
        }
        r13.current = false;
      }, t12 = window.setTimeout(() => {
        document.addEventListener("pointerdown", e12);
      }, 0);
      return () => {
        window.clearTimeout(t12), document.removeEventListener("pointerdown", e12);
      };
    }, [n6]), { onPointerDownCapture: () => r13.current = true };
  }((e11) => {
    O4 || (C6 == null || C6(e11), w6 == null || w6(e11), e11.defaultPrevented || L4 == null || L4());
  }), { onBlurCapture: h4, onFocusCapture: F5 } = function(e11) {
    const n6 = useCallbackRef(e11), r13 = i5.useRef(false);
    return i5.useEffect(() => {
      const e12 = (e13) => {
        const t12 = e13.target;
        if (t12 && !r13.current) {
          const r14 = new CustomEvent("dismissableLayer.focusOutside", { bubbles: false, cancelable: true, detail: { originalEvent: e13 } });
          t12.addEventListener("dismissableLayer.focusOutside", n6, { once: true }), t12.dispatchEvent(r14);
        }
      };
      return document.addEventListener("focusin", e12), () => document.removeEventListener("focusin", e12);
    }, [n6]), { onFocusCapture: () => r13.current = true, onBlurCapture: () => r13.current = false };
  }((e11) => {
    b7 == null || b7(e11), w6 == null || w6(e11), e11.defaultPrevented || L4 == null || L4();
  }), k4 = g6 > 0 && !O4;
  return i5.createElement(l6, { runningCount: P3 }, /* @__PURE__ */ i5.createElement(p4, { runningCount: x6 }, /* @__PURE__ */ i5.createElement(Primitive.div, _extends2({}, y5, { ref: a7, style: __spreadValues({ pointerEvents: k4 ? "auto" : void 0 }, y5.style), onPointerDownCapture: composeEventHandlers(r12.onPointerDownCapture, R5), onBlurCapture: composeEventHandlers(r12.onBlurCapture, h4), onFocusCapture: composeEventHandlers(r12.onFocusCapture, F5) }))));
});
function C2(e11) {
  const [t12, n6] = createContext3("TotalLayerCount", { total: 0, onTotalIncrease: () => {
  }, onTotalDecrease: () => {
  } }), o11 = ({ children: e12 }) => {
    const [n7, r12] = i5.useState(0);
    return i5.createElement(t12, { total: n7, onTotalIncrease: i5.useCallback(() => r12((e13) => e13 + 1), []), onTotalDecrease: i5.useCallback(() => r12((e13) => e13 - 1), []) }, e12);
  };
  return [o11, function(e12 = true) {
    const { total: t13, onTotalIncrease: r12, onTotalDecrease: o12 } = n6("TotalLayerCountConsumer");
    return i5.useLayoutEffect(() => {
      if (e12)
        return r12(), () => o12();
    }, [e12, r12, o12]), t13;
  }];
}
function b3(e11) {
  const [t12, n6] = createContext3("RunningLayerCount", { count: 0 }), o11 = (e12) => {
    const { children: n7, runningCount: r12 } = e12;
    return i5.createElement(t12, { count: r12 }, n7);
  };
  return [o11, function() {
    return n6("RunningLayerCountConsumer").count || 0;
  }];
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (parentNode === void 0) {
    parentNode = getDefaultParent(originalTarget);
  }
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute("aria-hidden");
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute("aria-hidden", "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute("aria-hidden");
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};

// ../../node_modules/react-remove-scroll/node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign: __assign2,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values: __values2,
  __read: __read2,
  __spread,
  __spreadArrays,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React52 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var React48 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-sidecar/node_modules/tslib/modules/index.js
var import_tslib2 = __toESM(require_tslib2(), 1);
var {
  __extends: __extends2,
  __assign: __assign3,
  __rest: __rest2,
  __decorate: __decorate2,
  __param: __param2,
  __metadata: __metadata2,
  __awaiter: __awaiter2,
  __generator: __generator2,
  __exportStar: __exportStar2,
  __createBinding: __createBinding2,
  __values: __values3,
  __read: __read3,
  __spread: __spread2,
  __spreadArrays: __spreadArrays2,
  __await: __await2,
  __asyncGenerator: __asyncGenerator2,
  __asyncDelegator: __asyncDelegator2,
  __asyncValues: __asyncValues2,
  __makeTemplateObject: __makeTemplateObject2,
  __importStar: __importStar2,
  __importDefault: __importDefault2,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2
} = import_tslib2.default;

// ../../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a7) {
  return a7;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x6) {
          return x6 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x6) {
          return cb(x6);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x6) {
          pendingQueue.push(x6);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign3({ async: true, ssr: false }, options2);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
var React47 = __toESM(require_react());
var SideCar = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest2(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React47.createElement(Target, __assign3({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react14 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react14.useState)(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef2(defaultValue, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React48.forwardRef(function(props, parentRef) {
  var ref = React48.useRef(null);
  var _a2 = React48.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container3 = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([
    ref,
    parentRef
  ]);
  var containerProps = __assign2({}, rest, callbacks);
  return React48.createElement(React48.Fragment, null, enabled && React48.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }), forwardProps ? React48.cloneElement(React48.Children.only(children), __assign2({}, containerProps, { ref: containerRef })) : React48.createElement(Container3, __assign2({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React51 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React50 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React49 = __toESM(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles3) {
    React49.useEffect(function() {
      sheet.add(styles3);
      return function() {
        sheet.remove();
      };
    }, []);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles3 = _a2.styles;
    useStyle2(styles3);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x6) {
  return parseInt(x6 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [
    parse2(left),
    parse2(top2),
    parse2(right)
  ];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top2 = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  ." + noScrollbarsClassName + " {\n   overflow: hidden " + important + ";\n   padding-right: " + gap + "px " + important + ";\n  }\n  body {\n    overflow: hidden " + important + ";\n    " + [
    allowRelative && "position: relative " + important + ";",
    gapMode === "margin" && "\n    padding-left: " + left + "px;\n    padding-top: " + top2 + "px;\n    padding-right: " + right + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ",
    gapMode === "padding" && "padding-right: " + gap + "px " + important + ";"
  ].filter(Boolean).join("") + "\n  }\n  \n  ." + zeroRightClassName + " {\n    right: " + gap + "px " + important + ";\n  }\n  \n  ." + fullWidthClassName + " {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  ." + zeroRightClassName + " ." + zeroRightClassName + " {\n    right: 0 " + important + ";\n  }\n  \n  ." + fullWidthClassName + " ." + fullWidthClassName + " {\n    margin-right: 0 " + important + ";\n  }\n  \n  body {\n    " + removedBarSizeVariable + ": " + gap + "px;\n  }\n";
};
var RemoveScrollBar = function(props) {
  var _a2 = React50.useState(getGapWidth(props.gapMode)), gap = _a2[0], setGap = _a2[1];
  React50.useEffect(function() {
    setGap(getGapWidth(props.gapMode));
  }, [props.gapMode]);
  var noRelative = props.noRelative, noImportant = props.noImportant, _b = props.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  return React50.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var elementCouldBeVScrolled = function(node) {
  var styles3 = window.getComputedStyle(node);
  return styles3.overflowY !== "hidden" && !(styles3.overflowY === styles3.overflowX && styles3.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node) {
  var styles3 = window.getComputedStyle(node);
  if (node.type === "range") {
    return true;
  }
  return styles3.overflowX !== "hidden" && !(styles3.overflowY === styles3.overflowX && styles3.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s9 = _a2[1], d7 = _a2[2];
      if (s9 > d7) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported = false;
  }
}
var options2;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x6, y5) {
  return x6[0] === y5[0] && x6[1] === y5[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-" + id + " {pointer-events: none;}\n  .allow-interactivity-" + id + " {pointer-events: all;}\n";
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React51.useRef([]);
  var touchStartRef = React51.useRef([0, 0]);
  var activeAxis = React51.useRef();
  var id = React51.useState(idCounter++)[0];
  var Style2 = React51.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React51.useRef(props);
  React51.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React51.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-" + id);
      var allow_1 = [
        props.lockRef.current
      ].concat((props.shards || []).map(extractRef)).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-" + id);
      });
      return function() {
        document.body.classList.remove("block-interactivity-" + id);
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-" + id);
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React51.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React51.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e11) {
      return e11.name === event.type && e11.target === event.target && deltaCompare(e11.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = React51.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e11) {
        return e11 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React51.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React51.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React51.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React51.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React51.createElement(React51.Fragment, null, inert ? React51.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React51.createElement(RemoveScrollBar, { gapMode: "margin" }) : null);
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React52.forwardRef(function(props, ref) {
  return React52.createElement(RemoveScroll, __assign2({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-menu/dist/index.module.js
var E3 = __toESM(require_react());
var x2 = ["Enter", " "];
var b4 = ["ArrowUp", "PageDown", "End"];
var R3 = ["ArrowDown", "PageUp", "Home", ...b4];
var _2 = { ltr: [...x2, "ArrowRight"], rtl: [...x2, "ArrowLeft"] };
var y2 = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] };
var [I2, k2, P2] = createCollection("Menu");
var [D2, S2] = createContextScope("Menu", [P2, l5, v2]);
var O2 = l5();
var T3 = v2();
var [L3, A2] = D2("Menu");
var Menu = (e11) => {
  const { __scopeMenu: t12, open: o11 = false, children: u4, onOpenChange: c8, modal: i8 = true } = e11, s9 = O2(t12), [l9, d7] = E3.useState(null), p7 = E3.useRef(false), f10 = useCallbackRef(c8), m8 = useDirection(l9, e11.dir);
  return E3.useEffect(() => {
    const e12 = () => p7.current = true, t13 = () => p7.current = false;
    return document.addEventListener("keydown", e12, { capture: true }), document.addEventListener("pointerdown", t13, { capture: true }), document.addEventListener("pointermove", t13, { capture: true }), () => {
      document.removeEventListener("keydown", e12, { capture: true }), document.removeEventListener("pointerdown", t13, { capture: true }), document.removeEventListener("pointermove", t13, { capture: true });
    };
  }, []), /* @__PURE__ */ E3.createElement(Root3, s9, /* @__PURE__ */ E3.createElement(L3, { scope: t12, isSubmenu: false, isUsingKeyboardRef: p7, dir: m8, open: o11, onOpenChange: f10, content: l9, onContentChange: d7, onRootClose: E3.useCallback(() => f10(false), [f10]), modal: i8 }, u4));
};
var MenuSub = (t12) => {
  const { __scopeMenu: r12, children: o11, open: u4 = false, onOpenChange: c8 } = t12, i8 = A2("MenuSub", r12), s9 = O2(r12), [l9, d7] = E3.useState(null), [p7, f10] = E3.useState(null), m8 = useCallbackRef(c8);
  return E3.useEffect(() => (i8.open === false && m8(false), () => m8(false)), [i8.open, m8]), /* @__PURE__ */ E3.createElement(Root3, s9, /* @__PURE__ */ E3.createElement(L3, { scope: r12, isSubmenu: true, isUsingKeyboardRef: i8.isUsingKeyboardRef, dir: i8.dir, open: u4, onOpenChange: m8, content: p7, onContentChange: f10, onRootClose: i8.onRootClose, contentId: useId(), trigger: l9, onTriggerChange: d7, triggerId: useId(), modal: false }, o11));
};
var MenuAnchor = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6 } = _a2, r12 = __objRest(_a2, ["__scopeMenu"]), o11 = O2(n6);
  return E3.createElement(Anchor, _extends2({}, o11, r12, { ref: t12 }));
});
var [F3, K2] = D2("MenuContent");
var MenuContent = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { forceMount: n6 } = _a2, r12 = __objRest(_a2, ["forceMount"]), o11 = A2("MenuContent", e11.__scopeMenu);
  return E3.createElement(I2.Provider, { scope: e11.__scopeMenu }, /* @__PURE__ */ E3.createElement(Presence, { present: n6 || o11.open }, /* @__PURE__ */ E3.createElement(I2.Slot, { scope: e11.__scopeMenu }, o11.isSubmenu ? /* @__PURE__ */ E3.createElement(X2, _extends2({}, r12, { ref: t12 })) : /* @__PURE__ */ E3.createElement(G3, _extends2({}, r12, { ref: t12 })))));
});
var G3 = /* @__PURE__ */ E3.forwardRef((e11, t12) => A2("MenuContent", e11.__scopeMenu).modal ? /* @__PURE__ */ E3.createElement(U2, _extends2({}, e11, { ref: t12 })) : /* @__PURE__ */ E3.createElement(V4, _extends2({}, e11, { ref: t12 })));
var U2 = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const n6 = A2("MenuContent", e11.__scopeMenu), r12 = E3.useRef(null), o11 = useComposedRefs(t12, r12);
  return E3.useEffect(() => {
    const e12 = r12.current;
    if (e12)
      return hideOthers(e12);
  }, []), /* @__PURE__ */ E3.createElement(B2, _extends2({}, e11, { ref: o11, trapFocus: n6.open, disableOutsidePointerEvents: n6.open, disableOutsideScroll: true, onFocusOutside: composeEventHandlers(e11.onFocusOutside, (e12) => e12.preventDefault(), { checkForDefaultPrevented: false }), onDismiss: () => n6.onOpenChange(false) }));
});
var V4 = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const n6 = A2("MenuContent", e11.__scopeMenu);
  return E3.createElement(B2, _extends2({}, e11, { ref: t12, trapFocus: false, disableOutsidePointerEvents: false, disableOutsideScroll: false, onDismiss: () => n6.onOpenChange(false) }));
});
var X2 = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const n6 = A2("MenuContent", e11.__scopeMenu), r12 = E3.useRef(null), o11 = useComposedRefs(t12, r12);
  return n6.isSubmenu ? /* @__PURE__ */ E3.createElement(B2, _extends2({ id: n6.contentId, "aria-labelledby": n6.triggerId }, e11, { ref: o11, align: "start", side: n6.dir === "rtl" ? "left" : "right", portalled: true, disableOutsidePointerEvents: false, disableOutsideScroll: false, trapFocus: false, onOpenAutoFocus: (e12) => {
    var t13;
    n6.isUsingKeyboardRef.current && ((t13 = r12.current) === null || t13 === void 0 || t13.focus()), e12.preventDefault();
  }, onCloseAutoFocus: (e12) => e12.preventDefault(), onFocusOutside: composeEventHandlers(e11.onFocusOutside, (e12) => {
    e12.target !== n6.trigger && n6.onOpenChange(false);
  }), onEscapeKeyDown: composeEventHandlers(e11.onEscapeKeyDown, n6.onRootClose), onKeyDown: composeEventHandlers(e11.onKeyDown, (e12) => {
    const t13 = e12.currentTarget.contains(e12.target), r13 = y2[n6.dir].includes(e12.key);
    var o12;
    t13 && r13 && (n6.onOpenChange(false), (o12 = n6.trigger) === null || o12 === void 0 || o12.focus(), e12.preventDefault());
  }) })) : null;
});
var B2 = /* @__PURE__ */ E3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeMenu: r12, loop: u4 = false, trapFocus: i8, onOpenAutoFocus: s9, onCloseAutoFocus: l9, disableOutsidePointerEvents: f10, onEscapeKeyDown: v6, onPointerDownOutside: g6, onFocusOutside: h4, onInteractOutside: x6, onDismiss: _5, disableOutsideScroll: y5, allowPinchZoom: I4, portalled: P3 } = _a2, D5 = __objRest(_a2, ["__scopeMenu", "loop", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "disableOutsideScroll", "allowPinchZoom", "portalled"]), S3 = A2("MenuContent", r12), L4 = O2(r12), K3 = T3(r12), G4 = k2(r12), [U3, V5] = E3.useState(null), X3 = E3.useRef(null), B4 = useComposedRefs(n6, X3, S3.onContentChange), Y4 = E3.useRef(0), Z4 = E3.useRef(""), z3 = E3.useRef(0), H4 = E3.useRef(null), W4 = E3.useRef("right"), q3 = E3.useRef(0), N2 = P3 ? Portal : E3.Fragment, Q = y5 ? Combination_default : E3.Fragment, $2 = y5 ? { allowPinchZoom: I4 } : void 0, ee = (e12) => {
    var t12, n7;
    const r13 = Z4.current + e12, o11 = G4().filter((e13) => !e13.disabled), u5 = document.activeElement, c8 = (t12 = o11.find((e13) => e13.ref.current === u5)) === null || t12 === void 0 ? void 0 : t12.textValue, a7 = function(e13, t13, n8) {
      const r14 = t13.length > 1 && Array.from(t13).every((e14) => e14 === t13[0]) ? t13[0] : t13, o12 = n8 ? e13.indexOf(n8) : -1;
      let u6 = (c9 = e13, a8 = Math.max(o12, 0), c9.map((e14, t14) => c9[(a8 + t14) % c9.length]));
      var c9, a8;
      r14.length === 1 && (u6 = u6.filter((e14) => e14 !== n8));
      const i10 = u6.find((e14) => e14.toLowerCase().startsWith(r14.toLowerCase()));
      return i10 !== n8 ? i10 : void 0;
    }(o11.map((e13) => e13.textValue), r13, c8), i9 = (n7 = o11.find((e13) => e13.textValue === a7)) === null || n7 === void 0 ? void 0 : n7.ref.current;
    !function e13(t13) {
      Z4.current = t13, window.clearTimeout(Y4.current), t13 !== "" && (Y4.current = window.setTimeout(() => e13(""), 1e3));
    }(r13), i9 && setTimeout(() => i9.focus());
  };
  E3.useEffect(() => () => window.clearTimeout(Y4.current), []), useFocusGuards();
  const te = E3.useCallback((e12) => {
    var t12, n7;
    return W4.current === ((t12 = H4.current) === null || t12 === void 0 ? void 0 : t12.side) && function(e13, t13) {
      if (!t13)
        return false;
      return function(e14, t14) {
        const { x: n8, y: r13 } = e14;
        let o11 = false;
        for (let e15 = 0, u5 = t14.length - 1; e15 < t14.length; u5 = e15++) {
          const c8 = t14[e15].x, a7 = t14[e15].y, i9 = t14[u5].x, s10 = t14[u5].y;
          a7 > r13 != s10 > r13 && n8 < (i9 - c8) * (r13 - a7) / (s10 - a7) + c8 && (o11 = !o11);
        }
        return o11;
      }({ x: e13.clientX, y: e13.clientY }, t13);
    }(e12, (n7 = H4.current) === null || n7 === void 0 ? void 0 : n7.area);
  }, []);
  return E3.createElement(N2, null, /* @__PURE__ */ E3.createElement(Q, $2, /* @__PURE__ */ E3.createElement(F3, { scope: r12, searchRef: Z4, onItemEnter: E3.useCallback((e12) => {
    te(e12) && e12.preventDefault();
  }, [te]), onItemLeave: E3.useCallback((e12) => {
    var t12;
    te(e12) || ((t12 = X3.current) === null || t12 === void 0 || t12.focus(), V5(null));
  }, [te]), onTriggerLeave: E3.useCallback((e12) => {
    te(e12) && e12.preventDefault();
  }, [te]), pointerGraceTimerRef: z3, onPointerGraceIntentChange: E3.useCallback((e12) => {
    H4.current = e12;
  }, []) }, /* @__PURE__ */ E3.createElement(FocusScope, { asChild: true, trapped: i8, onMountAutoFocus: composeEventHandlers(s9, (e12) => {
    var t12;
    e12.preventDefault(), (t12 = X3.current) === null || t12 === void 0 || t12.focus();
  }), onUnmountAutoFocus: l9 }, /* @__PURE__ */ E3.createElement(DismissableLayer, { asChild: true, disableOutsidePointerEvents: f10, onEscapeKeyDown: v6, onPointerDownOutside: g6, onFocusOutside: h4, onInteractOutside: x6, onDismiss: _5 }, /* @__PURE__ */ E3.createElement(Root, _extends2({ asChild: true }, K3, { dir: S3.dir, orientation: "vertical", loop: u4, currentTabStopId: U3, onCurrentTabStopIdChange: V5, onEntryFocus: (e12) => {
    S3.isUsingKeyboardRef.current || e12.preventDefault();
  } }), /* @__PURE__ */ E3.createElement(Content, _extends2({ role: "menu", "aria-orientation": "vertical", "data-state": j3(S3.open), dir: S3.dir }, L4, D5, { ref: B4, style: __spreadValues({ outline: "none" }, D5.style), onKeyDown: composeEventHandlers(D5.onKeyDown, (e12) => {
    const t12 = e12.target, n7 = e12.currentTarget.contains(t12), r13 = e12.ctrlKey || e12.altKey || e12.metaKey;
    n7 && !r13 && e12.key.length === 1 && ee(e12.key), e12.key === "Tab" && e12.preventDefault();
    const o11 = X3.current;
    if (e12.target !== o11)
      return;
    if (!R3.includes(e12.key))
      return;
    e12.preventDefault();
    const u5 = G4().filter((e13) => !e13.disabled).map((e13) => e13.ref.current);
    b4.includes(e12.key) && u5.reverse(), function(e13) {
      const t13 = document.activeElement;
      for (const n8 of e13) {
        if (n8 === t13)
          return;
        if (n8.focus(), document.activeElement !== t13)
          return;
      }
    }(u5);
  }), onBlur: composeEventHandlers(e11.onBlur, (e12) => {
    e12.currentTarget.contains(e12.target) || (window.clearTimeout(Y4.current), Z4.current = "");
  }), onPointerMove: composeEventHandlers(e11.onPointerMove, J2((e12) => {
    const t12 = e12.target, n7 = q3.current !== e12.clientX;
    if (e12.currentTarget.contains(t12) && n7) {
      const t13 = e12.clientX > q3.current ? "right" : "left";
      W4.current = t13, q3.current = e12.clientX;
    }
  })) }))))))));
});
var MenuGroup = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6 } = _a2, r12 = __objRest(_a2, ["__scopeMenu"]);
  return E3.createElement(Primitive.div, _extends2({ role: "group" }, r12, { ref: t12 }));
});
var MenuItem = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { disabled: n6 = false, onSelect: r12 } = _a2, o11 = __objRest(_a2, ["disabled", "onSelect"]), u4 = E3.useRef(null), c8 = A2("MenuItem", e11.__scopeMenu), a7 = K2("MenuItem", e11.__scopeMenu), i8 = useComposedRefs(t12, u4), s9 = E3.useRef(false);
  return E3.createElement(Y3, _extends2({}, o11, { ref: i8, disabled: n6, onClick: composeEventHandlers(e11.onClick, () => {
    const e12 = u4.current;
    if (!n6 && e12) {
      const t13 = new Event("menu.itemSelect", { bubbles: true, cancelable: true });
      e12.addEventListener("menu.itemSelect", (e13) => r12 == null ? void 0 : r12(e13), { once: true }), e12.dispatchEvent(t13), t13.defaultPrevented ? s9.current = false : c8.onRootClose();
    }
  }), onPointerDown: (t13) => {
    var n7;
    (n7 = e11.onPointerDown) === null || n7 === void 0 || n7.call(e11, t13), s9.current = true;
  }, onPointerUp: composeEventHandlers(e11.onPointerUp, (e12) => {
    var t13;
    s9.current || (t13 = e12.currentTarget) === null || t13 === void 0 || t13.click();
  }), onKeyDown: composeEventHandlers(e11.onKeyDown, (e12) => {
    const t13 = a7.searchRef.current !== "";
    n6 || t13 && e12.key === " " || x2.includes(e12.key) && (e12.currentTarget.click(), e12.preventDefault());
  }) }));
});
var MenuSubTrigger = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const n6 = A2("MenuSubTrigger", e11.__scopeMenu), r12 = K2("MenuSubTrigger", e11.__scopeMenu), o11 = E3.useRef(null), { pointerGraceTimerRef: u4, onPointerGraceIntentChange: c8 } = r12, a7 = E3.useCallback(() => {
    o11.current && window.clearTimeout(o11.current), o11.current = null;
  }, []);
  return E3.useEffect(() => a7, [a7]), E3.useEffect(() => {
    const e12 = u4.current;
    return () => {
      window.clearTimeout(e12), c8(null);
    };
  }, [u4, c8]), n6.isSubmenu ? /* @__PURE__ */ E3.createElement(MenuAnchor, _extends2({ asChild: true }, e11), /* @__PURE__ */ E3.createElement(Y3, _extends2({ id: n6.triggerId, "aria-haspopup": "menu", "aria-expanded": n6.open, "aria-controls": n6.contentId, "data-state": j3(n6.open) }, e11, { ref: composeRefs(t12, n6.onTriggerChange), onClick: (t13) => {
    var r13;
    (r13 = e11.onClick) === null || r13 === void 0 || r13.call(e11, t13), e11.disabled || t13.defaultPrevented || (t13.currentTarget.focus(), n6.open || n6.onOpenChange(true));
  }, onPointerMove: composeEventHandlers(e11.onPointerMove, J2((t13) => {
    r12.onItemEnter(t13), t13.defaultPrevented || e11.disabled || n6.open || o11.current || (r12.onPointerGraceIntentChange(null), o11.current = window.setTimeout(() => {
      n6.onOpenChange(true), a7();
    }, 100));
  })), onPointerLeave: composeEventHandlers(e11.onPointerLeave, J2((e12) => {
    var t13;
    a7();
    const o12 = (t13 = n6.content) === null || t13 === void 0 ? void 0 : t13.getBoundingClientRect();
    if (o12) {
      var c9;
      const t14 = (c9 = n6.content) === null || c9 === void 0 ? void 0 : c9.dataset.side, a8 = t14 === "right", i8 = a8 ? -5 : 5, s9 = o12[a8 ? "left" : "right"], l9 = o12[a8 ? "right" : "left"];
      r12.onPointerGraceIntentChange({ area: [{ x: e12.clientX + i8, y: e12.clientY }, { x: s9, y: o12.top }, { x: l9, y: o12.top }, { x: l9, y: o12.bottom }, { x: s9, y: o12.bottom }], side: t14 }), window.clearTimeout(u4.current), u4.current = window.setTimeout(() => r12.onPointerGraceIntentChange(null), 300);
    } else {
      if (r12.onTriggerLeave(e12), e12.defaultPrevented)
        return;
      r12.onPointerGraceIntentChange(null);
    }
  })), onKeyDown: composeEventHandlers(e11.onKeyDown, (t13) => {
    const o12 = r12.searchRef.current !== "";
    var u5;
    e11.disabled || o12 && t13.key === " " || _2[n6.dir].includes(t13.key) && (n6.onOpenChange(true), (u5 = n6.content) === null || u5 === void 0 || u5.focus(), t13.preventDefault());
  }) }))) : null;
});
var Y3 = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6, disabled: r12 = false, textValue: u4 } = _a2, c8 = __objRest(_a2, ["__scopeMenu", "disabled", "textValue"]), a7 = K2("MenuItem", n6), i8 = T3(n6), l9 = E3.useRef(null), d7 = useComposedRefs(t12, l9), [p7, f10] = E3.useState("");
  return E3.useEffect(() => {
    const e12 = l9.current;
    var t13;
    e12 && f10(((t13 = e12.textContent) !== null && t13 !== void 0 ? t13 : "").trim());
  }, [c8.children]), /* @__PURE__ */ E3.createElement(I2.ItemSlot, { scope: n6, disabled: r12, textValue: u4 != null ? u4 : p7 }, /* @__PURE__ */ E3.createElement(Item, _extends2({ asChild: true }, i8, { focusable: !r12 }), /* @__PURE__ */ E3.createElement(Primitive.div, _extends2({ role: "menuitem", "aria-disabled": r12 || void 0, "data-disabled": r12 ? "" : void 0 }, c8, { ref: d7, onPointerMove: composeEventHandlers(e11.onPointerMove, J2((e12) => {
    if (r12)
      a7.onItemLeave(e12);
    else if (a7.onItemEnter(e12), !e12.defaultPrevented) {
      e12.currentTarget.focus();
    }
  })), onPointerLeave: composeEventHandlers(e11.onPointerLeave, J2((e12) => a7.onItemLeave(e12))) }))));
});
var MenuCheckboxItem = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { checked: n6 = false, onCheckedChange: r12 } = _a2, o11 = __objRest(_a2, ["checked", "onCheckedChange"]);
  return E3.createElement(H2, { scope: e11.__scopeMenu, checked: n6 }, /* @__PURE__ */ E3.createElement(MenuItem, _extends2({ role: "menuitemcheckbox", "aria-checked": n6 }, o11, { ref: t12, "data-state": q2(n6), onSelect: composeEventHandlers(o11.onSelect, () => r12 == null ? void 0 : r12(!n6), { checkForDefaultPrevented: false }) })));
});
var [Z3, z2] = D2("MenuRadioGroup", { value: void 0, onValueChange: () => {
} });
var MenuRadioGroup = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { value: r12, onValueChange: o11 } = _a2, u4 = __objRest(_a2, ["value", "onValueChange"]), c8 = useCallbackRef(o11);
  return E3.createElement(Z3, { scope: e11.__scopeMenu, value: r12, onValueChange: c8 }, /* @__PURE__ */ E3.createElement(MenuGroup, _extends2({}, u4, { ref: t12 })));
});
var MenuRadioItem = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { value: n6 } = _a2, r12 = __objRest(_a2, ["value"]), o11 = z2("MenuRadioItem", e11.__scopeMenu), u4 = n6 === o11.value;
  return E3.createElement(H2, { scope: e11.__scopeMenu, checked: u4 }, /* @__PURE__ */ E3.createElement(MenuItem, _extends2({ role: "menuitemradio", "aria-checked": u4 }, r12, { ref: t12, "data-state": q2(u4), onSelect: composeEventHandlers(r12.onSelect, () => {
    var e12;
    return (e12 = o11.onValueChange) === null || e12 === void 0 ? void 0 : e12.call(o11, n6);
  }, { checkForDefaultPrevented: false }) })));
});
var [H2, W3] = D2("MenuItemIndicator", { checked: false });
var MenuItemIndicator = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6, forceMount: r12 } = _a2, o11 = __objRest(_a2, ["__scopeMenu", "forceMount"]), u4 = W3("MenuItemIndicator", n6);
  return E3.createElement(Presence, { present: r12 || u4.checked }, /* @__PURE__ */ E3.createElement(Primitive.span, _extends2({}, o11, { ref: t12, "data-state": q2(u4.checked) })));
});
var MenuSeparator = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6 } = _a2, r12 = __objRest(_a2, ["__scopeMenu"]);
  return E3.createElement(Primitive.div, _extends2({ role: "separator", "aria-orientation": "horizontal" }, r12, { ref: t12 }));
});
var MenuArrow = /* @__PURE__ */ E3.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeMenu: n6 } = _a2, r12 = __objRest(_a2, ["__scopeMenu"]), o11 = O2(n6);
  return E3.createElement(Arrow2, _extends2({}, o11, r12, { ref: t12 }));
});
function j3(e11) {
  return e11 ? "open" : "closed";
}
function q2(e11) {
  return e11 ? "checked" : "unchecked";
}
function J2(e11) {
  return (t12) => t12.pointerType === "mouse" ? e11(t12) : void 0;
}
var Root4 = Menu;
var Sub = MenuSub;
var Anchor2 = MenuAnchor;
var SubTrigger = MenuSubTrigger;
var Content2 = MenuContent;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow3 = MenuArrow;

// ../../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
var c6 = __toESM(require_react());
var [i6, s6] = createContextScope("DropdownMenu", [S2]);
var l7 = S2();
var [m5, w3] = i6("DropdownMenu");
var DropdownMenu = (e11) => {
  const { __scopeDropdownMenu: n6, children: r12, open: p7, defaultOpen: a7, onOpenChange: d7 } = e11, i8 = g3("DropdownMenu", n6), s9 = l7(n6), [w6 = false, D5] = useControllableState({ prop: p7, defaultProp: a7, onChange: d7 }), M3 = c6.useCallback(() => D5((e12) => !e12), [D5]);
  return i8.isInsideContent ? /* @__PURE__ */ c6.createElement(m5, { scope: n6, isRootMenu: false, open: w6, onOpenChange: D5, onOpenToggle: M3 }, /* @__PURE__ */ c6.createElement(Sub, _extends2({}, s9, { open: w6, onOpenChange: D5 }), r12)) : /* @__PURE__ */ c6.createElement(f7, _extends2({}, e11, { open: w6, onOpenChange: D5, onOpenToggle: M3 }), r12);
};
var f7 = (n6) => {
  const { __scopeDropdownMenu: r12, children: t12, dir: p7, open: a7, onOpenChange: d7, onOpenToggle: i8, modal: s9 = true } = n6, w6 = l7(r12), f10 = c6.useRef(null);
  return c6.createElement(m5, { scope: r12, isRootMenu: true, triggerId: useId(), triggerRef: f10, contentId: useId(), open: a7, onOpenChange: d7, onOpenToggle: i8, modal: s9 }, /* @__PURE__ */ c6.createElement(Root4, _extends2({}, w6, { open: a7, onOpenChange: d7, dir: p7, modal: s9 }), t12));
};
var DropdownMenuTrigger = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: t12, disabled: p7 = false } = _a2, i8 = __objRest(_a2, ["__scopeDropdownMenu", "disabled"]), s9 = w3("DropdownMenuTrigger", t12), m8 = l7(t12);
  return s9.isRootMenu ? /* @__PURE__ */ c6.createElement(Anchor2, _extends2({ asChild: true }, m8), /* @__PURE__ */ c6.createElement(Primitive.button, _extends2({ type: "button", id: s9.triggerId, "aria-haspopup": "menu", "aria-expanded": !!s9.open || void 0, "aria-controls": s9.open ? s9.contentId : void 0, "data-state": s9.open ? "open" : "closed", "data-disabled": p7 ? "" : void 0, disabled: p7 }, i8, { ref: composeRefs(n6, s9.triggerRef), onClick: composeEventHandlers(e11.onClick, () => s9.onOpenChange(true)), onPointerDown: composeEventHandlers(e11.onPointerDown, (e12) => {
    p7 || e12.button !== 0 || e12.ctrlKey !== false || (s9.open || e12.preventDefault(), s9.onOpenToggle());
  }), onKeyDown: composeEventHandlers(e11.onKeyDown, (e12) => {
    p7 || e12.key !== "ArrowDown" || (e12.preventDefault(), s9.onOpenChange(true));
  }) }))) : null;
});
var [D3, g3] = i6("DropdownMenuContent", { isInsideContent: false });
var DropdownMenuContent = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = w3("DropdownMenuContent", r12), a7 = l7(r12), d7 = __spreadProps(__spreadValues({}, t12), { style: __spreadProps(__spreadValues({}, e11.style), { "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)" }) });
  return c6.createElement(D3, { scope: r12, isInsideContent: true }, p7.isRootMenu ? /* @__PURE__ */ c6.createElement(M2, _extends2({ __scopeDropdownMenu: r12 }, d7, { ref: n6 })) : /* @__PURE__ */ c6.createElement(Content2, _extends2({}, a7, d7, { ref: n6 })));
});
var M2 = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12, portalled: t12 = true } = _a2, p7 = __objRest(_a2, ["__scopeDropdownMenu", "portalled"]), a7 = w3("DropdownMenuContent", r12), d7 = l7(r12), i8 = c6.useRef(false);
  return a7.isRootMenu ? /* @__PURE__ */ c6.createElement(Content2, _extends2({ id: a7.contentId, "aria-labelledby": a7.triggerId }, d7, p7, { ref: n6, portalled: t12, onCloseAutoFocus: (o11) => {
    var n7, r13;
    ((n7 = e11.onCloseAutoFocus) === null || n7 === void 0 || n7.call(e11, o11), o11.defaultPrevented) || (i8.current || (r13 = a7.triggerRef.current) === null || r13 === void 0 || r13.focus(), o11.preventDefault());
    i8.current = false;
  }, onInteractOutside: (o11) => {
    var n7, r13;
    if ((n7 = e11.onInteractOutside) === null || n7 === void 0 || n7.call(e11, o11), !o11.defaultPrevented) {
      const e12 = o11.detail.originalEvent, n8 = e12.button === 0 && e12.ctrlKey === true, r14 = e12.button === 2 || n8;
      a7.modal && !r14 || (i8.current = true);
    }
    const t13 = o11.target;
    ((r13 = a7.triggerRef.current) === null || r13 === void 0 ? void 0 : r13.contains(t13)) && o11.preventDefault();
  } })) : null;
});
var DropdownMenuItem = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(Item2, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuTriggerItem = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(SubTrigger, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuCheckboxItem = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(CheckboxItem, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuRadioGroup = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(RadioGroup, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuRadioItem = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(RadioItem, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuItemIndicator = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(ItemIndicator, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuSeparator = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(Separator, _extends2({}, p7, t12, { ref: n6 }));
});
var DropdownMenuArrow = /* @__PURE__ */ c6.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeDropdownMenu: r12 } = _a2, t12 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r12);
  return c6.createElement(Arrow3, _extends2({}, p7, t12, { ref: n6 }));
});
var Root5 = DropdownMenu;
var Trigger = DropdownMenuTrigger;
var Content3 = DropdownMenuContent;
var Item3 = DropdownMenuItem;
var TriggerItem = DropdownMenuTriggerItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var RadioGroup2 = DropdownMenuRadioGroup;
var RadioItem2 = DropdownMenuRadioItem;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator;
var Arrow4 = DropdownMenuArrow;

// ../../node_modules/@radix-ui/react-icons/dist/react-icons.esm.js
var import_react15 = __toESM(require_react());
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i8;
  for (i8 = 0; i8 < sourceKeys.length; i8++) {
    key = sourceKeys[i8];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var AlignBottomIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignCenterHorizontallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignCenterVerticallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignLeftIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignRightIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignTopIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AngleIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowDownIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowTopRightIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowUpIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AspectRatioIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var BoxIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CheckIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ChevronRightIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CircleIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ClipboardIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M5 2V1H10V2H5ZM4.75 0C4.33579 0 4 0.335786 4 0.75V1H3.5C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V2.5C13 1.67157 12.3284 1 11.5 1H11V0.75C11 0.335786 10.6642 0 10.25 0H4.75ZM11 2V2.25C11 2.66421 10.6642 3 10.25 3H4.75C4.33579 3 4 2.66421 4 2.25V2H3.5C3.22386 2 3 2.22386 3 2.5V12.5C3 12.7761 3.22386 13 3.5 13H11.5C11.7761 13 12 12.7761 12 12.5V2.5C12 2.22386 11.7761 2 11.5 2H11Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CopyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CursorArrowIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var DotFilledIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
    fill: color
  }));
});
var DotsHorizontalIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ExitIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M3 1C2.44771 1 2 1.44772 2 2V13C2 13.5523 2.44772 14 3 14H10.5C10.7761 14 11 13.7761 11 13.5C11 13.2239 10.7761 13 10.5 13H3V2L10.5 2C10.7761 2 11 1.77614 11 1.5C11 1.22386 10.7761 1 10.5 1H3ZM12.6036 4.89645C12.4083 4.70118 12.0917 4.70118 11.8964 4.89645C11.7012 5.09171 11.7012 5.40829 11.8964 5.60355L13.2929 7H6.5C6.22386 7 6 7.22386 6 7.5C6 7.77614 6.22386 8 6.5 8H13.2929L11.8964 9.39645C11.7012 9.59171 11.7012 9.90829 11.8964 10.1036C12.0917 10.2988 12.4083 10.2988 12.6036 10.1036L14.8536 7.85355C15.0488 7.65829 15.0488 7.34171 14.8536 7.14645L12.6036 4.89645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var GitHubLogoIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.49936 0.850006C3.82767 0.850006 0.849976 3.8273 0.849976 7.50023C0.849976 10.4379 2.75523 12.9306 5.39775 13.8104C5.73047 13.8712 5.85171 13.6658 5.85171 13.4895C5.85171 13.3315 5.846 12.9135 5.84273 12.3587C3.99301 12.7604 3.60273 11.4671 3.60273 11.4671C3.30022 10.6988 2.86423 10.4942 2.86423 10.4942C2.26044 10.0819 2.90995 10.0901 2.90995 10.0901C3.57742 10.137 3.9285 10.7755 3.9285 10.7755C4.52167 11.7916 5.48512 11.4981 5.86396 11.3279C5.92438 10.8984 6.09625 10.6053 6.28608 10.4391C4.80948 10.2709 3.25695 9.70063 3.25695 7.15241C3.25695 6.42615 3.51618 5.83298 3.94157 5.368C3.87299 5.1998 3.64478 4.52375 4.00689 3.60807C4.00689 3.60807 4.56494 3.42926 5.83538 4.28941C6.36568 4.14204 6.93477 4.06856 7.50018 4.0657C8.06518 4.06856 8.63386 4.14204 9.16498 4.28941C10.4346 3.42926 10.9918 3.60807 10.9918 3.60807C11.3548 4.52375 11.1266 5.1998 11.0584 5.368C11.4846 5.83298 11.7418 6.42615 11.7418 7.15241C11.7418 9.70716 10.1868 10.2693 8.70571 10.4338C8.94412 10.6392 9.15681 11.045 9.15681 11.6655C9.15681 12.5542 9.14865 13.2715 9.14865 13.4895C9.14865 13.6675 9.26867 13.8745 9.60588 13.8095C12.2464 12.9282 14.15 10.4375 14.15 7.50023C14.15 3.8273 11.1723 0.850006 7.49936 0.850006Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var GroupIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var HamburgerMenuIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var LockClosedIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var LockOpen1Icon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var MixerVerticalIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var Pencil1Icon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var Pencil2Icon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PinBottomIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PinTopIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PlusIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var RotateCounterClockwiseIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SpaceEvenlyVerticallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SquareIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var StretchHorizontallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var StretchVerticallyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignCenterIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignJustifyIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignLeftIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignRightIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TwitterLogoIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.23336 4.69629C7.23336 2.96884 8.63335 1.56857 10.36 1.56857C11.3736 1.56857 12.183 2.04804 12.7254 2.74385C13.3079 2.62467 13.8557 2.40913 14.3513 2.11508C14.1559 2.72598 13.7424 3.2396 13.2033 3.56463C13.2038 3.56568 13.2042 3.56674 13.2047 3.56779C13.7334 3.50361 14.2364 3.36302 14.7048 3.15546L14.7037 3.15715C14.3667 3.66183 13.9431 4.10736 13.4561 4.47034C13.4823 4.64672 13.4956 4.82427 13.4956 5.00079C13.4956 8.6871 10.6873 12.9746 5.52122 12.9746C3.93906 12.9746 2.46544 12.511 1.22505 11.7152C0.992632 11.5661 0.925108 11.2568 1.07423 11.0244C1.0874 11.0038 1.10183 10.9846 1.11734 10.9666C1.20582 10.8202 1.37438 10.7309 1.5554 10.7522C2.47066 10.8601 3.38568 10.7485 4.19219 10.3962C3.39226 10.0434 2.77129 9.35975 2.50204 8.51974C2.45359 8.3686 2.48835 8.20311 2.59351 8.08422C2.59716 8.0801 2.60087 8.07606 2.60464 8.0721C1.96391 7.50819 1.55973 6.68208 1.55973 5.76143V5.72759C1.55973 5.56814 1.64411 5.42059 1.78155 5.33974C1.82671 5.31317 1.87537 5.29511 1.92532 5.28558C1.70549 4.86154 1.58116 4.37984 1.58116 3.86958C1.58116 3.40165 1.58384 2.81192 1.91332 2.28081C1.98718 2.16175 2.10758 2.08915 2.2364 2.07195C2.42588 2.01237 2.64087 2.06969 2.77406 2.23302C3.86536 3.57126 5.44066 4.49583 7.23366 4.73961L7.23336 4.69629ZM5.52122 11.9746C4.73387 11.9746 3.97781 11.8435 3.27248 11.6023C4.13012 11.4538 4.95307 11.1159 5.66218 10.5602C5.81211 10.4427 5.87182 10.2435 5.81126 10.0629C5.7507 9.88234 5.583 9.75943 5.39255 9.75607C4.68968 9.74366 4.06712 9.39716 3.67793 8.86845C3.86828 8.85306 4.05428 8.82039 4.23445 8.77167C4.43603 8.71716 4.57363 8.53114 4.56674 8.32243C4.55985 8.11372 4.41029 7.93718 4.20555 7.89607C3.42694 7.73977 2.79883 7.16764 2.56169 6.42174C2.76255 6.47025 2.97102 6.4991 3.18482 6.5061C3.38563 6.51267 3.56646 6.38533 3.62795 6.19405C3.68943 6.00277 3.61666 5.79391 3.44963 5.68224C2.86523 5.29155 2.48116 4.62464 2.48116 3.86958C2.48116 3.70213 2.48352 3.55268 2.49355 3.41719C3.85115 4.79913 5.70873 5.68931 7.77588 5.79338C7.93225 5.80126 8.08328 5.73543 8.18395 5.61553C8.28463 5.49562 8.32332 5.33548 8.28851 5.18284C8.25255 5.02517 8.23336 4.86284 8.23336 4.69629C8.23336 3.52085 9.18591 2.56857 10.36 2.56857C11.5943 2.56857 12.4956 3.71208 12.4956 5.00079C12.4956 8.25709 10.0202 11.9746 5.52122 11.9746Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var VercelLogoIcon = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react15.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react15.createElement)("path", {
    d: "M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});

// ../../packages/tldraw/dist/index.mjs
var React332 = __toESM(require_react(), 1);
var React323 = __toESM(require_react(), 1);
var React55 = __toESM(require_react(), 1);
var React362 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-visually-hidden/dist/index.module.js
var r10 = __toESM(require_react());
var VisuallyHidden = /* @__PURE__ */ r10.forwardRef((i8, o11) => /* @__PURE__ */ r10.createElement(Primitive.span, _extends2({}, i8, { ref: o11, style: __spreadProps(__spreadValues({}, i8.style), { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }) })));
var Root6 = VisuallyHidden;

// ../../node_modules/@radix-ui/react-use-previous/dist/index.module.js
var e10 = __toESM(require_react());
function usePrevious(r12) {
  const t12 = e10.useRef(r12);
  return e10.useEffect(() => {
    t12.current = r12;
  }, [r12]), t12.current;
}

// ../../node_modules/@radix-ui/react-tooltip/dist/index.module.js
var T4 = __toESM(require_react());
var [w4, x3] = createContextScope("Tooltip", [l5]);
var g4 = l5();
var E4 = 700;
var [v4, b5] = w4("TooltipProvider", { isOpenDelayed: true, delayDuration: E4, onOpen: () => {
}, onClose: () => {
} });
var [y3, _3] = w4("Tooltip");
var Tooltip = (o11) => {
  const { __scopeTooltip: t12, children: r12, open: i8, defaultOpen: a7 = false, onOpenChange: l9, delayDuration: c8 } = o11, s9 = b5("Tooltip", t12), u4 = g4(t12), [d7, m8] = T4.useState(null), f10 = useId(), C6 = T4.useRef(0), w6 = c8 != null ? c8 : s9.delayDuration, x6 = T4.useRef(false), { onOpen: E7, onClose: v6 } = s9, [_5 = false, h4] = useControllableState({ prop: i8, defaultProp: a7, onChange: (e11) => {
    e11 && (document.dispatchEvent(new CustomEvent("tooltip.open")), E7()), l9 == null || l9(e11);
  } }), k4 = T4.useMemo(() => _5 ? x6.current ? "delayed-open" : "instant-open" : "closed", [_5]), D5 = T4.useCallback(() => {
    window.clearTimeout(C6.current), x6.current = false, h4(true);
  }, [h4]), O4 = T4.useCallback(() => {
    window.clearTimeout(C6.current), C6.current = window.setTimeout(() => {
      x6.current = true, h4(true);
    }, w6);
  }, [w6, h4]);
  return T4.useEffect(() => () => window.clearTimeout(C6.current), []), /* @__PURE__ */ T4.createElement(Root3, u4, /* @__PURE__ */ T4.createElement(y3, { scope: t12, contentId: f10, open: _5, stateAttribute: k4, trigger: d7, onTriggerChange: m8, onTriggerEnter: T4.useCallback(() => {
    s9.isOpenDelayed ? O4() : D5();
  }, [s9.isOpenDelayed, O4, D5]), onOpen: T4.useCallback(D5, [D5]), onClose: T4.useCallback(() => {
    window.clearTimeout(C6.current), h4(false), v6();
  }, [h4, v6]) }, r12));
};
var TooltipTrigger = /* @__PURE__ */ T4.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeTooltip: t12 } = _a2, r12 = __objRest(_a2, ["__scopeTooltip"]), i8 = _3("TooltipTrigger", t12), l9 = g4(t12), c8 = useComposedRefs(o11, i8.onTriggerChange), s9 = T4.useRef(false), u4 = T4.useCallback(() => s9.current = false, []);
  return T4.useEffect(() => () => document.removeEventListener("mouseup", u4), [u4]), /* @__PURE__ */ T4.createElement(Anchor, _extends2({ asChild: true }, l9), /* @__PURE__ */ T4.createElement(Primitive.button, _extends2({ "aria-describedby": i8.open ? i8.contentId : void 0, "data-state": i8.stateAttribute }, r12, { ref: c8, onMouseEnter: composeEventHandlers(e11.onMouseEnter, i8.onTriggerEnter), onMouseLeave: composeEventHandlers(e11.onMouseLeave, i8.onClose), onMouseDown: composeEventHandlers(e11.onMouseDown, () => {
    i8.onClose(), s9.current = true, document.addEventListener("mouseup", u4, { once: true });
  }), onFocus: composeEventHandlers(e11.onFocus, () => {
    s9.current || i8.onOpen();
  }), onBlur: composeEventHandlers(e11.onBlur, i8.onClose), onClick: composeEventHandlers(e11.onClick, i8.onClose) })));
});
var TooltipContent = /* @__PURE__ */ T4.forwardRef((e11, o11) => {
  const _a2 = e11, { forceMount: t12 } = _a2, r12 = __objRest(_a2, ["forceMount"]), n6 = _3("TooltipContent", e11.__scopeTooltip);
  return T4.createElement(Presence, { present: t12 || n6.open }, /* @__PURE__ */ T4.createElement(h2, _extends2({ ref: o11 }, r12)));
});
var h2 = /* @__PURE__ */ T4.forwardRef((e11, i8) => {
  const _a2 = e11, { __scopeTooltip: a7, children: l9, "aria-label": c8, portalled: s9 = true } = _a2, p7 = __objRest(_a2, ["__scopeTooltip", "children", "aria-label", "portalled"]), d7 = _3("TooltipContent", a7), m8 = g4(a7), f10 = s9 ? Portal : T4.Fragment, { onClose: w6 } = d7;
  return useEscapeKeydown(() => w6()), T4.useEffect(() => (document.addEventListener("tooltip.open", w6), () => document.removeEventListener("tooltip.open", w6)), [w6]), /* @__PURE__ */ T4.createElement(f10, null, /* @__PURE__ */ T4.createElement(k3, { __scopeTooltip: a7 }), /* @__PURE__ */ T4.createElement(Content, _extends2({ "data-state": d7.stateAttribute }, m8, p7, { ref: i8, style: __spreadProps(__spreadValues({}, p7.style), { "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)" }) }), /* @__PURE__ */ T4.createElement(Slottable, null, l9), /* @__PURE__ */ T4.createElement(Root6, { id: d7.contentId, role: "tooltip" }, c8 || l9)));
});
var TooltipArrow = /* @__PURE__ */ T4.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeTooltip: t12 } = _a2, r12 = __objRest(_a2, ["__scopeTooltip"]), i8 = g4(t12);
  return T4.createElement(Arrow2, _extends2({}, i8, r12, { ref: o11 }));
});
function k3(e11) {
  const { __scopeTooltip: o11 } = e11, t12 = _3("CheckTriggerMoved", o11), r12 = useRect(t12.trigger), n6 = r12 == null ? void 0 : r12.left, i8 = usePrevious(n6), a7 = r12 == null ? void 0 : r12.top, l9 = usePrevious(a7), u4 = t12.onClose;
  return T4.useEffect(() => {
    (i8 !== void 0 && i8 !== n6 || l9 !== void 0 && l9 !== a7) && u4();
  }, [u4, i8, l9, n6, a7]), null;
}
var Root7 = Tooltip;
var Trigger2 = TooltipTrigger;
var Content4 = TooltipContent;
var Arrow5 = TooltipArrow;

// ../../packages/tldraw/dist/index.mjs
var React352 = __toESM(require_react(), 1);
var React542 = __toESM(require_react(), 1);
var React372 = __toESM(require_react(), 1);
var React382 = __toESM(require_react(), 1);
var React392 = __toESM(require_react(), 1);
var React402 = __toESM(require_react(), 1);
var React412 = __toESM(require_react(), 1);
var React422 = __toESM(require_react(), 1);
var React432 = __toESM(require_react(), 1);
var React442 = __toESM(require_react(), 1);
var React452 = __toESM(require_react(), 1);
var React462 = __toESM(require_react(), 1);
var React472 = __toESM(require_react(), 1);
var React482 = __toESM(require_react(), 1);
var React492 = __toESM(require_react(), 1);
var React502 = __toESM(require_react(), 1);
var React512 = __toESM(require_react(), 1);
var React522 = __toESM(require_react(), 1);
var React532 = __toESM(require_react(), 1);
var React61 = __toESM(require_react(), 1);
var React56 = __toESM(require_react(), 1);
var React57 = __toESM(require_react(), 1);
var React58 = __toESM(require_react(), 1);
var React59 = __toESM(require_react(), 1);
var React60 = __toESM(require_react(), 1);
var React622 = __toESM(require_react(), 1);
var React73 = __toESM(require_react(), 1);
var React66 = __toESM(require_react(), 1);
var React64 = __toESM(require_react(), 1);
var React65 = __toESM(require_react(), 1);
var React69 = __toESM(require_react(), 1);
var React68 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-dialog/dist/index.module.js
var m6 = __toESM(require_react());
var [x4, v5] = createContextScope("Dialog");
var [C3, E5] = x4("Dialog");
var Dialog = (e11) => {
  const { __scopeDialog: o11, children: t12, open: r12, defaultOpen: n6, onOpenChange: a7, modal: i8 = true, allowPinchZoom: l9 } = e11, c8 = m6.useRef(null), p7 = m6.useRef(null), [d7 = false, f10] = useControllableState({ prop: r12, defaultProp: n6, onChange: a7 });
  return m6.createElement(C3, { scope: o11, triggerRef: c8, contentRef: p7, contentId: useId(), titleId: useId(), descriptionId: useId(), open: d7, onOpenChange: f10, onOpenToggle: m6.useCallback(() => f10((e12) => !e12), [f10]), modal: i8, allowPinchZoom: l9 }, t12);
};
var DialogTrigger = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeDialog: t12 } = _a2, r12 = __objRest(_a2, ["__scopeDialog"]), a7 = E5("DialogTrigger", t12), i8 = useComposedRefs(o11, a7.triggerRef);
  return m6.createElement(Primitive.button, _extends2({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a7.open, "aria-controls": a7.contentId, "data-state": h3(a7.open) }, r12, { ref: i8, onClick: composeEventHandlers(e11.onClick, a7.onOpenToggle) }));
});
var DialogPortal = (e11) => {
  const { __scopeDialog: o11, forceMount: t12, children: r12, container: n6 } = e11, l9 = E5("DialogPortal", o11);
  return m6.createElement(m6.Fragment, null, m6.Children.map(r12, (e12) => /* @__PURE__ */ m6.createElement(Presence, { present: t12 || l9.open }, /* @__PURE__ */ m6.createElement(UnstablePortal, { asChild: true, container: n6 }, e12))));
};
var DialogOverlay = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const _a2 = e11, { forceMount: t12 } = _a2, r12 = __objRest(_a2, ["forceMount"]), n6 = E5("DialogOverlay", e11.__scopeDialog);
  return n6.modal ? /* @__PURE__ */ m6.createElement(Presence, { present: t12 || n6.open }, /* @__PURE__ */ m6.createElement(b6, _extends2({}, r12, { ref: o11 }))) : null;
});
var b6 = /* @__PURE__ */ m6.forwardRef((o11, r12) => {
  const _a2 = o11, { __scopeDialog: a7 } = _a2, i8 = __objRest(_a2, ["__scopeDialog"]), l9 = E5("DialogOverlay", a7);
  return m6.createElement(Combination_default, { as: Slot, allowPinchZoom: l9.allowPinchZoom, shards: [l9.contentRef] }, /* @__PURE__ */ m6.createElement(Primitive.div, _extends2({ "data-state": h3(l9.open) }, i8, { ref: r12, style: __spreadValues({ pointerEvents: "auto" }, i8.style) })));
});
var DialogContent = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const _a2 = e11, { forceMount: t12 } = _a2, r12 = __objRest(_a2, ["forceMount"]), n6 = E5("DialogContent", e11.__scopeDialog);
  return m6.createElement(Presence, { present: t12 || n6.open }, n6.modal ? /* @__PURE__ */ m6.createElement(R4, _extends2({}, r12, { ref: o11 })) : /* @__PURE__ */ m6.createElement(_4, _extends2({}, r12, { ref: o11 })));
});
var R4 = /* @__PURE__ */ m6.forwardRef((e11, t12) => {
  const r12 = E5("DialogContent", e11.__scopeDialog), n6 = m6.useRef(null), a7 = useComposedRefs(t12, r12.contentRef, n6);
  return m6.useEffect(() => {
    const e12 = n6.current;
    if (e12)
      return hideOthers(e12);
  }, []), /* @__PURE__ */ m6.createElement(O3, _extends2({}, e11, { ref: a7, trapFocus: r12.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(e11.onCloseAutoFocus, (e12) => {
    var o11;
    e12.preventDefault(), (o11 = r12.triggerRef.current) === null || o11 === void 0 || o11.focus();
  }), onPointerDownOutside: composeEventHandlers(e11.onPointerDownOutside, (e12) => {
    const o11 = e12.detail.originalEvent, t13 = o11.button === 0 && o11.ctrlKey === true;
    (o11.button === 2 || t13) && e12.preventDefault();
  }), onFocusOutside: composeEventHandlers(e11.onFocusOutside, (e12) => e12.preventDefault()) }));
});
var _4 = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const t12 = E5("DialogContent", e11.__scopeDialog), r12 = m6.useRef(false);
  return m6.createElement(O3, _extends2({}, e11, { ref: o11, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o12) => {
    var n6, a7;
    ((n6 = e11.onCloseAutoFocus) === null || n6 === void 0 || n6.call(e11, o12), o12.defaultPrevented) || (r12.current || (a7 = t12.triggerRef.current) === null || a7 === void 0 || a7.focus(), o12.preventDefault());
    r12.current = false;
  }, onInteractOutside: (o12) => {
    var n6, a7;
    (n6 = e11.onInteractOutside) === null || n6 === void 0 || n6.call(e11, o12), o12.defaultPrevented || (r12.current = true);
    const i8 = o12.target;
    ((a7 = t12.triggerRef.current) === null || a7 === void 0 ? void 0 : a7.contains(i8)) && o12.preventDefault();
  } }));
});
var O3 = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeDialog: t12, "aria-label": n6, "aria-labelledby": a7, "aria-describedby": i8, trapFocus: s9, onOpenAutoFocus: u4, onCloseAutoFocus: p7 } = _a2, d7 = __objRest(_a2, ["__scopeDialog", "aria-label", "aria-labelledby", "aria-describedby", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]), g6 = E5("DialogContent", t12), x6 = m6.useRef(null), v6 = useComposedRefs(o11, x6);
  return useFocusGuards(), /* @__PURE__ */ m6.createElement(m6.Fragment, null, /* @__PURE__ */ m6.createElement(FocusScope, { asChild: true, loop: true, trapped: s9, onMountAutoFocus: u4, onUnmountAutoFocus: p7 }, /* @__PURE__ */ m6.createElement(DismissableLayer, _extends2({ role: "dialog", id: g6.contentId, "aria-describedby": i8 || g6.descriptionId, "aria-labelledby": n6 ? void 0 : a7 || g6.titleId, "aria-label": n6 || void 0, "data-state": h3(g6.open) }, d7, { ref: v6, onDismiss: () => g6.onOpenChange(false) }))), false);
});
var DialogClose = /* @__PURE__ */ m6.forwardRef((e11, o11) => {
  const _a2 = e11, { __scopeDialog: t12 } = _a2, r12 = __objRest(_a2, ["__scopeDialog"]), a7 = E5("DialogClose", t12);
  return m6.createElement(Primitive.button, _extends2({ type: "button" }, r12, { ref: o11, onClick: composeEventHandlers(e11.onClick, () => a7.onOpenChange(false)) }));
});
function h3(e11) {
  return e11 ? "open" : "closed";
}
var [w5, y4] = createContext3("DialogLabelWarning", { contentName: "DialogContent", titleName: "DialogTitle", docsSlug: "dialog" });
var Root8 = Dialog;
var Trigger3 = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay3 = DialogOverlay;
var Content5 = DialogContent;
var Close = DialogClose;

// ../../node_modules/@radix-ui/react-alert-dialog/dist/index.module.js
var a6 = __toESM(require_react());
var [c7, s7] = createContextScope("AlertDialog", [v5]);
var p5 = v5();
var AlertDialog = (e11) => {
  const _a2 = e11, { __scopeAlertDialog: t12 } = _a2, o11 = __objRest(_a2, ["__scopeAlertDialog"]), l9 = p5(t12);
  return a6.createElement(Root8, _extends2({}, l9, o11, { modal: true }));
};
var AlertDialogTrigger = /* @__PURE__ */ a6.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeAlertDialog: o11 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o11);
  return a6.createElement(Trigger3, _extends2({}, n6, l9, { ref: t12 }));
});
var AlertDialogPortal = (e11) => {
  const _a2 = e11, { __scopeAlertDialog: t12 } = _a2, o11 = __objRest(_a2, ["__scopeAlertDialog"]), l9 = p5(t12);
  return a6.createElement(Portal2, _extends2({}, l9, o11));
};
var AlertDialogOverlay = /* @__PURE__ */ a6.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeAlertDialog: o11 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o11);
  return a6.createElement(Overlay3, _extends2({}, n6, l9, { ref: t12 }));
});
var [g5, D4] = c7("AlertDialogContent");
var AlertDialogContent = /* @__PURE__ */ a6.forwardRef((o11, n6) => {
  const _a2 = o11, { __scopeAlertDialog: c8, children: s9 } = _a2, D5 = __objRest(_a2, ["__scopeAlertDialog", "children"]), A3 = p5(c8), m8 = a6.useRef(null), u4 = useComposedRefs(n6, m8), x6 = a6.useRef(null);
  return a6.createElement(w5, { contentName: "AlertDialogContent", titleName: f8, docsSlug: "alert-dialog" }, /* @__PURE__ */ a6.createElement(g5, { scope: c8, cancelRef: x6 }, /* @__PURE__ */ a6.createElement(Content5, _extends2({ role: "alertdialog" }, A3, D5, { ref: u4, onOpenAutoFocus: composeEventHandlers(D5.onOpenAutoFocus, (e11) => {
    var t12;
    e11.preventDefault(), (t12 = x6.current) === null || t12 === void 0 || t12.focus({ preventScroll: true });
  }), onPointerDownOutside: (e11) => e11.preventDefault(), onInteractOutside: (e11) => e11.preventDefault() }), /* @__PURE__ */ a6.createElement(Slottable, null, s9), false)));
});
var f8 = "AlertDialogTitle";
var AlertDialogAction = /* @__PURE__ */ a6.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeAlertDialog: o11 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o11);
  return a6.createElement(Close, _extends2({}, n6, l9, { ref: t12 }));
});
var AlertDialogCancel = /* @__PURE__ */ a6.forwardRef((e11, t12) => {
  const _a2 = e11, { __scopeAlertDialog: o11 } = _a2, n6 = __objRest(_a2, ["__scopeAlertDialog"]), { cancelRef: c8 } = D4("AlertDialogCancel", o11), s9 = p5(o11), g6 = useComposedRefs(t12, c8);
  return a6.createElement(Close, _extends2({}, s9, n6, { ref: g6 }));
});
var Root9 = AlertDialog;
var Trigger4 = AlertDialogTrigger;
var Portal3 = AlertDialogPortal;
var Overlay4 = AlertDialogOverlay;
var Content6 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;

// ../../packages/tldraw/dist/index.mjs
var React67 = __toESM(require_react(), 1);
var React70 = __toESM(require_react(), 1);
var React71 = __toESM(require_react(), 1);
var React722 = __toESM(require_react(), 1);
var React74 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-context-menu/dist/index.module.js
var u3 = __toESM(require_react());
var [s8, i7] = createContextScope("ContextMenu", [S2]);
var x5 = S2();
var [p6, C4] = s8("ContextMenu");
var ContextMenu = (n6) => {
  const { __scopeContextMenu: o11, children: r12, onOpenChange: c8, dir: s9, modal: i8 = true } = n6, [C6, m8] = u3.useState(false), f10 = l8("ContextMenu", o11), d7 = x5(o11), M3 = useCallbackRef(c8), R5 = u3.useCallback((e11) => {
    m8(e11), M3(e11);
  }, [M3]);
  return f10.isInsideContent ? /* @__PURE__ */ u3.createElement(p6, { scope: o11, isRootMenu: false, open: C6, onOpenChange: R5, modal: i8 }, /* @__PURE__ */ u3.createElement(Sub, _extends2({}, d7, { open: C6, onOpenChange: R5 }), r12)) : /* @__PURE__ */ u3.createElement(p6, { scope: o11, isRootMenu: true, open: C6, onOpenChange: R5, modal: i8 }, /* @__PURE__ */ u3.createElement(Root4, _extends2({}, d7, { dir: s9, open: C6, onOpenChange: R5, modal: i8 }), r12));
};
var ContextMenuTrigger = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: r12 } = _a2, s9 = __objRest(_a2, ["__scopeContextMenu"]), i8 = C4("ContextMenuTrigger", r12), p7 = x5(r12), l9 = u3.useRef({ x: 0, y: 0 }), f10 = u3.useRef({ getBoundingClientRect: () => DOMRect.fromRect(__spreadValues({ width: 0, height: 0 }, l9.current)) }), M3 = u3.useRef(0), R5 = u3.useCallback(() => window.clearTimeout(M3.current), []), _5 = (e12) => {
    l9.current = { x: e12.clientX, y: e12.clientY }, i8.onOpenChange(true);
  };
  return u3.useEffect(() => R5, [R5]), /* @__PURE__ */ u3.createElement(m7, { scope: r12, isInsideContent: false }, /* @__PURE__ */ u3.createElement(Anchor2, _extends2({}, p7, { virtualRef: f10 })), /* @__PURE__ */ u3.createElement(Primitive.span, _extends2({}, s9, { ref: n6, style: __spreadValues({ WebkitTouchCallout: "none" }, e11.style), onContextMenu: composeEventHandlers(e11.onContextMenu, (e12) => {
    R5(), e12.preventDefault(), _5(e12);
  }), onPointerDown: composeEventHandlers(e11.onPointerDown, d6((e12) => {
    R5(), M3.current = window.setTimeout(() => _5(e12), 700);
  })), onPointerMove: composeEventHandlers(e11.onPointerMove, d6(R5)), onPointerCancel: composeEventHandlers(e11.onPointerCancel, d6(R5)), onPointerUp: composeEventHandlers(e11.onPointerUp, d6(R5)) })));
});
var [m7, l8] = s8("ContextMenuContent", { isInsideContent: false });
var ContextMenuContent = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: o11 } = _a2, r12 = __objRest(_a2, ["__scopeContextMenu"]), c8 = C4("ContextMenuContent", o11), s9 = x5(o11), i8 = __spreadProps(__spreadValues({}, r12), { style: __spreadProps(__spreadValues({}, e11.style), { "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)" }) });
  return u3.createElement(m7, { scope: o11, isInsideContent: true }, c8.isRootMenu ? /* @__PURE__ */ u3.createElement(f9, _extends2({ __scopeContextMenu: o11 }, i8, { ref: n6 })) : /* @__PURE__ */ u3.createElement(Content2, _extends2({}, s9, i8, { ref: n6 })));
});
var f9 = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: o11 } = _a2, r12 = __objRest(_a2, ["__scopeContextMenu"]), c8 = C4("ContextMenuContent", o11), s9 = x5(o11), i8 = u3.useRef(false);
  return u3.createElement(Content2, _extends2({}, s9, r12, { ref: n6, portalled: true, side: "right", sideOffset: 2, align: "start", onCloseAutoFocus: (t12) => {
    var n7;
    (n7 = e11.onCloseAutoFocus) === null || n7 === void 0 || n7.call(e11, t12), !t12.defaultPrevented && i8.current && t12.preventDefault(), i8.current = false;
  }, onInteractOutside: (t12) => {
    var n7;
    (n7 = e11.onInteractOutside) === null || n7 === void 0 || n7.call(e11, t12), t12.defaultPrevented || c8.modal || (i8.current = true);
  } }));
});
var ContextMenuItem = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: o11 } = _a2, r12 = __objRest(_a2, ["__scopeContextMenu"]), c8 = x5(o11);
  return u3.createElement(Item2, _extends2({}, c8, r12, { ref: n6 }));
});
var ContextMenuTriggerItem = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: o11 } = _a2, r12 = __objRest(_a2, ["__scopeContextMenu"]), c8 = x5(o11);
  return u3.createElement(SubTrigger, _extends2({}, c8, r12, { ref: n6 }));
});
var ContextMenuArrow = /* @__PURE__ */ u3.forwardRef((e11, n6) => {
  const _a2 = e11, { __scopeContextMenu: o11 } = _a2, r12 = __objRest(_a2, ["__scopeContextMenu"]), c8 = x5(o11);
  return u3.createElement(Arrow3, _extends2({}, c8, r12, { ref: n6 }));
});
function d6(e11) {
  return (t12) => t12.pointerType !== "mouse" ? e11(t12) : void 0;
}
var Root10 = ContextMenu;
var Trigger5 = ContextMenuTrigger;
var Content7 = ContextMenuContent;

// ../../packages/tldraw/dist/index.mjs
var React75 = __toESM(require_react(), 1);
var React76 = __toESM(require_react(), 1);
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a7, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp4.call(b7, prop))
      __defNormalProp5(a7, prop, b7[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b7)) {
      if (__propIsEnum4.call(b7, prop))
        __defNormalProp5(a7, prop, b7[prop]);
    }
  return a7;
};
var __spreadProps4 = (a7, b7) => __defProps4(a7, __getOwnPropDescs4(b7));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp5(target, name, { get: all[name], enumerable: true });
};
var __publicField3 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject2) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e11) {
        reject2(e11);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e11) {
        reject2(e11);
      }
    };
    var step = (x6) => x6.done ? resolve(x6.value) : Promise.resolve(x6.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var supported;
var supported_default;
var init_supported = __esm({
  "src/state/data/browser-fs-access/supported.js"() {
    supported = (() => {
      if (typeof self === "undefined") {
        return false;
      }
      if ("top" in self && self !== top) {
        try {
          top.location + "";
        } catch (e11) {
          return false;
        }
      } else if ("showOpenFilePicker" in self) {
        return "showOpenFilePicker";
      }
      return false;
    })();
    supported_default = supported;
  }
});
var file_open_exports = {};
__export(file_open_exports, {
  default: () => file_open_default
});
var file_open_default;
var init_file_open = __esm({
  "src/state/data/browser-fs-access/legacy/file-open.js"() {
    file_open_default = (..._0) => __async2(void 0, [..._0], function* (options2 = [{}]) {
      if (!Array.isArray(options2)) {
        options2 = [options2];
      }
      return new Promise((resolve, reject2) => {
        const input = document.createElement("input");
        input.type = "file";
        const accept = [
          ...options2.map((option) => option.mimeTypes || []).join(),
          options2.map((option) => option.extensions || []).join()
        ].join();
        input.multiple = options2[0].multiple || false;
        input.accept = accept || "";
        const _reject = () => cleanupListenersAndMaybeReject(reject2);
        const _resolve = (value) => {
          if (typeof cleanupListenersAndMaybeReject === "function") {
            cleanupListenersAndMaybeReject();
          }
          resolve(value);
        };
        const cleanupListenersAndMaybeReject = options2[0].legacySetup && options2[0].legacySetup(_resolve, _reject, input);
        input.addEventListener("change", () => {
          _resolve(input.multiple ? Array.from(input.files) : input.files[0]);
        });
        input.click();
      });
    });
  }
});
var file_open_exports2 = {};
__export(file_open_exports2, {
  default: () => file_open_default2
});
var getFileWithHandle;
var file_open_default2;
var init_file_open2 = __esm({
  "src/state/data/browser-fs-access/fs-access/file-open.js"() {
    getFileWithHandle = (handle) => __async2(void 0, null, function* () {
      const file = yield handle.getFile();
      file.handle = handle;
      return file;
    });
    file_open_default2 = (..._0) => __async2(void 0, [..._0], function* (options2 = [{}]) {
      if (!Array.isArray(options2)) {
        options2 = [options2];
      }
      const types = [];
      options2.forEach((option, i8) => {
        types[i8] = {
          description: option.description || "",
          accept: {}
        };
        if (option.mimeTypes) {
          option.mimeTypes.map((mimeType) => {
            types[i8].accept[mimeType] = option.extensions || [];
          });
        } else {
          types[i8].accept["*/*"] = option.extensions || [];
        }
      });
      const handleOrHandles = yield window.showOpenFilePicker({
        id: options2[0].id,
        startIn: options2[0].startIn,
        types,
        multiple: options2[0].multiple || false,
        excludeAcceptAllOption: options2[0].excludeAcceptAllOption || false
      });
      const files = yield Promise.all(handleOrHandles.map(getFileWithHandle));
      if (options2[0].multiple) {
        return files;
      }
      return files[0];
    });
  }
});
function fileOpen(...args2) {
  return __async2(this, null, function* () {
    return (yield implementation).default(...args2);
  });
}
var implementation;
var init_file_open3 = __esm({
  "src/state/data/browser-fs-access/file-open.js"() {
    init_supported();
    implementation = !supported_default ? Promise.resolve().then(() => (init_file_open(), file_open_exports)) : Promise.resolve().then(() => (init_file_open2(), file_open_exports2));
  }
});
var directory_open_exports = {};
__export(directory_open_exports, {
  default: () => directory_open_default
});
var directory_open_default;
var init_directory_open = __esm({
  "src/state/data/browser-fs-access/legacy/directory-open.js"() {
    directory_open_default = (..._0) => __async2(void 0, [..._0], function* (options2 = [{}]) {
      if (!Array.isArray(options2)) {
        options2 = [options2];
      }
      options2[0].recursive = options2[0].recursive || false;
      return new Promise((resolve, reject2) => {
        const input = document.createElement("input");
        input.type = "file";
        input.webkitdirectory = true;
        const _reject = () => cleanupListenersAndMaybeReject(reject2);
        const _resolve = (value) => {
          if (typeof cleanupListenersAndMaybeReject === "function") {
            cleanupListenersAndMaybeReject();
          }
          resolve(value);
        };
        const cleanupListenersAndMaybeReject = options2[0].legacySetup && options2[0].legacySetup(_resolve, _reject, input);
        input.addEventListener("change", () => {
          let files = Array.from(input.files);
          if (!options2[0].recursive) {
            files = files.filter((file) => {
              return file.webkitRelativePath.split("/").length === 2;
            });
          } else if (options2[0].recursive && options2[0].skipDirectory) {
            files = files.filter((file) => {
              const directoriesName = file.webkitRelativePath.split("/");
              return directoriesName.every((directoryName) => !options2[0].skipDirectory({
                name: directoryName,
                kind: "directory"
              }));
            });
          }
          _resolve(files);
        });
        input.click();
      });
    });
  }
});
var directory_open_exports2 = {};
__export(directory_open_exports2, {
  default: () => directory_open_default2
});
var getFiles;
var directory_open_default2;
var init_directory_open2 = __esm({
  "src/state/data/browser-fs-access/fs-access/directory-open.js"() {
    getFiles = (_0, _1, ..._22) => __async2(void 0, [_0, _1, ..._22], function* (dirHandle, recursive, path = dirHandle.name, skipDirectory) {
      const dirs = [];
      const files = [];
      for (const entry of dirHandle.values()) {
        const nestedPath = `${path}/${entry.name}`;
        if (entry.kind === "file") {
          files.push(yield entry.getFile().then((file) => {
            file.directoryHandle = dirHandle;
            return Object.defineProperty(file, "webkitRelativePath", {
              configurable: true,
              enumerable: true,
              get: () => nestedPath
            });
          }));
        } else if (entry.kind === "directory" && recursive && (!skipDirectory || !skipDirectory(entry))) {
          dirs.push(yield getFiles(entry, recursive, nestedPath, skipDirectory));
        }
      }
      return [...(yield Promise.all(dirs)).flat(), ...yield Promise.all(files)];
    });
    directory_open_default2 = (..._0) => __async2(void 0, [..._0], function* (options2 = {}) {
      options2.recursive = options2.recursive || false;
      const handle = yield window.showDirectoryPicker({
        id: options2.id,
        startIn: options2.startIn
      });
      return getFiles(handle, options2.recursive, void 0, options2.skipDirectory);
    });
  }
});
function directoryOpen(...args2) {
  return __async2(this, null, function* () {
    return (yield implementation2).default(...args2);
  });
}
var implementation2;
var init_directory_open3 = __esm({
  "src/state/data/browser-fs-access/directory-open.js"() {
    init_supported();
    implementation2 = !supported_default ? Promise.resolve().then(() => (init_directory_open(), directory_open_exports)) : Promise.resolve().then(() => (init_directory_open2(), directory_open_exports2));
  }
});
var file_save_exports = {};
__export(file_save_exports, {
  default: () => file_save_default
});
function streamToBlob(stream, type) {
  return __async2(this, null, function* () {
    const reader = stream.getReader();
    const pumpedStream = new ReadableStream({
      start(controller) {
        return pump();
        function pump() {
          return __async2(this, null, function* () {
            return reader.read().then(({ done, value }) => {
              if (done) {
                controller.close();
                return;
              }
              controller.enqueue(value);
              return pump();
            });
          });
        }
      }
    });
    const res = new Response(pumpedStream);
    reader.releaseLock();
    return new Blob([yield res.blob()], { type });
  });
}
var file_save_default;
var init_file_save = __esm({
  "src/state/data/browser-fs-access/legacy/file-save.js"() {
    file_save_default = (_0, ..._1) => __async2(void 0, [_0, ..._1], function* (blobOrResponse, options2 = {}) {
      if (Array.isArray(options2)) {
        options2 = options2[0];
      }
      const a7 = document.createElement("a");
      let data = blobOrResponse;
      if ("body" in blobOrResponse) {
        data = yield streamToBlob(blobOrResponse.body, blobOrResponse.headers.get("content-type"));
      }
      a7.download = options2.fileName || "Untitled";
      a7.href = URL.createObjectURL(data);
      const _reject = () => cleanupListenersAndMaybeReject(reject);
      const _resolve = () => {
        if (typeof cleanupListenersAndMaybeReject === "function") {
          cleanupListenersAndMaybeReject();
        }
      };
      const cleanupListenersAndMaybeReject = options2.legacySetup && options2.legacySetup(_resolve, _reject, a7);
      a7.addEventListener("click", () => {
        setTimeout(() => URL.revokeObjectURL(a7.href), 30 * 1e3);
        _resolve(null);
      });
      a7.click();
      return null;
    });
  }
});
var file_save_exports2 = {};
__export(file_save_exports2, {
  default: () => file_save_default2
});
var file_save_default2;
var init_file_save2 = __esm({
  "src/state/data/browser-fs-access/fs-access/file-save.js"() {
    file_save_default2 = (_0, ..._1) => __async2(void 0, [_0, ..._1], function* (blobOrResponse, options2 = [{}], existingHandle = null, throwIfExistingHandleNotGood = false) {
      if (!Array.isArray(options2)) {
        options2 = [options2];
      }
      options2[0].fileName = options2[0].fileName || "Untitled";
      const types = [];
      options2.forEach((option, i8) => {
        types[i8] = {
          description: option.description || "",
          accept: {}
        };
        if (option.mimeTypes) {
          if (i8 === 0) {
            if (blobOrResponse.type) {
              option.mimeTypes.push(blobOrResponse.type);
            } else if (blobOrResponse.headers && blobOrResponse.headers.get("content-type")) {
              option.mimeTypes.push(blobOrResponse.headers.get("content-type"));
            }
          }
          option.mimeTypes.map((mimeType) => {
            types[i8].accept[mimeType] = option.extensions || [];
          });
        } else if (blobOrResponse.type) {
          types[i8].accept[blobOrResponse.type] = option.extensions || [];
        }
      });
      if (existingHandle) {
        try {
          yield existingHandle.getFile();
        } catch (err) {
          existingHandle = null;
          if (throwIfExistingHandleNotGood) {
            throw err;
          }
        }
      }
      const handle = existingHandle || (yield window.showSaveFilePicker({
        suggestedName: options2[0].fileName,
        id: options2[0].id,
        startIn: options2[0].startIn,
        types,
        excludeAcceptAllOption: options2[0].excludeAcceptAllOption || false
      }));
      const writable = yield handle.createWritable();
      if ("stream" in blobOrResponse) {
        const stream = blobOrResponse.stream();
        yield stream.pipeTo(writable);
        return handle;
      } else if ("body" in blobOrResponse) {
        yield blobOrResponse.body.pipeTo(writable);
        return handle;
      }
      yield writable.write(blob);
      yield writable.close();
      return handle;
    });
  }
});
function fileSave(...args2) {
  return __async2(this, null, function* () {
    return (yield implementation3).default(...args2);
  });
}
var implementation3;
var init_file_save3 = __esm({
  "src/state/data/browser-fs-access/file-save.js"() {
    init_supported();
    implementation3 = !supported_default ? Promise.resolve().then(() => (init_file_save(), file_save_exports)) : Promise.resolve().then(() => (init_file_save2(), file_save_exports2));
  }
});
var browser_fs_access_exports = {};
__export(browser_fs_access_exports, {
  directoryOpen: () => directoryOpen,
  fileOpen: () => fileOpen,
  fileSave: () => fileSave,
  supported: () => supported_default
});
var init_browser_fs_access = __esm({
  "src/state/data/browser-fs-access/index.js"() {
    init_file_open3();
    init_directory_open3();
    init_file_save3();
    init_supported();
  }
});
var { styled, createTheme } = q({
  themeMap: __spreadValues4({}, n),
  theme: {
    colors: {
      bounds: "rgba(65, 132, 244, 1.000)",
      boundsBg: "rgba(65, 132, 244, 0.05)",
      hover: "#ececec",
      overlay: "rgba(0, 0, 0, 0.15)",
      overlayContrast: "rgba(255, 255, 255, 0.15)",
      panel: "#fefefe",
      panelContrast: "#ffffff",
      selected: "rgba(66, 133, 244, 1.000)",
      selectedContrast: "#fefefe",
      sponsor: "#ec6cb9",
      sponsorContrast: "#ec6cb944",
      text: "#333333",
      tooltip: "#1d1d1d",
      tooltipContrast: "#ffffff",
      warn: "rgba(255, 100, 100, 1)"
    },
    shadows: {
      2: "0px 1px 1px rgba(0, 0, 0, 0.14)",
      3: "0px 2px 3px rgba(0, 0, 0, 0.14)",
      4: "0px 4px 5px -1px rgba(0, 0, 0, 0.14)",
      8: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      12: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      24: "0px 24px 38px rgba(0, 0, 0, 0.14)",
      key: "1px 1px rgba(0,0,0,1)",
      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -8px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -12px rgba(0, 0, 0, 0.12),
        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`
    },
    space: {
      0: "2px",
      1: "3px",
      2: "4px",
      3: "8px",
      4: "12px",
      5: "16px",
      6: "32px",
      7: "48px"
    },
    fontSizes: {
      0: "10px",
      1: "12px",
      2: "13px",
      3: "16px",
      4: "18px"
    },
    fonts: {
      ui: '"Recursive", system-ui, sans-serif',
      body: '"Recursive", system-ui, sans-serif',
      mono: '"Recursive Mono", monospace'
    },
    fontWeights: {},
    lineHeights: {},
    letterSpacings: {},
    sizes: {},
    borderWidths: {
      0: "$1"
    },
    borderStyles: {},
    radii: {
      0: "2px",
      1: "4px",
      2: "8px",
      3: "12px",
      4: "16px"
    },
    zIndices: {},
    transitions: {}
  },
  media: {
    micro: "(max-width: 370px)",
    sm: "(min-width: 640px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 1024px)"
  },
  utils: {
    zStrokeWidth: () => (value) => {
      if (Array.isArray(value)) {
        return {
          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`
        };
      }
      return {
        strokeWidth: `calc(${value}px / var(--camera-zoom))`
      };
    }
  }
});
var dark = createTheme({
  colors: {
    bounds: "rgba(38, 150, 255, 1.000)",
    boundsBg: "rgba(38, 150, 255, 0.05)",
    hover: "#444A50",
    overlay: "rgba(0, 0, 0, 0.15)",
    overlayContrast: "rgba(255, 255, 255, 0.15)",
    panel: "#363D44",
    panelContrast: "#49555f",
    selected: "rgba(38, 150, 255, 1.000)",
    selectedContrast: "#fefefe",
    text: "#f8f9fa",
    tooltip: "#1d1d1d",
    tooltipContrast: "#ffffff"
  },
  shadows: {
    2: "0px 1px 1px rgba(0, 0, 0, 0.24)",
    3: "0px 2px 3px rgba(0, 0, 0, 0.24)",
    4: "0px 4px 5px -1px rgba(0, 0, 0, 0.24)",
    8: "0px 12px 17px rgba(0, 0, 0, 0.24)",
    12: "0px 12px 17px rgba(0, 0, 0, 0.24)",
    24: "0px 24px 38px rgba(0, 0, 0, 0.24)",
    panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
      0px 0px 16px -8px rgba(0, 0, 0, 0.09), 
      0px 0px 16px -12px rgba(0, 0, 0, 0.2)`
  }
});
var TDEventHandler = class {
  constructor() {
    __publicField3(this, "onPinchStart");
    __publicField3(this, "onPinchEnd");
    __publicField3(this, "onPinch");
    __publicField3(this, "onKeyDown");
    __publicField3(this, "onKeyUp");
    __publicField3(this, "onPointerMove");
    __publicField3(this, "onPointerUp");
    __publicField3(this, "onPan");
    __publicField3(this, "onZoom");
    __publicField3(this, "onPointerDown");
    __publicField3(this, "onPointCanvas");
    __publicField3(this, "onDoubleClickCanvas");
    __publicField3(this, "onRightPointCanvas");
    __publicField3(this, "onDragCanvas");
    __publicField3(this, "onReleaseCanvas");
    __publicField3(this, "onPointShape");
    __publicField3(this, "onDoubleClickShape");
    __publicField3(this, "onRightPointShape");
    __publicField3(this, "onDragShape");
    __publicField3(this, "onHoverShape");
    __publicField3(this, "onUnhoverShape");
    __publicField3(this, "onReleaseShape");
    __publicField3(this, "onPointBounds");
    __publicField3(this, "onDoubleClickBounds");
    __publicField3(this, "onRightPointBounds");
    __publicField3(this, "onDragBounds");
    __publicField3(this, "onHoverBounds");
    __publicField3(this, "onUnhoverBounds");
    __publicField3(this, "onReleaseBounds");
    __publicField3(this, "onPointBoundsHandle");
    __publicField3(this, "onDoubleClickBoundsHandle");
    __publicField3(this, "onRightPointBoundsHandle");
    __publicField3(this, "onDragBoundsHandle");
    __publicField3(this, "onHoverBoundsHandle");
    __publicField3(this, "onUnhoverBoundsHandle");
    __publicField3(this, "onReleaseBoundsHandle");
    __publicField3(this, "onPointHandle");
    __publicField3(this, "onDoubleClickHandle");
    __publicField3(this, "onRightPointHandle");
    __publicField3(this, "onDragHandle");
    __publicField3(this, "onHoverHandle");
    __publicField3(this, "onUnhoverHandle");
    __publicField3(this, "onReleaseHandle");
    __publicField3(this, "onShapeBlur");
    __publicField3(this, "onShapeClone");
  }
};
var SizeStyle = /* @__PURE__ */ ((SizeStyle2) => {
  SizeStyle2["Small"] = "small";
  SizeStyle2["Medium"] = "medium";
  SizeStyle2["Large"] = "large";
  return SizeStyle2;
})(SizeStyle || {});
var DashStyle = /* @__PURE__ */ ((DashStyle2) => {
  DashStyle2["Draw"] = "draw";
  DashStyle2["Solid"] = "solid";
  DashStyle2["Dashed"] = "dashed";
  DashStyle2["Dotted"] = "dotted";
  return DashStyle2;
})(DashStyle || {});
var AlignStyle = /* @__PURE__ */ ((AlignStyle2) => {
  AlignStyle2["Start"] = "start";
  AlignStyle2["Middle"] = "middle";
  AlignStyle2["End"] = "end";
  AlignStyle2["Justify"] = "justify";
  return AlignStyle2;
})(AlignStyle || {});
var FontStyle = /* @__PURE__ */ ((FontStyle2) => {
  FontStyle2["Script"] = "script";
  FontStyle2["Sans"] = "sans";
  FontStyle2["Serif"] = "erif";
  FontStyle2["Mono"] = "mono";
  return FontStyle2;
})(FontStyle || {});
function migrate(document2, newVersion) {
  const { version = 0 } = document2;
  if (!("assets" in document2)) {
    document2.assets = {};
  }
  const assetIdsInUse = /* @__PURE__ */ new Set();
  Object.values(document2.pages).forEach((page) => Object.values(page.shapes).forEach((shape) => {
    const { parentId, children, assetId } = shape;
    if (assetId) {
      assetIdsInUse.add(assetId);
    }
    if (parentId !== page.id && !page.shapes[parentId]) {
      console.warn("Encountered a shape with a missing parent!");
      shape.parentId = page.id;
    }
    if (shape.type === "group" && children) {
      children.forEach((childId) => {
        if (!page.shapes[childId]) {
          console.warn("Encountered a parent with a missing child!", shape.id, childId);
          children == null ? void 0 : children.splice(children.indexOf(childId), 1);
        }
      });
    }
  }));
  Object.keys(document2.assets).forEach((assetId) => {
    if (!assetIdsInUse.has(assetId)) {
      delete document2.assets[assetId];
    }
  });
  if (version === newVersion)
    return document2;
  if (version < 14) {
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.shapes).filter((shape) => shape.type === "text").forEach((shape) => shape.style.font === "script");
    });
  }
  if (version <= 13) {
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.bindings).forEach((binding) => {
        Object.assign(binding, binding.meta);
      });
      Object.values(page.shapes).forEach((shape) => {
        Object.entries(shape.style).forEach(([id, style]) => {
          if (typeof style === "string") {
            shape.style[id] = style.toLowerCase();
          }
        });
        if (shape.type === "arrow") {
          if (shape.decorations) {
            Object.entries(shape.decorations).forEach(([id, decoration]) => {
              if (decoration === "Arrow") {
                shape.decorations = __spreadProps4(__spreadValues4({}, shape.decorations), {
                  [id]: "arrow"
                });
              }
            });
          }
        }
      });
    });
  }
  if (version <= 13.1) {
    document2.name = "New Document";
  }
  if (version < 15) {
    document2.assets = {};
  }
  Object.values(document2.pages).forEach((page) => {
    Object.values(page.shapes).forEach((shape) => {
      if (version < 15.2) {
        if (shape.type === "image" || shape.type === "video") {
          shape.style.isFilled = true;
        }
      }
      if (version < 15.3) {
        if (shape.type === "rectangle" || shape.type === "triangle" || shape.type === "ellipse" || shape.type === "arrow") {
          shape.label = shape.text || "";
          shape.labelPoint = [0.5, 0.5];
        }
      }
    });
  });
  Object.values(document2.pageStates).forEach((pageState) => {
    pageState.selectedIds = pageState.selectedIds.filter((id) => {
      return document2.pages[pageState.id].shapes[id] !== void 0;
    });
    pageState.bindingId = void 0;
    pageState.editingId = void 0;
    pageState.hoveredId = void 0;
    pageState.pointedId = void 0;
  });
  document2.version = newVersion;
  return document2;
}
var LETTER_SPACING = "-0.03em";
var LINE_HEIGHT3 = 1.3;
var GRID_SIZE = 8;
var SVG_EXPORT_PADDING = 16;
var BINDING_DISTANCE = 16;
var CLONING_DISTANCE = 32;
var FIT_TO_SCREEN_PADDING = 128;
var SNAP_DISTANCE = 5;
var SLOW_SPEED = 10;
var GHOSTED_OPACITY = 0.3;
var DEAD_ZONE = 3;
var LABEL_POINT = [0.5, 0.5];
var PI2 = Math.PI * 2;
var EASINGS = {
  linear: (t12) => t12,
  easeInQuad: (t12) => t12 * t12,
  easeOutQuad: (t12) => t12 * (2 - t12),
  easeInOutQuad: (t12) => t12 < 0.5 ? 2 * t12 * t12 : -1 + (4 - 2 * t12) * t12,
  easeInCubic: (t12) => t12 * t12 * t12,
  easeOutCubic: (t12) => --t12 * t12 * t12 + 1,
  easeInOutCubic: (t12) => t12 < 0.5 ? 4 * t12 * t12 * t12 : (t12 - 1) * (2 * t12 - 2) * (2 * t12 - 2) + 1,
  easeInQuart: (t12) => t12 * t12 * t12 * t12,
  easeOutQuart: (t12) => 1 - --t12 * t12 * t12 * t12,
  easeInOutQuart: (t12) => t12 < 0.5 ? 8 * t12 * t12 * t12 * t12 : 1 - 8 * --t12 * t12 * t12 * t12,
  easeInQuint: (t12) => t12 * t12 * t12 * t12 * t12,
  easeOutQuint: (t12) => 1 + --t12 * t12 * t12 * t12 * t12,
  easeInOutQuint: (t12) => t12 < 0.5 ? 16 * t12 * t12 * t12 * t12 * t12 : 1 + 16 * --t12 * t12 * t12 * t12 * t12,
  easeInSine: (t12) => 1 - Math.cos(t12 * Math.PI / 2),
  easeOutSine: (t12) => Math.sin(t12 * Math.PI / 2),
  easeInOutSine: (t12) => -(Math.cos(Math.PI * t12) - 1) / 2,
  easeInExpo: (t12) => t12 <= 0 ? 0 : Math.pow(2, 10 * t12 - 10),
  easeOutExpo: (t12) => t12 >= 1 ? 1 : 1 - Math.pow(2, -10 * t12),
  easeInOutExpo: (t12) => t12 <= 0 ? 0 : t12 >= 1 ? 1 : t12 < 0.5 ? Math.pow(2, 20 * t12 - 10) / 2 : (2 - Math.pow(2, -20 * t12 + 10)) / 2
};
var USER_COLORS = [
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467",
  "#FF802B"
];
var isSafari = typeof Window === "undefined" ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var IMAGE_EXTENSIONS = [".png", ".svg", ".jpg", ".jpeg", ".gif"];
var VIDEO_EXTENSIONS = isSafari ? [] : [".mp4", ".webm"];
var options = { mode: "readwrite" };
var checkPermissions = (handle) => __async2(void 0, null, function* () {
  return (yield handle.queryPermission(options)) === "granted" || (yield handle.requestPermission(options)) === "granted";
});
function loadFileHandle() {
  return __async2(this, null, function* () {
    if (typeof Window === "undefined" || !("_location" in Window))
      return;
    const fileHandle = yield get3(`Tldraw_file_handle_${window.location.origin}`);
    if (!fileHandle)
      return null;
    return fileHandle;
  });
}
function saveFileHandle(fileHandle) {
  return __async2(this, null, function* () {
    return set4(`Tldraw_file_handle_${window.location.origin}`, fileHandle);
  });
}
function saveToFileSystem(document2, fileHandle) {
  return __async2(this, null, function* () {
    const file = {
      name: document2.name || "New Document",
      fileHandle: fileHandle != null ? fileHandle : null,
      document: document2,
      assets: {}
    };
    const json = JSON.stringify(file, null, 2);
    const blob2 = new Blob([json], {
      type: "application/vnd.Tldraw+json"
    });
    if (fileHandle) {
      const hasPermissions = yield checkPermissions(fileHandle);
      if (!hasPermissions)
        return null;
    }
    const browserFS = yield Promise.resolve().then(() => (init_browser_fs_access(), browser_fs_access_exports));
    const fileSave2 = browserFS.fileSave;
    const newFileHandle = yield fileSave2(blob2, {
      fileName: `${file.name}.tldr`,
      description: "Tldraw File",
      extensions: [`.tldr`]
    }, fileHandle);
    yield saveFileHandle(newFileHandle);
    return newFileHandle;
  });
}
function openFromFileSystem() {
  return __async2(this, null, function* () {
    var _a2;
    const browserFS = yield Promise.resolve().then(() => (init_browser_fs_access(), browser_fs_access_exports));
    const fileOpen2 = browserFS.fileOpen;
    const blob2 = yield fileOpen2({
      description: "Tldraw File",
      extensions: [`.tldr`],
      multiple: false
    });
    if (!blob2)
      return null;
    const json = yield new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.readyState === FileReader.DONE) {
          resolve(reader.result);
        }
      };
      reader.readAsText(blob2, "utf8");
    });
    const file = JSON.parse(json);
    const fileHandle = (_a2 = blob2.handle) != null ? _a2 : null;
    yield saveFileHandle(fileHandle);
    return {
      fileHandle,
      document: file.document
    };
  });
}
function openAssetFromFileSystem() {
  return __async2(this, null, function* () {
    const browserFS = yield Promise.resolve().then(() => (init_browser_fs_access(), browser_fs_access_exports));
    const fileOpen2 = browserFS.fileOpen;
    return fileOpen2({
      description: "Image or Video",
      extensions: [...IMAGE_EXTENSIONS, ...VIDEO_EXTENSIONS],
      multiple: false
    });
  });
}
function fileToBase64(file) {
  return new Promise((resolve, reject2) => {
    if (file) {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject2(error);
      reader.onabort = (error) => reject2(error);
    }
  });
}
function fileToText(file) {
  return new Promise((resolve, reject2) => {
    if (file) {
      const reader = new FileReader();
      reader.readAsText(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject2(error);
      reader.onabort = (error) => reject2(error);
    }
  });
}
function getImageSizeFromSrc(src) {
  return new Promise((resolve, reject2) => {
    const img = new Image();
    img.onload = () => resolve([img.width, img.height]);
    img.onerror = () => reject2(new Error("Could not get image size"));
    img.src = src;
  });
}
function getVideoSizeFromSrc(src) {
  return new Promise((resolve, reject2) => {
    const video = document.createElement("video");
    video.onloadedmetadata = () => resolve([video.videoWidth, video.videoHeight]);
    video.onerror = () => reject2(new Error("Could not get video size"));
    video.src = src;
  });
}
init_browser_fs_access();
var canvasLight = "#fafafa";
var canvasDark = "#343d45";
var colors = {
  ["white"]: "#f0f1f3",
  ["lightGray"]: "#c6cbd1",
  ["gray"]: "#788492",
  ["black"]: "#1d1d1d",
  ["green"]: "#36b24d",
  ["cyan"]: "#0e98ad",
  ["blue"]: "#1c7ed6",
  ["indigo"]: "#4263eb",
  ["violet"]: "#7746f1",
  ["red"]: "#ff2133",
  ["orange"]: "#ff9433",
  ["yellow"]: "#ffc936"
};
var stickyFills = {
  light: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k4, v6]) => [k4, Utils.lerpColor(v6, canvasLight, 0.45)]))), {
    ["white"]: "#ffffff",
    ["black"]: "#3d3d3d"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k4, v6]) => [
    k4,
    Utils.lerpColor(Utils.lerpColor(v6, "#999999", 0.3), canvasDark, 0.4)
  ]))), {
    ["white"]: "#1d1d1d",
    ["black"]: "#bbbbbb"
  })
};
var strokes = {
  light: __spreadProps4(__spreadValues4({}, colors), {
    ["white"]: "#1d1d1d"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k4, v6]) => [k4, Utils.lerpColor(v6, canvasDark, 0.1)]))), {
    ["white"]: "#cecece",
    ["black"]: "#cecece"
  })
};
var fills = {
  light: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k4, v6]) => [k4, Utils.lerpColor(v6, canvasLight, 0.82)]))), {
    ["white"]: "#fefefe"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k4, v6]) => [k4, Utils.lerpColor(v6, canvasDark, 0.82)]))), {
    ["white"]: "rgb(30,33,37)",
    ["black"]: "#1e1e1f"
  })
};
var strokeWidths = {
  ["small"]: 2,
  ["medium"]: 3.5,
  ["large"]: 5
};
var fontSizes = {
  ["small"]: 28,
  ["medium"]: 48,
  ["large"]: 96,
  auto: "auto"
};
var fontFaces = {
  ["script"]: '"Caveat Brush"',
  ["sans"]: '"Source Sans Pro"',
  ["erif"]: '"Crimson Pro"',
  ["mono"]: '"Source Code Pro"'
};
var fontSizeModifiers = {
  ["script"]: 1,
  ["sans"]: 1,
  ["erif"]: 1,
  ["mono"]: 1
};
var stickyFontSizes = {
  ["small"]: 24,
  ["medium"]: 36,
  ["large"]: 48,
  auto: "auto"
};
function getStrokeWidth(size) {
  return strokeWidths[size];
}
function getFontSize(size, fontStyle = "script") {
  return fontSizes[size] * fontSizeModifiers[fontStyle];
}
function getFontFace(font = "script") {
  return fontFaces[font];
}
function getStickyFontSize(size) {
  return stickyFontSizes[size];
}
function getFontStyle(style) {
  const fontSize = getFontSize(style.size, style.font);
  const fontFace = getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyFontStyle(style) {
  const fontSize = getStickyFontSize(style.size);
  const fontFace = getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyShapeStyle(style, isDarkMode = false) {
  const { color } = style;
  const theme = isDarkMode ? "dark" : "light";
  const adjustedColor = color === "white" || color === "black" ? "yellow" : color;
  return {
    fill: stickyFills[theme][adjustedColor],
    stroke: strokes[theme][adjustedColor],
    color: isDarkMode ? "#1d1d1d" : "#0d0d0d"
  };
}
function getShapeStyle(style, isDarkMode) {
  const { color, size, isFilled } = style;
  const strokeWidth = getStrokeWidth(size);
  const theme = isDarkMode ? "dark" : "light";
  return {
    stroke: strokes[theme][color],
    fill: isFilled ? fills[theme][color] : "none",
    strokeWidth
  };
}
var defaultStyle = {
  color: "black",
  size: "small",
  isFilled: false,
  dash: "draw",
  scale: 1
};
var defaultTextStyle = __spreadProps4(__spreadValues4({}, defaultStyle), {
  font: "script",
  textAlign: "middle"
});
var ALIGN_VALUES = {
  ["start"]: "left",
  ["middle"]: "center",
  ["end"]: "right",
  ["justify"]: "justify"
};
function getTextAlign(alignStyle = "start") {
  return ALIGN_VALUES[alignStyle];
}
function getTextSvgElement(text2, style, bounds) {
  const fontSize = getFontSize(style.size, style.font);
  const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
  const textLines = text2.split("\n").map((line, i8) => {
    const textElm = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textElm.textContent = line;
    textElm.setAttribute("y", LINE_HEIGHT3 * fontSize * (0.5 + i8) + "");
    g6.appendChild(textElm);
    return textElm;
  });
  g6.setAttribute("font-size", fontSize + "");
  g6.setAttribute("font-family", getFontFace(style.font).slice(1, -1));
  g6.setAttribute("text-align", getTextAlign(style.textAlign));
  switch (style.textAlign) {
    case "middle": {
      g6.setAttribute("text-align", "center");
      g6.setAttribute("text-anchor", "middle");
      textLines.forEach((textElm) => textElm.setAttribute("x", bounds.width / 2 + ""));
      break;
    }
    case "end": {
      g6.setAttribute("text-align", "right");
      g6.setAttribute("text-anchor", "end");
      textLines.forEach((textElm) => textElm.setAttribute("x", bounds.width + ""));
      break;
    }
    case "start": {
      g6.setAttribute("text-anchor", "start");
      g6.setAttribute("alignment-baseline", "central");
    }
  }
  return g6;
}
var melm;
function getMeasurementDiv() {
  var _a2;
  (_a2 = document.getElementById("__textLabelMeasure")) == null ? void 0 : _a2.remove();
  const pre = document.createElement("pre");
  pre.id = "__textLabelMeasure";
  Object.assign(pre.style, {
    whiteSpace: "pre",
    width: "auto",
    border: "1px solid transparent",
    padding: "4px",
    margin: "0px",
    letterSpacing: LETTER_SPACING,
    opacity: "0",
    position: "absolute",
    top: "-500px",
    left: "0px",
    zIndex: "9999",
    pointerEvents: "none",
    userSelect: "none",
    alignmentBaseline: "mathematical",
    dominantBaseline: "mathematical"
  });
  pre.tabIndex = -1;
  document.body.appendChild(pre);
  return pre;
}
if (typeof window !== "undefined") {
  melm = getMeasurementDiv();
}
var prevText = "";
var prevFont = "";
var prevSize = [0, 0];
function clearPrevSize() {
  prevText = "";
}
function getTextLabelSize(text2, font) {
  if (!text2) {
    return [16, 32];
  }
  if (!melm) {
    return [10, 10];
  }
  if (!melm.parent)
    document.body.appendChild(melm);
  if (text2 === prevText && font === prevFont) {
    return prevSize;
  }
  prevText = text2;
  prevFont = font;
  melm.textContent = text2;
  melm.style.font = font;
  const width = melm.offsetWidth || 1;
  const height = melm.offsetHeight || 1;
  prevSize = [width, height];
  return prevSize;
}
function getBoundsRectangle(shape, boundsCache) {
  const bounds = Utils.getFromCache(boundsCache, shape, () => {
    const [width, height] = shape.size;
    return {
      minX: 0,
      maxX: width,
      minY: 0,
      maxY: height,
      width,
      height
    };
  });
  return Utils.translateBounds(bounds, shape.point);
}
function transformRectangle(shape, bounds, { initialShape, transformOrigin, scaleX, scaleY }) {
  if (shape.rotation || initialShape.isAspectRatioLocked) {
    const size = src_default.toFixed(src_default.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));
    const point = src_default.toFixed([
      bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),
      bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])
    ]);
    const rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;
    return {
      size,
      point,
      rotation
    };
  } else {
    return {
      point: src_default.toFixed([bounds.minX, bounds.minY]),
      size: src_default.toFixed([bounds.width, bounds.height])
    };
  }
}
function transformSingleRectangle(shape, bounds) {
  return {
    size: src_default.toFixed([bounds.width, bounds.height]),
    point: src_default.toFixed([bounds.minX, bounds.minY])
  };
}
var INDENT = "  ";
var TextAreaUtils = class {
  static insertTextFirefox(field, text2) {
    field.setRangeText(text2, field.selectionStart || 0, field.selectionEnd || 0, "end");
    field.dispatchEvent(new InputEvent("input", {
      data: text2,
      inputType: "insertText",
      isComposing: false
    }));
  }
  static insert(field, text2) {
    const document2 = field.ownerDocument;
    const initialFocus = document2.activeElement;
    if (initialFocus !== field) {
      field.focus();
    }
    if (!document2.execCommand("insertText", false, text2)) {
      TextAreaUtils.insertTextFirefox(field, text2);
    }
    if (initialFocus === document2.body) {
      field.blur();
    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
      initialFocus.focus();
    }
  }
  static set(field, text2) {
    field.select();
    TextAreaUtils.insert(field, text2);
  }
  static getSelection(field) {
    const { selectionStart, selectionEnd } = field;
    return field.value.slice(selectionStart ? selectionStart : void 0, selectionEnd ? selectionEnd : void 0);
  }
  static wrapSelection(field, wrap, wrapEnd) {
    const { selectionStart, selectionEnd } = field;
    const selection = TextAreaUtils.getSelection(field);
    TextAreaUtils.insert(field, wrap + selection + (wrapEnd != null ? wrapEnd : wrap));
    field.selectionStart = (selectionStart || 0) + wrap.length;
    field.selectionEnd = (selectionEnd || 0) + wrap.length;
  }
  static replace(field, searchValue, replacer) {
    let drift = 0;
    field.value.replace(searchValue, (...args2) => {
      const matchStart = drift + args2[args2.length - 2];
      const matchLength = args2[0].length;
      field.selectionStart = matchStart;
      field.selectionEnd = matchStart + matchLength;
      const replacement = typeof replacer === "string" ? replacer : replacer(...args2);
      TextAreaUtils.insert(field, replacement);
      field.selectionStart = matchStart;
      drift += replacement.length - matchLength;
      return replacement;
    });
  }
  static findLineEnd(value, currentEnd) {
    const lastLineStart = value.lastIndexOf("\n", currentEnd - 1) + 1;
    if (value.charAt(lastLineStart) !== "	") {
      return currentEnd;
    }
    return lastLineStart + 1;
  }
  static indent(element2) {
    var _a2;
    const { selectionStart, selectionEnd, value } = element2;
    const selectedContrast = value.slice(selectionStart, selectionEnd);
    const lineBreakCount = (_a2 = /\n/g.exec(selectedContrast)) == null ? void 0 : _a2.length;
    if (lineBreakCount && lineBreakCount > 0) {
      const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
      const newSelection = element2.value.slice(firstLineStart, selectionEnd - 1);
      const indentedText = newSelection.replace(/^|\n/g, `$&${INDENT}`);
      const replacementsCount = indentedText.length - newSelection.length;
      element2.setSelectionRange(firstLineStart, selectionEnd - 1);
      TextAreaUtils.insert(element2, indentedText);
      element2.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);
    } else {
      TextAreaUtils.insert(element2, INDENT);
    }
  }
  static unindent(element2) {
    const { selectionStart, selectionEnd, value } = element2;
    const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd);
    const newSelection = element2.value.slice(firstLineStart, minimumSelectionEnd);
    const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, "$1");
    const replacementsCount = newSelection.length - indentedText.length;
    element2.setSelectionRange(firstLineStart, minimumSelectionEnd);
    TextAreaUtils.insert(element2, indentedText);
    const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));
    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;
    const newSelectionStart = selectionStart - difference;
    element2.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));
  }
};
var stopPropagation = (e11) => e11.stopPropagation();
function useTextKeyboardEvents(onChange2) {
  const handleKeyDown = React53.useCallback((e11) => {
    if (e11.metaKey)
      e11.stopPropagation();
    switch (e11.key) {
      case "Meta": {
        e11.stopPropagation();
        break;
      }
      case "z": {
        if (e11.metaKey) {
          if (e11.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          e11.preventDefault();
        }
        break;
      }
      case "Escape": {
        e11.currentTarget.blur();
        break;
      }
      case "Enter": {
        if (e11.ctrlKey || e11.metaKey) {
          e11.currentTarget.blur();
        }
        break;
      }
      case "Tab": {
        e11.preventDefault();
        if (e11.shiftKey) {
          TextAreaUtils.unindent(e11.currentTarget);
        } else {
          TextAreaUtils.indent(e11.currentTarget);
        }
        onChange2(TLDR.normalizeText(e11.currentTarget.value));
        break;
      }
    }
  }, [onChange2]);
  return handleKeyDown;
}
var TextLabel = React210.memo(function TextLabel2({
  font,
  text: text2,
  color,
  offsetX = 0,
  offsetY = 0,
  scale = 1,
  isEditing = false,
  onBlur,
  onChange: onChange2
}) {
  const rInput = React210.useRef(null);
  const rIsMounted = React210.useRef(false);
  const rTextContent = React210.useRef(text2);
  const handleChange = React210.useCallback((e11) => {
    rTextContent.current = TLDR.normalizeText(e11.currentTarget.value);
    onChange2(rTextContent.current);
  }, [onChange2]);
  const handleKeyDown = useTextKeyboardEvents(onChange2);
  const handleBlur = React210.useCallback((e11) => {
    e11.currentTarget.setSelectionRange(0, 0);
    onBlur == null ? void 0 : onBlur();
  }, [onBlur]);
  const handleFocus = React210.useCallback((e11) => {
    if (!isEditing)
      return;
    if (!rIsMounted.current)
      return;
    if (document.activeElement === e11.currentTarget) {
      e11.currentTarget.select();
    }
  }, [isEditing]);
  const handlePointerDown = React210.useCallback((e11) => {
    if (isEditing) {
      e11.stopPropagation();
    }
  }, [isEditing]);
  React210.useEffect(() => {
    if (isEditing) {
      rTextContent.current = text2;
      requestAnimationFrame(() => {
        rIsMounted.current = true;
        const elm = rInput.current;
        if (elm) {
          elm.focus();
          elm.select();
        }
      });
    } else {
      onBlur == null ? void 0 : onBlur();
    }
  }, [isEditing, onBlur]);
  const rInnerWrapper = React210.useRef(null);
  React210.useLayoutEffect(() => {
    const elm = rInnerWrapper.current;
    if (!elm)
      return;
    const size = getTextLabelSize(text2, font);
    elm.style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;
    elm.style.width = size[0] + 1 + "px";
    elm.style.height = size[1] + 1 + "px";
  }, [text2, font, offsetY, offsetX, scale]);
  return /* @__PURE__ */ React210.createElement(TextWrapper, null, /* @__PURE__ */ React210.createElement(InnerWrapper, {
    ref: rInnerWrapper,
    hasText: !!text2,
    isEditing,
    style: {
      font,
      color
    }
  }, isEditing ? /* @__PURE__ */ React210.createElement(TextArea, {
    ref: rInput,
    style: {
      font,
      color
    },
    name: "text",
    tabIndex: -1,
    autoComplete: "false",
    autoCapitalize: "false",
    autoCorrect: "false",
    autoSave: "false",
    autoFocus: true,
    placeholder: "",
    spellCheck: "true",
    wrap: "off",
    dir: "auto",
    datatype: "wysiwyg",
    defaultValue: rTextContent.current,
    color,
    onFocus: handleFocus,
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur,
    onPointerDown: handlePointerDown,
    onContextMenu: stopPropagation
  }) : text2, "\u200B"));
});
var TextWrapper = styled("div", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  pointerEvents: "none",
  userSelect: "none",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    }
  }
});
var commonTextWrapping = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var InnerWrapper = styled("div", __spreadValues4({
  position: "absolute",
  padding: "4px",
  zIndex: 1,
  minHeight: 1,
  minWidth: 1,
  lineHeight: 1,
  letterSpacing: LETTER_SPACING,
  outline: 0,
  fontWeight: "500",
  textAlign: "center",
  backfaceVisibility: "hidden",
  userSelect: "none",
  WebkitUserSelect: "none",
  WebkitTouchCallout: "none",
  variants: {
    hasText: {
      false: {
        pointerEvents: "none"
      },
      true: {
        pointerEvents: "all"
      }
    },
    isEditing: {
      false: {
        userSelect: "none"
      },
      true: {
        background: "$boundsBg",
        userSelect: "text",
        WebkitUserSelect: "text"
      }
    }
  }
}, commonTextWrapping));
var TextArea = styled("textarea", __spreadValues4({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  width: "100%",
  height: "100%",
  border: "none",
  padding: "4px",
  resize: "none",
  textAlign: "inherit",
  minHeight: "inherit",
  minWidth: "inherit",
  lineHeight: "inherit",
  letterSpacing: "inherit",
  outline: 0,
  fontWeight: "inherit",
  overflow: "hidden",
  backfaceVisibility: "hidden",
  display: "inline-block",
  pointerEvents: "all",
  background: "$boundsBg",
  userSelect: "text",
  WebkitUserSelect: "text",
  fontSmooth: "always",
  WebkitFontSmoothing: "subpixel-antialiased",
  MozOsxFontSmoothing: "auto"
}, commonTextWrapping));
var TDShapeUtil = class extends TLShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "canBind", false);
    __publicField3(this, "canEdit", false);
    __publicField3(this, "canClone", false);
    __publicField3(this, "isAspectRatioLocked", false);
    __publicField3(this, "hideResizeHandles", false);
    __publicField3(this, "bindingDistance", BINDING_DISTANCE);
    __publicField3(this, "hitTestPoint", (shape, point) => {
      return Utils.pointInBounds(point, this.getRotatedBounds(shape));
    });
    __publicField3(this, "hitTestLineSegment", (shape, A3, B4) => {
      const box2 = Utils.getBoundsFromPoints([A3, B4]);
      const bounds = this.getBounds(shape);
      return Utils.boundsContain(bounds, box2) || shape.rotation ? intersectLineSegmentPolyline(A3, B4, Utils.getRotatedCorners(this.getBounds(shape))).didIntersect : intersectLineSegmentBounds(A3, B4, this.getBounds(shape)).length > 0;
    });
    __publicField3(this, "create", (props) => {
      this.refMap.set(props.id, React310.createRef());
      return this.getShape(props);
    });
    __publicField3(this, "getCenter", (shape) => {
      return Utils.getBoundsCenter(this.getBounds(shape));
    });
    __publicField3(this, "getExpandedBounds", (shape) => {
      return Utils.expandBounds(this.getBounds(shape), this.bindingDistance);
    });
    __publicField3(this, "getBindingPoint", (shape, fromShape, point, origin, direction, bindAnywhere) => {
      const bounds = this.getBounds(shape);
      const expandedBounds = this.getExpandedBounds(shape);
      if (!Utils.pointInBounds(point, expandedBounds))
        return;
      const intersections = intersectRayBounds(origin, direction, expandedBounds).filter((int) => int.didIntersect).map((int) => int.points[0]);
      if (!intersections.length)
        return;
      const center = this.getCenter(shape);
      const intersection = intersections.sort((a7, b7) => Vec.dist(b7, origin) - Vec.dist(a7, origin))[0];
      const middlePoint = Vec.med(point, intersection);
      let anchor;
      let distance;
      if (bindAnywhere) {
        anchor = Vec.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
        distance = 0;
      } else {
        if (Vec.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
          anchor = center;
        } else {
          anchor = middlePoint;
        }
        if (Utils.pointInBounds(point, bounds)) {
          distance = this.bindingDistance;
        } else {
          distance = Math.max(this.bindingDistance, Utils.getBoundsSides(bounds).map((side) => Vec.distanceToLineSegment(side[1][0], side[1][1], point)).sort((a7, b7) => a7 - b7)[0]);
        }
      }
      const bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
        expandedBounds.width,
        expandedBounds.height
      ]);
      return {
        point: Vec.clampV(bindingPoint, 0, 1),
        distance
      };
    });
    __publicField3(this, "mutate", (shape, props) => {
      return props;
    });
    __publicField3(this, "transform", (shape, bounds, info) => {
      return __spreadProps4(__spreadValues4({}, shape), { point: [bounds.minX, bounds.minY] });
    });
    __publicField3(this, "transformSingle", (shape, bounds, info) => {
      return this.transform(shape, bounds, info);
    });
    __publicField3(this, "updateChildren");
    __publicField3(this, "onChildrenChange");
    __publicField3(this, "onHandleChange");
    __publicField3(this, "onRightPointHandle");
    __publicField3(this, "onDoubleClickHandle");
    __publicField3(this, "onDoubleClickBoundsHandle");
    __publicField3(this, "onSessionComplete");
    __publicField3(this, "getSvgElement", (shape) => {
      var _a2;
      const elm = (_a2 = document.getElementById(shape.id + "_svg")) == null ? void 0 : _a2.cloneNode(true);
      if (!elm)
        return;
      if ("label" in shape && shape.label !== void 0) {
        const s9 = shape;
        const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const bounds = this.getBounds(shape);
        const labelElm = getTextSvgElement(s9["label"], shape.style, bounds);
        labelElm.setAttribute("fill", getShapeStyle(shape.style).stroke);
        const font = getFontStyle(shape.style);
        const size = getTextLabelSize(s9["label"], font);
        labelElm.setAttribute("transform-origin", "top left");
        labelElm.setAttribute("transform", `translate(${(bounds.width - size[0]) / 2}, ${(bounds.height - size[1]) / 2})`);
        g6.appendChild(elm);
        g6.appendChild(labelElm);
        return g6;
      }
      return elm;
    });
  }
};
function getRectangleDrawPoints(id, style, size) {
  const styles22 = getShapeStyle(style);
  const getRandom = Utils.rng(id);
  const sw = styles22.strokeWidth;
  const w6 = Math.max(0, size[0]);
  const h4 = Math.max(0, size[1]);
  const offsets = Array.from(Array(4)).map(() => {
    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];
  });
  const tl = src_default.add([sw / 2, sw / 2], offsets[0]);
  const tr = src_default.add([w6 - sw / 2, sw / 2], offsets[1]);
  const br = src_default.add([w6 - sw / 2, h4 - sw / 2], offsets[2]);
  const bl = src_default.add([sw / 2, h4 - sw / 2], offsets[3]);
  const rm = Math.round(Math.abs(getRandom() * 2 * 4));
  const rx = Math.min(w6 / 4, sw * 2);
  const ry = Math.min(h4 / 4, sw * 2);
  const px = Math.max(8, Math.floor(w6 / 16));
  const py = Math.max(8, Math.floor(h4 / 16));
  const lines = Utils.rotateArray([
    src_default.pointsBetween(src_default.add(tl, [rx, 0]), src_default.sub(tr, [rx, 0]), px),
    src_default.pointsBetween(src_default.add(tr, [0, ry]), src_default.sub(br, [0, ry]), py),
    src_default.pointsBetween(src_default.sub(br, [rx, 0]), src_default.add(bl, [rx, 0]), px),
    src_default.pointsBetween(src_default.sub(bl, [0, ry]), src_default.add(tl, [0, ry]), py)
  ], rm);
  const points = [...lines.flat(), ...lines[0]].slice(5, Math.floor((rm % 2 === 0 ? px : py) / -2) + 3);
  return {
    points
  };
}
function getDrawStrokeInfo(id, style, size) {
  const { points } = getRectangleDrawPoints(id, style, size);
  const { strokeWidth } = getShapeStyle(style);
  const options2 = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options: options2 };
}
function getRectanglePath(id, style, size) {
  const { points, options: options2 } = getDrawStrokeInfo(id, style, size);
  const stroke = Te(points, options2);
  return Utils.getSvgPathFromStroke(stroke);
}
function getRectangleIndicatorPathTDSnapshot(id, style, size) {
  const { points, options: options2 } = getDrawStrokeInfo(id, style, size);
  const strokePoints = ce(points, options2);
  return Utils.getSvgPathFromStroke(strokePoints.map((pt) => pt.point.slice(0, 2)), false);
}
var DrawRectangle = React410.memo(function DrawRectangle2({
  id,
  style,
  size,
  isSelected,
  isDarkMode
}) {
  const { isFilled } = style;
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const pathTDSnapshot = getRectanglePath(id, style, size);
  const innerPath = getRectangleIndicatorPathTDSnapshot(id, style, size);
  return /* @__PURE__ */ React410.createElement(React410.Fragment, null, /* @__PURE__ */ React410.createElement("path", {
    className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    d: innerPath
  }), isFilled && /* @__PURE__ */ React410.createElement("path", {
    d: innerPath,
    fill,
    pointerEvents: "none"
  }), /* @__PURE__ */ React410.createElement("path", {
    d: pathTDSnapshot,
    fill: stroke,
    stroke,
    strokeWidth,
    pointerEvents: "none"
  }));
});
var DashedRectangle = React54.memo(function DashedRectangle2({
  id,
  style,
  size,
  isSelected,
  isDarkMode
}) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const sw = 1 + strokeWidth * 1.618;
  const w6 = Math.max(0, size[0] - sw / 2);
  const h4 = Math.max(0, size[1] - sw / 2);
  const strokes2 = [
    [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
    [[w6, sw / 2], [w6, h4], h4 - sw / 2],
    [[w6, h4], [sw / 2, h4], w6 - sw / 2],
    [[sw / 2, h4], [sw / 2, sw / 2], h4 - sw / 2]
  ];
  const paths = strokes2.map(([start, end, length3], i8) => {
    const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(length3, strokeWidth * 1.618, style.dash);
    return /* @__PURE__ */ React54.createElement("line", {
      key: id + "_" + i8,
      x1: start[0],
      y1: start[1],
      x2: end[0],
      y2: end[1],
      strokeDasharray,
      strokeDashoffset
    });
  });
  return /* @__PURE__ */ React54.createElement(React54.Fragment, null, /* @__PURE__ */ React54.createElement("rect", {
    className: isSelected || style.isFilled ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    x: sw / 2,
    y: sw / 2,
    width: w6,
    height: h4,
    strokeWidth: BINDING_DISTANCE
  }), style.isFilled && /* @__PURE__ */ React54.createElement("rect", {
    x: sw / 2,
    y: sw / 2,
    width: w6,
    height: h4,
    fill,
    pointerEvents: "none"
  }), /* @__PURE__ */ React54.createElement("g", {
    pointerEvents: "none",
    stroke,
    strokeWidth: sw,
    strokeLinecap: "round"
  }, paths));
});
function BindingIndicator({ strokeWidth, size }) {
  return /* @__PURE__ */ React62.createElement("rect", {
    className: "tl-binding-indicator",
    x: strokeWidth,
    y: strokeWidth,
    width: Math.max(0, size[0] - strokeWidth / 2),
    height: Math.max(0, size[1] - strokeWidth / 2),
    strokeWidth: BINDING_DISTANCE * 2
  });
}
var RectangleUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "rectangle");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "rectangle",
        name: "Rectangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({
      shape,
      isEditing,
      isBinding,
      isSelected,
      isGhost,
      meta,
      bounds,
      events,
      onShapeBlur,
      onShapeChange
    }, ref) => {
      const { id, size, style, label = "", labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(style);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const Component = style.dash === "draw" ? DrawRectangle : DashedRectangle;
      const handleLabelChange = React72.useCallback((label2) => onShapeChange == null ? void 0 : onShapeChange({ id, label: label2 }), [onShapeChange]);
      return /* @__PURE__ */ React72.createElement(FullWrapper, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React72.createElement(TextLabel, {
        isEditing,
        onChange: handleLabelChange,
        onBlur: onShapeBlur,
        font,
        text: label,
        color: styles22.stroke,
        offsetX: (labelPoint[0] - 0.5) * bounds.width,
        offsetY: (labelPoint[1] - 0.5) * bounds.height
      }), /* @__PURE__ */ React72.createElement(SVGContainer, {
        id: shape.id + "_svg",
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, isBinding && /* @__PURE__ */ React72.createElement(BindingIndicator, {
        strokeWidth: styles22.strokeWidth,
        size
      }), /* @__PURE__ */ React72.createElement(Component, {
        id,
        style,
        size,
        isSelected,
        isDarkMode: meta.isDarkMode
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { id, style, size } = shape;
      const styles22 = getShapeStyle(style, false);
      const sw = styles22.strokeWidth;
      if (style.dash === "draw") {
        return /* @__PURE__ */ React72.createElement("path", {
          d: getRectangleIndicatorPathTDSnapshot(id, style, size)
        });
      }
      return /* @__PURE__ */ React72.createElement("rect", {
        x: sw,
        y: sw,
        rx: 1,
        ry: 1,
        width: Math.max(1, size[0] - sw * 2),
        height: Math.max(1, size[1] - sw * 2)
      });
    }));
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;
    });
    __publicField3(this, "transform", transformRectangle);
    __publicField3(this, "transformSingle", transformSingleRectangle);
  }
};
var FullWrapper = styled("div", { width: "100%", height: "100%" });
var PI22 = Math.PI * 2;
var _PolygonUtils = class {
  static inwardEdgeNormal(edge) {
    const delta = src_default.sub(edge[1], edge[0]);
    const len = src_default.len2(delta);
    return [-delta[0] / len, delta[1] / len];
  }
  static outwardEdgeNormal(edge) {
    return src_default.neg(_PolygonUtils.inwardEdgeNormal(edge));
  }
  static isReflexVertex(polygon, index2) {
    const len = polygon.length;
    const v0 = polygon[(index2 + len - 1) % len];
    const v1 = polygon[index2];
    const v22 = polygon[(index2 + 1) % len];
    if (_PolygonUtils.leftSide(v0, v22, v1) < 0)
      return true;
    return false;
  }
  static getEdges(vertices) {
    return vertices.map((vert, i8) => [vert, vertices[(i8 + 1) % vertices.length]]);
  }
  static edgesIntersection([A1, A22], [B1, B22]) {
    const den = (B22[1] - B1[1]) * (A22[0] - A1[0]) - (B22[0] - B1[0]) * (A22[1] - A1[1]);
    if (den == 0)
      return null;
    const ua = ((B22[0] - B1[0]) * (A1[1] - B1[1]) - (B22[1] - B1[1]) * (A1[0] - B1[0])) / den;
    const ub = ((A22[0] - A1[0]) * (A1[1] - B1[1]) - (A22[1] - A1[1]) * (A1[0] - B1[0])) / den;
    if (ua < 0 || ub < 0 || ua > 1 || ub > 1)
      return null;
    return [A1[0] + ua * (A22[0] - A1[0]), A1[1] + ua * (A22[1] - A1[1])];
  }
  static appendArc(polygon, center, radius, startVertex, endVertex, isPaddingBoundary = false) {
    const vertices = [...polygon];
    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]);
    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);
    if (startAngle < 0)
      startAngle += PI22;
    if (endAngle < 0)
      endAngle += PI22;
    const arcSegmentCount = 5;
    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI22 - endAngle;
    const angle5 = (isPaddingBoundary ? -angle : PI22 - angle) / arcSegmentCount;
    vertices.push(startVertex);
    for (let i8 = 1; i8 < arcSegmentCount; ++i8) {
      const angle2 = startAngle + angle5 * i8;
      vertices.push([center[0] + Math.cos(angle2) * radius, center[1] + Math.sin(angle2) * radius]);
    }
    vertices.push(endVertex);
    return vertices;
  }
  static createOffsetEdge(edge, offset) {
    return edge.map((vert) => src_default.add(vert, offset));
  }
  static getOffsetPolygon(polygon, offset = 0) {
    const edges = _PolygonUtils.getEdges(polygon);
    const offsetEdges = edges.map((edge) => _PolygonUtils.createOffsetEdge(edge, src_default.mul(_PolygonUtils.outwardEdgeNormal(edge), offset)));
    const vertices = [];
    for (let i8 = 0; i8 < offsetEdges.length; i8++) {
      const thisEdge = offsetEdges[i8];
      const prevEdge = offsetEdges[(i8 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, edges[i8][0], offset, prevEdge[1], thisEdge[0], false);
      }
    }
    return vertices;
  }
  static createPaddingPolygon(polygon, shapePadding = 0) {
    const offsetEdges = polygon.map((edge) => _PolygonUtils.createOffsetEdge(edge, _PolygonUtils.inwardEdgeNormal(edge)));
    const vertices = [];
    for (let i8 = 0; i8 < offsetEdges.length; i8++) {
      const thisEdge = offsetEdges[i8];
      const prevEdge = offsetEdges[(i8 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, polygon[i8][0], shapePadding, prevEdge[1], thisEdge[0], true);
      }
    }
    return vertices;
  }
};
var PolygonUtils = _PolygonUtils;
__publicField3(PolygonUtils, "leftSide", src_default.isLeft);
function getOffsetPolygon(points, offset) {
  if (points.length < 3)
    throw Error("Polygon must have at least 3 points");
  const len = points.length;
  return points.map((point, i8) => [point, points[(i8 + 1) % len]]).map(([A3, B4]) => {
    const offsetVector = src_default.mul(src_default.per(src_default.uni(src_default.sub(B4, A3))), offset);
    return [src_default.add(A3, offsetVector), src_default.add(B4, offsetVector)];
  }).map((edge, i8, edges) => {
    const intersection = intersectLineLine(edge, edges[(i8 + 1) % edges.length]);
    if (intersection === void 0)
      throw Error("Expected an intersection");
    return intersection;
  });
}
function getTrianglePoints(size, offset = 0, rotation = 0) {
  const [w6, h4] = size;
  let points = [
    [w6 / 2, 0],
    [w6, h4],
    [0, h4]
  ];
  if (offset)
    points = getOffsetPolygon(points, offset);
  if (rotation)
    points = points.map((pt) => src_default.rotWith(pt, [w6 / 2, h4 / 2], rotation));
  return points;
}
function getTriangleCentroid(size) {
  const [w6, h4] = size;
  const points = [
    [w6 / 2, 0],
    [w6, h4],
    [0, h4]
  ];
  return [
    (points[0][0] + points[1][0] + points[2][0]) / 3,
    (points[0][1] + points[1][1] + points[2][1]) / 3
  ];
}
function getTriangleDrawPoints(id, size, strokeWidth) {
  const [w6, h4] = size;
  const getRandom = Utils.rng(id);
  const offsets = Array.from(Array(3)).map(() => {
    return [getRandom() * strokeWidth * 0.75, getRandom() * strokeWidth * 0.75];
  });
  const corners = [
    src_default.add([w6 / 2, 0], offsets[0]),
    src_default.add([w6, h4], offsets[1]),
    src_default.add([0, h4], offsets[2])
  ];
  const rm = Math.round(Math.abs(getRandom() * 2 * 3));
  const lines = Utils.rotateArray([
    src_default.pointsBetween(corners[0], corners[1], 32),
    src_default.pointsBetween(corners[1], corners[2], 32),
    src_default.pointsBetween(corners[2], corners[0], 32)
  ], rm);
  const points = [...lines.flat(), ...lines[0]];
  return {
    points
  };
}
function getDrawStrokeInfo2(id, size, style) {
  const { strokeWidth } = getShapeStyle(style);
  const { points } = getTriangleDrawPoints(id, size, strokeWidth);
  const options2 = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options: options2 };
}
function getTrianglePath(id, size, style) {
  const { points, options: options2 } = getDrawStrokeInfo2(id, size, style);
  const stroke = Te(points, options2);
  return Utils.getSvgPathFromStroke(stroke);
}
function getTriangleIndicatorPathTDSnapshot(id, size, style) {
  const { points, options: options2 } = getDrawStrokeInfo2(id, size, style);
  const strokePoints = ce(points, options2);
  return Utils.getSvgPathFromStroke(strokePoints.map((pt) => pt.point.slice(0, 2)), false);
}
var DrawTriangle = React82.memo(function DrawTriangle2({
  id,
  size,
  style,
  isSelected,
  isDarkMode
}) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const pathTDSnapshot = getTrianglePath(id, size, style);
  const indicatorPath = getTriangleIndicatorPathTDSnapshot(id, size, style);
  return /* @__PURE__ */ React82.createElement(React82.Fragment, null, /* @__PURE__ */ React82.createElement("path", {
    className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    d: indicatorPath
  }), style.isFilled && /* @__PURE__ */ React82.createElement("path", {
    d: indicatorPath,
    fill,
    pointerEvents: "none"
  }), /* @__PURE__ */ React82.createElement("path", {
    d: pathTDSnapshot,
    fill: stroke,
    stroke,
    strokeWidth,
    pointerEvents: "none"
  }));
});
var DashedTriangle = React92.memo(function DashedTriangle2({
  id,
  size,
  style,
  isSelected,
  isDarkMode
}) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const sw = 1 + strokeWidth * 1.618;
  const points = getTrianglePoints(size);
  const sides = Utils.pointsToLineSegments(points, true);
  const paths = sides.map(([start, end], i8) => {
    const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(src_default.dist(start, end), strokeWidth * 1.618, style.dash);
    return /* @__PURE__ */ React92.createElement("line", {
      key: id + "_" + i8,
      x1: start[0],
      y1: start[1],
      x2: end[0],
      y2: end[1],
      stroke,
      strokeWidth: sw,
      strokeLinecap: "round",
      strokeDasharray,
      strokeDashoffset
    });
  });
  const bgPath = points.join();
  return /* @__PURE__ */ React92.createElement(React92.Fragment, null, /* @__PURE__ */ React92.createElement("polygon", {
    className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    points: bgPath
  }), style.isFilled && /* @__PURE__ */ React92.createElement("polygon", {
    fill,
    points: bgPath,
    pointerEvents: "none"
  }), /* @__PURE__ */ React92.createElement("g", {
    pointerEvents: "stroke"
  }, paths));
});
function TriangleBindingIndicator({ size }) {
  const trianglePoints = getTrianglePoints(size).join();
  return /* @__PURE__ */ React102.createElement("polygon", {
    className: "tl-binding-indicator",
    points: trianglePoints,
    strokeWidth: BINDING_DISTANCE * 2
  });
}
var TriangleUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "triangle");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "triangle",
        name: "Triangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({
      shape,
      bounds,
      isBinding,
      isEditing,
      isSelected,
      isGhost,
      meta,
      events,
      onShapeChange,
      onShapeBlur
    }, ref) => {
      const { id, label = "", size, style, labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(style);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const Component = style.dash === "draw" ? DrawTriangle : DashedTriangle;
      const handleLabelChange = React112.useCallback((label2) => onShapeChange == null ? void 0 : onShapeChange({ id, label: label2 }), [onShapeChange]);
      const offsetY = React112.useMemo(() => {
        const center = src_default.div(size, 2);
        const centroid = getTriangleCentroid(size);
        return (centroid[1] - center[1]) * 0.72;
      }, [size]);
      return /* @__PURE__ */ React112.createElement(FullWrapper2, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React112.createElement(TextLabel, {
        font,
        text: label,
        color: styles22.stroke,
        offsetX: (labelPoint[0] - 0.5) * bounds.width,
        offsetY: offsetY + (labelPoint[1] - 0.5) * bounds.height,
        isEditing,
        onChange: handleLabelChange,
        onBlur: onShapeBlur
      }), /* @__PURE__ */ React112.createElement(SVGContainer, {
        id: shape.id + "_svg",
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, isBinding && /* @__PURE__ */ React112.createElement(TriangleBindingIndicator, {
        size
      }), /* @__PURE__ */ React112.createElement(Component, {
        id,
        style,
        size,
        isSelected,
        isDarkMode: meta.isDarkMode
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { size } = shape;
      return /* @__PURE__ */ React112.createElement("polygon", {
        points: getTrianglePoints(size).join()
      });
    }));
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style || next.label !== prev.label;
    });
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "getExpandedBounds", (shape) => {
      return Utils.getBoundsFromPoints(getTrianglePoints(shape.size, this.bindingDistance).map((pt) => src_default.add(pt, shape.point)));
    });
    __publicField3(this, "hitTestLineSegment", (shape, A3, B4) => {
      return intersectLineSegmentPolyline(A3, B4, this.getPoints(shape)).didIntersect;
    });
    __publicField3(this, "hitTestBounds", (shape, bounds) => {
      return Utils.boundsContained(this.getBounds(shape), bounds) || intersectBoundsPolygon(bounds, this.getPoints(shape)).length > 0;
    });
    __publicField3(this, "getBindingPoint", (shape, fromShape, point, origin, direction, bindAnywhere) => {
      const expandedBounds = this.getExpandedBounds(shape);
      if (!Utils.pointInBounds(point, expandedBounds))
        return;
      const points = getTrianglePoints(shape.size).map((pt) => src_default.add(pt, shape.point));
      const expandedPoints = getTrianglePoints(shape.size, this.bindingDistance).map((pt) => src_default.add(pt, shape.point));
      const closestDistanceToEdge = Utils.pointsToLineSegments(points, true).map(([a7, b7]) => src_default.distanceToLineSegment(a7, b7, point)).sort((a7, b7) => a7 - b7)[0];
      if (!(Utils.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance))
        return;
      const intersections = Utils.pointsToLineSegments(expandedPoints.concat([expandedPoints[0]])).map((segment) => intersectRayLineSegment(origin, direction, segment[0], segment[1])).filter((intersection2) => intersection2.didIntersect).flatMap((intersection2) => intersection2.points);
      if (!intersections.length)
        return;
      const center = src_default.add(getTriangleCentroid(shape.size), shape.point);
      const intersection = intersections.sort((a7, b7) => src_default.dist(b7, origin) - src_default.dist(a7, origin))[0];
      const middlePoint = src_default.med(point, intersection);
      let anchor;
      let distance;
      if (bindAnywhere) {
        anchor = src_default.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
        distance = 0;
      } else {
        if (src_default.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
          anchor = center;
        } else {
          anchor = middlePoint;
        }
        if (Utils.pointInPolygon(point, points)) {
          distance = this.bindingDistance;
        } else {
          distance = Math.max(this.bindingDistance, closestDistanceToEdge);
        }
      }
      const bindingPoint = src_default.divV(src_default.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
        expandedBounds.width,
        expandedBounds.height
      ]);
      return {
        point: src_default.clampV(bindingPoint, 0, 1),
        distance
      };
    });
    __publicField3(this, "transform", transformRectangle);
    __publicField3(this, "transformSingle", transformSingleRectangle);
  }
  getPoints(shape) {
    const {
      rotation = 0,
      point: [x6, y5],
      size: [w6, h4]
    } = shape;
    return [
      [x6 + w6 / 2, y5],
      [x6, y5 + h4],
      [x6 + w6, y5 + h4]
    ].map((pt) => src_default.rotWith(pt, this.getCenter(shape), rotation));
  }
};
var FullWrapper2 = styled("div", { width: "100%", height: "100%" });
function getEllipseStrokePoints(id, radius, style) {
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = Utils.rng(id);
  const rx = radius[0] + getRandom() * strokeWidth * 2;
  const ry = radius[1] + getRandom() * strokeWidth * 2;
  const perimeter = Utils.perimeterOfEllipse(rx, ry);
  const points = [];
  const start = Math.PI + Math.PI * getRandom();
  const extra = Math.abs(getRandom());
  const count = Math.max(16, perimeter / 10);
  for (let i8 = 0; i8 < count; i8++) {
    const t12 = EASINGS.easeInOutSine(i8 / (count + 1));
    const rads = start * 2 + Math.PI * (2 + extra) * t12;
    const c8 = Math.cos(rads);
    const s9 = Math.sin(rads);
    points.push([rx * c8 + radius[0], ry * s9 + radius[1], t12 + 0.5 + getRandom() / 2]);
  }
  return ce(points, {
    size: 1 + strokeWidth * 2,
    thinning: 0.618,
    end: { taper: perimeter / 8 },
    start: { taper: perimeter / 12 },
    streamline: 0,
    simulatePressure: true
  });
}
function getEllipsePath(id, radius, style) {
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = Utils.rng(id);
  const rx = radius[0] + getRandom() * strokeWidth * 2;
  const ry = radius[1] + getRandom() * strokeWidth * 2;
  const perimeter = Utils.perimeterOfEllipse(rx, ry);
  return Utils.getSvgPathFromStroke(ie(getEllipseStrokePoints(id, radius, style), {
    size: 2 + strokeWidth * 2,
    thinning: 0.618,
    end: { taper: perimeter / 8 },
    start: { taper: perimeter / 12 },
    streamline: 0,
    simulatePressure: true
  }));
}
function getEllipseIndicatorPath(id, radius, style) {
  return Utils.getSvgPathFromStroke(getEllipseStrokePoints(id, radius, style).map((pt) => pt.point.slice(0, 2)), false);
}
var DrawEllipse = React122.memo(function DrawEllipse2({
  id,
  radius,
  style,
  isSelected,
  isDarkMode
}) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const innerPath = getEllipsePath(id, radius, style);
  return /* @__PURE__ */ React122.createElement(React122.Fragment, null, /* @__PURE__ */ React122.createElement("ellipse", {
    className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    cx: radius[0],
    cy: radius[1],
    rx: radius[0],
    ry: radius[1]
  }), style.isFilled && /* @__PURE__ */ React122.createElement("path", {
    d: getEllipseIndicatorPath(id, radius, style),
    stroke: "none",
    fill,
    pointerEvents: "none"
  }), /* @__PURE__ */ React122.createElement("path", {
    d: innerPath,
    fill: stroke,
    stroke,
    strokeWidth,
    pointerEvents: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
});
var DashedEllipse = React132.memo(function DashedEllipse2({
  radius,
  style,
  isSelected,
  isDarkMode
}) {
  const { stroke, strokeWidth, fill } = getShapeStyle(style, isDarkMode);
  const sw = 1 + strokeWidth * 1.618;
  const rx = Math.max(0, radius[0] - sw / 2);
  const ry = Math.max(0, radius[1] - sw / 2);
  const perimeter = Utils.perimeterOfEllipse(rx, ry);
  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(perimeter < 64 ? perimeter * 2 : perimeter, strokeWidth * 1.618, style.dash, 4);
  return /* @__PURE__ */ React132.createElement(React132.Fragment, null, /* @__PURE__ */ React132.createElement("ellipse", {
    className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
    cx: radius[0],
    cy: radius[1],
    rx: radius[0],
    ry: radius[1]
  }), /* @__PURE__ */ React132.createElement("ellipse", {
    cx: radius[0],
    cy: radius[1],
    rx,
    ry,
    fill,
    stroke,
    strokeWidth: sw,
    strokeDasharray,
    strokeDashoffset,
    pointerEvents: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
});
var EllipseUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "ellipse");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "ellipse",
        name: "Ellipse",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        radius: [1, 1],
        rotation: 0,
        style: defaultStyle,
        label: "",
        labelPoint: [0.5, 0.5]
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({
      shape,
      isGhost,
      isSelected,
      isBinding,
      isEditing,
      meta,
      bounds,
      events,
      onShapeChange,
      onShapeBlur
    }, ref) => {
      const { id, radius, style, label = "", labelPoint = LABEL_POINT } = shape;
      const font = getFontStyle(shape.style);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const strokeWidth = styles22.strokeWidth;
      const sw = 1 + strokeWidth * 1.618;
      const rx = Math.max(0, radius[0] - sw / 2);
      const ry = Math.max(0, radius[1] - sw / 2);
      const Component = style.dash === "draw" ? DrawEllipse : DashedEllipse;
      const handleLabelChange = React142.useCallback((label2) => onShapeChange == null ? void 0 : onShapeChange({ id, label: label2 }), [onShapeChange]);
      return /* @__PURE__ */ React142.createElement(FullWrapper3, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React142.createElement(TextLabel, {
        isEditing,
        onChange: handleLabelChange,
        onBlur: onShapeBlur,
        font,
        text: label,
        color: styles22.stroke,
        offsetX: (labelPoint[0] - 0.5) * bounds.width,
        offsetY: (labelPoint[1] - 0.5) * bounds.height
      }), /* @__PURE__ */ React142.createElement(SVGContainer, {
        id: shape.id + "_svg",
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, isBinding && /* @__PURE__ */ React142.createElement("ellipse", {
        className: "tl-binding-indicator",
        cx: radius[0],
        cy: radius[1],
        rx,
        ry,
        strokeWidth: this.bindingDistance
      }), /* @__PURE__ */ React142.createElement(Component, {
        id,
        radius,
        style,
        isSelected,
        isDarkMode: meta.isDarkMode
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { id, radius, style } = shape;
      const styles22 = getShapeStyle(style);
      const strokeWidth = styles22.strokeWidth;
      const sw = 1 + strokeWidth * 1.618;
      const rx = Math.max(0, radius[0] - sw / 2);
      const ry = Math.max(0, radius[1] - sw / 2);
      return style.dash === "draw" ? /* @__PURE__ */ React142.createElement("path", {
        d: getEllipseIndicatorPath(id, radius, style)
      }) : /* @__PURE__ */ React142.createElement("ellipse", {
        cx: radius[0],
        cy: radius[1],
        rx,
        ry
      });
    }));
    __publicField3(this, "hitTestPoint", (shape, point) => {
      return Utils.pointInBounds(point, this.getRotatedBounds(shape)) && Utils.pointInEllipse(point, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0);
    });
    __publicField3(this, "hitTestLineSegment", (shape, A3, B4) => {
      return intersectLineSegmentEllipse(A3, B4, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0).didIntersect;
    });
    __publicField3(this, "getBounds", (shape) => {
      return Utils.getFromCache(this.boundsCache, shape, () => {
        return Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], 0);
      });
    });
    __publicField3(this, "getRotatedBounds", (shape) => {
      return Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation);
    });
    __publicField3(this, "hitTestBounds", (shape, bounds) => {
      const shapeBounds = this.getBounds(shape);
      return Utils.boundsContained(shapeBounds, bounds) || intersectEllipseBounds(this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0, bounds).length > 0;
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.radius !== prev.radius || next.style !== prev.style || next.label !== prev.label;
    });
    __publicField3(this, "getCenter", (shape) => {
      return Vec.add(shape.point, shape.radius);
    });
    __publicField3(this, "getBindingPoint", (shape, fromShape, point, origin, direction, bindAnywhere) => {
      {
        const expandedBounds = this.getExpandedBounds(shape);
        const center = this.getCenter(shape);
        let bindingPoint;
        let distance;
        if (!Utils.pointInEllipse(point, center, shape.radius[0] + this.bindingDistance, shape.radius[1] + this.bindingDistance)) {
          return;
        }
        if (bindAnywhere) {
          if (Vec.dist(point, this.getCenter(shape)) < 12) {
            bindingPoint = [0.5, 0.5];
          } else {
            bindingPoint = Vec.divV(Vec.sub(point, [expandedBounds.minX, expandedBounds.minY]), [
              expandedBounds.width,
              expandedBounds.height
            ]);
          }
          distance = 0;
        } else {
          let intersection = intersectRayEllipse(origin, direction, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort((a7, b7) => Vec.dist(a7, origin) - Vec.dist(b7, origin))[0];
          if (!intersection) {
            intersection = intersectLineSegmentEllipse(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort((a7, b7) => Vec.dist(a7, point) - Vec.dist(b7, point))[0];
          }
          if (!intersection) {
            return void 0;
          }
          const anchor = Vec.med(point, intersection);
          if (Vec.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {
            bindingPoint = [0.5, 0.5];
          } else {
            bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
              expandedBounds.width,
              expandedBounds.height
            ]);
          }
          if (Utils.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)) {
            distance = this.bindingDistance / 2;
          } else {
            const innerIntersection = intersectLineSegmentEllipse(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points[0];
            if (!innerIntersection)
              return void 0;
            distance = Math.max(this.bindingDistance / 2, Vec.dist(point, innerIntersection));
          }
        }
        return {
          point: bindingPoint,
          distance
        };
      }
    });
    __publicField3(this, "transform", (shape, bounds, { scaleX, scaleY, initialShape }) => {
      const { rotation = 0 } = initialShape;
      return {
        point: [bounds.minX, bounds.minY],
        radius: [bounds.width / 2, bounds.height / 2],
        rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0
      };
    });
    __publicField3(this, "transformSingle", (shape, bounds) => {
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        radius: Vec.div([bounds.width, bounds.height], 2)
      };
    });
  }
};
var FullWrapper3 = styled("div", { width: "100%", height: "100%" });
function getArrowArcPath(start, end, circle, bend) {
  return [
    "M",
    start[0],
    start[1],
    "A",
    circle[2],
    circle[2],
    0,
    0,
    bend < 0 ? 0 : 1,
    end[0],
    end[1]
  ].join(" ");
}
function getBendPoint(handles, bend) {
  const { start, end } = handles;
  const dist = src_default.dist(start.point, end.point);
  const midPoint = src_default.med(start.point, end.point);
  const bendDist = dist / 2 * bend;
  const u4 = src_default.uni(src_default.vec(start.point, end.point));
  const point = src_default.toFixed(Math.abs(bendDist) < 10 ? midPoint : src_default.add(midPoint, src_default.mul(src_default.per(u4), bendDist)));
  return point;
}
function renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) {
  const getRandom = Utils.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const startPoint = decorationStart ? src_default.nudge(start, end, strokeWidth) : start;
  const endPoint = decorationEnd ? src_default.nudge(end, start, strokeWidth) : end;
  const stroke = Te([startPoint, endPoint], {
    size: strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: true,
    streamline: 0,
    last: true
  });
  return Utils.getSvgPathFromStroke(stroke);
}
function renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length3, easing) {
  const getRandom = Utils.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const startPoint = decorationStart ? src_default.rotWith(start, center, strokeWidth / length3) : start;
  const endPoint = decorationEnd ? src_default.rotWith(end, center, -(strokeWidth / length3)) : end;
  const startAngle = src_default.angle(center, startPoint);
  const endAngle = src_default.angle(center, endPoint);
  const points = [];
  const count = 8 + Math.floor(Math.abs(length3) / 20 * 1 + getRandom() / 2);
  for (let i8 = 0; i8 < count; i8++) {
    const t12 = easing(i8 / count);
    const angle = Utils.lerpAngles(startAngle, endAngle, t12);
    points.push(src_default.toFixed(src_default.nudgeAtAngle(center, angle, radius)));
  }
  const stroke = Te([startPoint, ...points, endPoint], {
    size: 1 + strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: false,
    streamline: 0,
    last: true
  });
  return Utils.getSvgPathFromStroke(stroke);
}
function getCtp(start, bend, end) {
  return Utils.circleFromThreePoints(start, end, bend);
}
function getCurvedArrowHeadPoints(A3, r1, C6, r22, sweep) {
  const ints = intersectCircleCircle(A3, r1 * 0.618, C6, r22).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A3, right: A3 };
  }
  const int = sweep ? ints[0] : ints[1];
  const left = int ? src_default.nudge(src_default.rotWith(int, A3, Math.PI / 6), A3, r1 * -0.382) : A3;
  const right = int ? src_default.nudge(src_default.rotWith(int, A3, -Math.PI / 6), A3, r1 * -0.382) : A3;
  return { left, right };
}
function getStraightArrowHeadPoints(A3, B4, r12) {
  const ints = intersectCircleLineSegment(A3, r12, A3, B4).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A3, right: A3 };
  }
  const int = ints[0];
  const left = int ? src_default.rotWith(int, A3, Math.PI / 6) : A3;
  const right = int ? src_default.rotWith(int, A3, -Math.PI / 6) : A3;
  return { left, right };
}
function getCurvedArrowHeadPath(A3, r1, C6, r22, sweep) {
  const { left, right } = getCurvedArrowHeadPoints(A3, r1, C6, r22, sweep);
  return `M ${left} L ${A3} ${right}`;
}
function getStraightArrowHeadPath(A3, B4, r12) {
  const { left, right } = getStraightArrowHeadPoints(A3, B4, r12);
  return `M ${left} L ${A3} ${right}`;
}
function getArrowPath(style, start, bend, end, decorationStart, decorationEnd) {
  const { strokeWidth } = getShapeStyle(style, false);
  const arrowDist = src_default.dist(start, end);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const path = [];
  const isStraightLine = src_default.dist(bend, src_default.toFixed(src_default.med(start, end))) < 1;
  if (isStraightLine) {
    path.push(`M ${start} L ${end}`);
    if (decorationStart) {
      path.push(getStraightArrowHeadPath(start, end, arrowHeadLength));
    }
    if (decorationEnd) {
      path.push(getStraightArrowHeadPath(end, start, arrowHeadLength));
    }
  } else {
    const circle = getCtp(start, bend, end);
    const center = [circle[0], circle[1]];
    const radius = circle[2];
    const length3 = getArcLength(center, radius, start, end);
    path.push(`M ${start} A ${radius} ${radius} 0 0 ${length3 > 0 ? "1" : "0"} ${end}`);
    if (decorationStart)
      path.push(getCurvedArrowHeadPath(start, arrowHeadLength, center, radius, length3 < 0));
    if (decorationEnd) {
      path.push(getCurvedArrowHeadPath(end, arrowHeadLength, center, radius, length3 >= 0));
    }
  }
  return path.join(" ");
}
function getArcPoints(start, bend, end) {
  if (src_default.dist2(bend, src_default.med(start, end)) <= 4)
    return [start, end];
  const points = [];
  const circle = getCtp(start, bend, end);
  const center = [circle[0], circle[1]];
  const radius = circle[2];
  const startAngle = src_default.angle(center, start);
  const endAngle = src_default.angle(center, end);
  for (let i8 = 1 / 20; i8 < 1; i8 += 1 / 20) {
    const angle = Utils.lerpAngles(startAngle, endAngle, i8);
    points.push(src_default.nudgeAtAngle(center, angle, radius));
  }
  return points;
}
function isAngleBetween2(a7, b7, c8) {
  if (c8 === a7 || c8 === b7)
    return true;
  const PI24 = Math.PI * 2;
  const AB = (b7 - a7 + PI24) % PI24;
  const AC = (c8 - a7 + PI24) % PI24;
  return AB <= Math.PI !== AC > AB;
}
function getArcLength(C6, r12, A3, B4) {
  const sweep = Utils.getSweep(C6, A3, B4);
  return r12 * (2 * Math.PI) * (sweep / (2 * Math.PI));
}
function Arrowhead({ left, middle, right, stroke, strokeWidth }) {
  return /* @__PURE__ */ React152.createElement("g", null, /* @__PURE__ */ React152.createElement("path", {
    className: "tl-stroke-hitarea",
    d: `M ${left} L ${middle} ${right}`
  }), /* @__PURE__ */ React152.createElement("path", {
    d: `M ${left} L ${middle} ${right}`,
    fill: "none",
    stroke,
    strokeWidth,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    pointerEvents: "none"
  }));
}
var StraightArrow = React162.memo(function StraightArrow2({
  id,
  style,
  start,
  end,
  decorationStart,
  decorationEnd,
  isDraw,
  isDarkMode
}) {
  const arrowDist = src_default.dist(start, end);
  if (arrowDist < 2)
    return null;
  const styles22 = getShapeStyle(style, isDarkMode);
  const { strokeWidth } = styles22;
  const sw = 1 + strokeWidth * 1.618;
  const path = isDraw ? renderFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd) : "M" + src_default.toFixed(start) + "L" + src_default.toFixed(end);
  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(arrowDist, strokeWidth * 1.618, style.dash, 2, false);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const startArrowHead = decorationStart ? getStraightArrowHeadPoints(start, end, arrowHeadLength) : null;
  const endArrowHead = decorationEnd ? getStraightArrowHeadPoints(end, start, arrowHeadLength) : null;
  return /* @__PURE__ */ React162.createElement(React162.Fragment, null, /* @__PURE__ */ React162.createElement("path", {
    className: "tl-stroke-hitarea",
    d: path
  }), /* @__PURE__ */ React162.createElement("path", {
    d: path,
    fill: styles22.stroke,
    stroke: styles22.stroke,
    strokeWidth: isDraw ? sw / 2 : sw,
    strokeDasharray,
    strokeDashoffset,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    pointerEvents: "stroke"
  }), startArrowHead && /* @__PURE__ */ React162.createElement(Arrowhead, {
    left: startArrowHead.left,
    middle: start,
    right: startArrowHead.right,
    stroke: styles22.stroke,
    strokeWidth: sw
  }), endArrowHead && /* @__PURE__ */ React162.createElement(Arrowhead, {
    left: endArrowHead.left,
    middle: end,
    right: endArrowHead.right,
    stroke: styles22.stroke,
    strokeWidth: sw
  }));
});
var CurvedArrow = React172.memo(function CurvedArrow2({
  id,
  style,
  start,
  bend,
  end,
  arrowBend,
  decorationStart,
  decorationEnd,
  isDraw,
  isDarkMode
}) {
  const arrowDist = src_default.dist(start, end);
  if (arrowDist < 2)
    return null;
  const styles22 = getShapeStyle(style, isDarkMode);
  const { strokeWidth } = styles22;
  const sw = 1 + strokeWidth * 1.618;
  const circle = getCtp(start, bend, end);
  const center = [circle[0], circle[1]];
  const radius = circle[2];
  const length3 = getArcLength(center, radius, start, end);
  const getRandom = Utils.rng(id);
  const easing = EASINGS[getRandom() > 0 ? "easeInOutSine" : "easeInOutCubic"];
  const path = isDraw ? renderCurvedFreehandArrowShaft(id, style, start, end, decorationStart, decorationEnd, center, radius, length3, easing) : getArrowArcPath(start, end, circle, arrowBend);
  const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(Math.abs(length3), sw, style.dash, 2, false);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const startArrowHead = decorationStart ? getCurvedArrowHeadPoints(start, arrowHeadLength, center, radius, length3 < 0) : null;
  const endArrowHead = decorationEnd ? getCurvedArrowHeadPoints(end, arrowHeadLength, center, radius, length3 >= 0) : null;
  return /* @__PURE__ */ React172.createElement(React172.Fragment, null, /* @__PURE__ */ React172.createElement("path", {
    className: "tl-stroke-hitarea",
    d: path
  }), /* @__PURE__ */ React172.createElement("path", {
    d: path,
    fill: isDraw ? styles22.stroke : "none",
    stroke: styles22.stroke,
    strokeWidth: isDraw ? 0 : sw,
    strokeDasharray,
    strokeDashoffset,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    pointerEvents: "none"
  }), startArrowHead && /* @__PURE__ */ React172.createElement(Arrowhead, {
    left: startArrowHead.left,
    middle: start,
    right: startArrowHead.right,
    stroke: styles22.stroke,
    strokeWidth: sw
  }), endArrowHead && /* @__PURE__ */ React172.createElement(Arrowhead, {
    left: endArrowHead.left,
    middle: end,
    right: endArrowHead.right,
    stroke: styles22.stroke,
    strokeWidth: sw
  }));
});
function LabelMask({ id, bounds, labelSize, offset, scale = 1 }) {
  return /* @__PURE__ */ React182.createElement("defs", null, /* @__PURE__ */ React182.createElement("mask", {
    id: id + "_clip"
  }, /* @__PURE__ */ React182.createElement("rect", {
    x: -100,
    y: -100,
    width: bounds.width + 200,
    height: bounds.height + 200,
    fill: "white"
  }), /* @__PURE__ */ React182.createElement("rect", {
    x: bounds.width / 2 - labelSize[0] / 2 * scale + ((offset == null ? void 0 : offset[0]) || 0),
    y: bounds.height / 2 - labelSize[1] / 2 * scale + ((offset == null ? void 0 : offset[1]) || 0),
    width: labelSize[0] * scale,
    height: labelSize[1] * scale,
    rx: 4 * scale,
    ry: 4 * scale,
    fill: "black",
    opacity: Math.max(scale, 0.8)
  })));
}
var ArrowUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "arrow");
    __publicField3(this, "hideBounds", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "pathCache", /* @__PURE__ */ new WeakMap());
    __publicField3(this, "getShape", (props) => {
      var _a2, _b, _c, _d;
      return __spreadValues4({
        id: "id",
        type: "arrow",
        name: "Arrow",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        bend: 0,
        handles: {
          start: __spreadValues4({
            id: "start",
            index: 0,
            point: [0, 0],
            canBind: true
          }, (_a2 = props.handles) == null ? void 0 : _a2.start),
          end: __spreadValues4({
            id: "end",
            index: 1,
            point: [1, 1],
            canBind: true
          }, (_b = props.handles) == null ? void 0 : _b.end),
          bend: __spreadValues4({
            id: "bend",
            index: 2,
            point: [0.5, 0.5]
          }, (_c = props.handles) == null ? void 0 : _c.bend)
        },
        decorations: (_d = props.decorations) != null ? _d : {
          end: "arrow"
        },
        style: __spreadValues4(__spreadProps4(__spreadValues4({}, defaultStyle), {
          isFilled: false
        }), props.style),
        label: "",
        labelPoint: [0.5, 0.5]
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, isEditing, isGhost, meta, events, onShapeChange, onShapeBlur }, ref) => {
      const {
        id,
        label = "",
        handles: { start, bend, end },
        decorations = {},
        style
      } = shape;
      const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1;
      const font = getFontStyle(style);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const labelSize = label || isEditing ? getTextLabelSize(label, font) : [0, 0];
      const bounds = this.getBounds(shape);
      const dist = React192.useMemo(() => {
        const { start: start2, bend: bend2, end: end2 } = shape.handles;
        if (isStraightLine)
          return Vec.dist(start2.point, end2.point);
        const circle = getCtp(start2.point, bend2.point, end2.point);
        const center = circle.slice(0, 2);
        const radius = circle[2];
        const length3 = getArcLength(center, radius, start2.point, end2.point);
        return Math.abs(length3);
      }, [shape.handles]);
      const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));
      const offset = React192.useMemo(() => {
        const bounds2 = this.getBounds(shape);
        const offset2 = Vec.sub(shape.handles.bend.point, Vec.toFixed([bounds2.width / 2, bounds2.height / 2]));
        return offset2;
      }, [shape, scale]);
      const handleLabelChange = React192.useCallback((label2) => {
        onShapeChange == null ? void 0 : onShapeChange({ id, label: label2 });
      }, [onShapeChange]);
      const Component = isStraightLine ? StraightArrow : CurvedArrow;
      return /* @__PURE__ */ React192.createElement(FullWrapper4, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React192.createElement(TextLabel, {
        font,
        text: label,
        color: styles22.stroke,
        offsetX: offset[0],
        offsetY: offset[1],
        scale,
        isEditing,
        onChange: handleLabelChange,
        onBlur: onShapeBlur
      }), /* @__PURE__ */ React192.createElement(SVGContainer, {
        id: shape.id + "_svg"
      }, /* @__PURE__ */ React192.createElement("defs", null, /* @__PURE__ */ React192.createElement("mask", {
        id: shape.id + "_clip"
      }, /* @__PURE__ */ React192.createElement("rect", {
        x: -100,
        y: -100,
        width: bounds.width + 200,
        height: bounds.height + 200,
        fill: "white"
      }), /* @__PURE__ */ React192.createElement("rect", {
        x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],
        y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],
        width: labelSize[0] * scale,
        height: labelSize[1] * scale,
        rx: 4 * scale,
        ry: 4 * scale,
        fill: "black",
        opacity: 1
      }))), /* @__PURE__ */ React192.createElement("g", {
        pointerEvents: "none",
        opacity: isGhost ? GHOSTED_OPACITY : 1,
        mask: label || isEditing ? `url(#${shape.id}_clip)` : ``
      }, /* @__PURE__ */ React192.createElement(Component, {
        id,
        style,
        start: start.point,
        end: end.point,
        bend: bend.point,
        arrowBend: shape.bend,
        decorationStart: decorations == null ? void 0 : decorations.start,
        decorationEnd: decorations == null ? void 0 : decorations.end,
        isDraw: style.dash === "draw",
        isDarkMode: meta.isDarkMode
      }))));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape, bounds }) => {
      const {
        style,
        decorations,
        label,
        handles: { start, bend, end }
      } = shape;
      const font = getFontStyle(style);
      const labelSize = label ? getTextLabelSize(label, font) : [0, 0];
      const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1;
      const dist = React192.useMemo(() => {
        const { start: start2, bend: bend2, end: end2 } = shape.handles;
        if (isStraightLine)
          return Vec.dist(start2.point, end2.point);
        const circle = getCtp(start2.point, bend2.point, end2.point);
        const center = circle.slice(0, 2);
        const radius = circle[2];
        const length3 = getArcLength(center, radius, start2.point, end2.point);
        return Math.abs(length3);
      }, [shape.handles]);
      const scale = Math.max(0.5, Math.min(1, Math.max(dist / (labelSize[1] + 128), dist / (labelSize[0] + 128))));
      const offset = React192.useMemo(() => {
        const bounds2 = this.getBounds(shape);
        const offset2 = Vec.sub(shape.handles.bend.point, [bounds2.width / 2, bounds2.height / 2]);
        return offset2;
      }, [shape, scale]);
      return /* @__PURE__ */ React192.createElement(React192.Fragment, null, /* @__PURE__ */ React192.createElement(LabelMask, {
        id: shape.id,
        scale,
        offset,
        bounds,
        labelSize
      }), /* @__PURE__ */ React192.createElement("path", {
        d: getArrowPath(style, start.point, bend.point, end.point, decorations == null ? void 0 : decorations.start, decorations == null ? void 0 : decorations.end),
        mask: label ? `url(#${shape.id}_clip)` : ``
      }), label && /* @__PURE__ */ React192.createElement("rect", {
        x: bounds.width / 2 - labelSize[0] / 2 * scale + offset[0],
        y: bounds.height / 2 - labelSize[1] / 2 * scale + offset[1],
        width: labelSize[0] * scale,
        height: labelSize[1] * scale,
        rx: 4 * scale,
        ry: 4 * scale,
        fill: "transparent"
      }));
    }));
    __publicField3(this, "getBounds", (shape) => {
      const bounds = Utils.getFromCache(this.boundsCache, shape, () => {
        const {
          handles: { start, bend, end }
        } = shape;
        return Utils.getBoundsFromPoints(getArcPoints(start.point, bend.point, end.point));
      });
      return Utils.translateBounds(bounds, shape.point);
    });
    __publicField3(this, "getRotatedBounds", (shape) => {
      const {
        handles: { start, bend, end }
      } = shape;
      let points = getArcPoints(start.point, bend.point, end.point);
      const { minX, minY, maxX, maxY } = Utils.getBoundsFromPoints(points);
      if (shape.rotation !== 0) {
        points = points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0));
      }
      return Utils.translateBounds(Utils.getBoundsFromPoints(points), shape.point);
    });
    __publicField3(this, "getCenter", (shape) => {
      const { start, end } = shape.handles;
      return Vec.add(shape.point, Vec.med(start.point, end.point));
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.decorations !== prev.decorations || next.handles !== prev.handles || next.style !== prev.style || next.label !== prev.label;
    });
    __publicField3(this, "hitTestPoint", (shape, point) => {
      const {
        handles: { start, bend, end }
      } = shape;
      const pt = Vec.sub(point, shape.point);
      const points = getArcPoints(start.point, bend.point, end.point);
      for (let i8 = 1; i8 < points.length; i8++) {
        if (Vec.distanceToLineSegment(points[i8 - 1], points[i8], pt) < 1) {
          return true;
        }
      }
      return false;
    });
    __publicField3(this, "hitTestLineSegment", (shape, A3, B4) => {
      const {
        handles: { start, bend, end }
      } = shape;
      const ptA = Vec.sub(A3, shape.point);
      const ptB = Vec.sub(B4, shape.point);
      const points = getArcPoints(start.point, bend.point, end.point);
      for (let i8 = 1; i8 < points.length; i8++) {
        if (intersectLineSegmentLineSegment(points[i8 - 1], points[i8], ptA, ptB).didIntersect) {
          return true;
        }
      }
      return false;
    });
    __publicField3(this, "hitTestBounds", (shape, bounds) => {
      const { start, end, bend } = shape.handles;
      const sp = Vec.add(shape.point, start.point);
      const ep = Vec.add(shape.point, end.point);
      if (Utils.pointInBounds(sp, bounds) || Utils.pointInBounds(ep, bounds)) {
        return true;
      }
      if (Vec.isEqual(Vec.med(start.point, end.point), bend.point)) {
        return intersectLineSegmentBounds(sp, ep, bounds).length > 0;
      } else {
        const [cx, cy, r12] = getCtp(start.point, bend.point, end.point);
        const cp = Vec.add(shape.point, [cx, cy]);
        return intersectArcBounds(cp, r12, sp, ep, bounds).length > 0;
      }
    });
    __publicField3(this, "transform", (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const initialShapeBounds = this.getBounds(initialShape);
      const handles = ["start", "end"];
      const nextHandles = __spreadValues4({}, initialShape.handles);
      handles.forEach((handle) => {
        const [x6, y5] = nextHandles[handle].point;
        const nw = x6 / initialShapeBounds.width;
        const nh = y5 / initialShapeBounds.height;
        nextHandles[handle] = __spreadProps4(__spreadValues4({}, nextHandles[handle]), {
          point: [
            bounds.width * (scaleX < 0 ? 1 - nw : nw),
            bounds.height * (scaleY < 0 ? 1 - nh : nh)
          ]
        });
      });
      const { start, bend, end } = nextHandles;
      const dist = Vec.dist(start.point, end.point);
      const midPoint = Vec.med(start.point, end.point);
      const bendDist = dist / 2 * initialShape.bend;
      const u4 = Vec.uni(Vec.vec(start.point, end.point));
      const point = Vec.add(midPoint, Vec.mul(Vec.per(u4), bendDist));
      nextHandles["bend"] = __spreadProps4(__spreadValues4({}, bend), {
        point: Vec.toFixed(Math.abs(bendDist) < 10 ? midPoint : point)
      });
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        handles: nextHandles
      };
    });
    __publicField3(this, "onDoubleClickHandle", (shape, handle) => {
      var _a2, _b;
      switch (handle) {
        case "bend": {
          return {
            bend: 0,
            handles: __spreadProps4(__spreadValues4({}, shape.handles), {
              bend: __spreadProps4(__spreadValues4({}, shape.handles.bend), {
                point: getBendPoint(shape.handles, shape.bend)
              })
            })
          };
        }
        case "start": {
          return {
            decorations: __spreadProps4(__spreadValues4({}, shape.decorations), {
              start: ((_a2 = shape.decorations) == null ? void 0 : _a2.start) ? void 0 : "arrow"
            })
          };
        }
        case "end": {
          return {
            decorations: __spreadProps4(__spreadValues4({}, shape.decorations), {
              end: ((_b = shape.decorations) == null ? void 0 : _b.end) ? void 0 : "arrow"
            })
          };
        }
      }
      return this;
    });
    __publicField3(this, "onHandleChange", (shape, handles) => {
      let nextHandles = Utils.deepMerge(shape.handles, handles);
      let nextBend = shape.bend;
      nextHandles = Utils.deepMerge(nextHandles, {
        start: {
          point: Vec.toFixed(nextHandles.start.point)
        },
        end: {
          point: Vec.toFixed(nextHandles.end.point)
        }
      });
      if (Vec.isEqual(nextHandles.start.point, nextHandles.end.point))
        return;
      if ("bend" in handles) {
        const { start, end, bend } = nextHandles;
        const distance = Vec.dist(start.point, end.point);
        const midPoint = Vec.med(start.point, end.point);
        const angle = Vec.angle(start.point, end.point);
        const u4 = Vec.uni(Vec.vec(start.point, end.point));
        const ap = Vec.add(midPoint, Vec.mul(Vec.per(u4), distance));
        const bp = Vec.sub(midPoint, Vec.mul(Vec.per(u4), distance));
        const bendPoint = Vec.nearestPointOnLineSegment(ap, bp, bend.point, true);
        const bendDist = Vec.dist(midPoint, bendPoint);
        const realBend = bendDist / (distance / 2);
        nextBend = Utils.clamp(realBend, -0.99, 0.99);
        const angleToBend = Vec.angle(start.point, bendPoint);
        if (Vec.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {
          nextBend = 0;
        } else if (isAngleBetween2(angle, angle + Math.PI, angleToBend)) {
          nextBend *= -1;
        }
      }
      const nextShape = {
        point: shape.point,
        bend: nextBend,
        handles: __spreadProps4(__spreadValues4({}, nextHandles), {
          bend: __spreadProps4(__spreadValues4({}, nextHandles.bend), {
            point: getBendPoint(nextHandles, nextBend)
          })
        })
      };
      const topLeft = shape.point;
      const nextBounds = this.getBounds(__spreadValues4({}, nextShape));
      const offset = Vec.sub([nextBounds.minX, nextBounds.minY], topLeft);
      if (!Vec.isEqual(offset, [0, 0])) {
        Object.values(nextShape.handles).forEach((handle) => {
          handle.point = Vec.toFixed(Vec.sub(handle.point, offset));
        });
        nextShape.point = Vec.toFixed(Vec.add(nextShape.point, offset));
      }
      return nextShape;
    });
  }
};
var FullWrapper4 = styled("div", { width: "100%", height: "100%" });
var GroupUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "group");
    __publicField3(this, "canBind", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "group",
        name: "Group",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [100, 100],
        rotation: 0,
        children: [],
        style: defaultStyle
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {
      const { id, size } = shape;
      const sw = 2;
      const w6 = Math.max(0, size[0] - sw / 2);
      const h4 = Math.max(0, size[1] - sw / 2);
      const strokes2 = [
        [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
        [[w6, sw / 2], [w6, h4], h4 - sw / 2],
        [[w6, h4], [sw / 2, h4], w6 - sw / 2],
        [[sw / 2, h4], [sw / 2, sw / 2], h4 - sw / 2]
      ];
      const paths = strokes2.map(([start, end], i8) => {
        return /* @__PURE__ */ React202.createElement("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1]
        });
      });
      return /* @__PURE__ */ React202.createElement(SVGContainer, __spreadValues4({
        ref
      }, events), isBinding && /* @__PURE__ */ React202.createElement("rect", {
        className: "tl-binding-indicator",
        strokeWidth: this.bindingDistance
      }), /* @__PURE__ */ React202.createElement("g", {
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, /* @__PURE__ */ React202.createElement("rect", {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        fill: "transparent",
        pointerEvents: "all"
      }), /* @__PURE__ */ React202.createElement(ScaledLines, {
        stroke: "black",
        opacity: isHovered || isSelected ? 1 : 0,
        strokeLinecap: "round",
        pointerEvents: "stroke"
      }, paths)));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { id, size } = shape;
      const sw = 2;
      const w6 = Math.max(0, size[0] - sw / 2);
      const h4 = Math.max(0, size[1] - sw / 2);
      const strokes2 = [
        [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
        [[w6, sw / 2], [w6, h4], h4 - sw / 2],
        [[w6, h4], [sw / 2, h4], w6 - sw / 2],
        [[sw / 2, h4], [sw / 2, sw / 2], h4 - sw / 2]
      ];
      const paths = strokes2.map(([start, end], i8) => {
        return /* @__PURE__ */ React202.createElement("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1]
        });
      });
      return /* @__PURE__ */ React202.createElement(ScaledLines, {
        strokeLinecap: "round",
        pointerEvents: "stroke"
      }, paths);
    }));
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style;
    });
  }
};
var ScaledLines = styled("g", {
  strokeWidth: "calc(1.5px * var(--tl-scale))",
  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`
});
var StickyUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "sticky");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "hideResizeHandles", true);
    __publicField3(this, "showCloneHandles", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "sticky",
        name: "Sticky",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [200, 200],
        text: "",
        rotation: 0,
        style: defaultTextStyle
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, ref) => {
      const font = getStickyFontStyle(shape.style);
      const { color, fill } = getStickyShapeStyle(shape.style, meta.isDarkMode);
      const rContainer = React212.useRef(null);
      const rTextArea = React212.useRef(null);
      const rText = React212.useRef(null);
      const rTextContent = React212.useRef(shape.text);
      const rIsMounted = React212.useRef(false);
      const handlePointerDown = React212.useCallback((e11) => {
        e11.stopPropagation();
      }, []);
      const handleTextChange = React212.useCallback((e11) => {
        rTextContent.current = TLDR.normalizeText(e11.currentTarget.value);
        onShapeChange == null ? void 0 : onShapeChange({
          id: shape.id,
          type: shape.type,
          text: rTextContent.current
        });
      }, [onShapeChange]);
      const handleKeyDown = React212.useCallback((e11) => {
        if (e11.key === "Escape")
          return;
        if (e11.key === "Tab" && shape.text.length === 0) {
          e11.preventDefault();
          return;
        }
        if (!(e11.key === "Meta" || e11.metaKey)) {
          e11.stopPropagation();
        } else if (e11.key === "z" && e11.metaKey) {
          if (e11.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          e11.stopPropagation();
          e11.preventDefault();
          return;
        }
        if (e11.key === "Tab") {
          e11.preventDefault();
          if (e11.shiftKey) {
            TextAreaUtils.unindent(e11.currentTarget);
          } else {
            TextAreaUtils.indent(e11.currentTarget);
          }
          rTextContent.current = TLDR.normalizeText(e11.currentTarget.value);
          onShapeChange == null ? void 0 : onShapeChange(__spreadProps4(__spreadValues4({}, shape), { text: rTextContent.current }));
        }
      }, [shape, onShapeChange]);
      const handleBlur = React212.useCallback((e11) => {
        e11.currentTarget.setSelectionRange(0, 0);
        onShapeBlur == null ? void 0 : onShapeBlur();
      }, []);
      const handleFocus = React212.useCallback((e11) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        e11.currentTarget.select();
      }, [isEditing]);
      React212.useEffect(() => {
        if (isEditing) {
          rTextContent.current = shape.text;
          rIsMounted.current = true;
          const elm = rTextArea.current;
          elm.focus();
          elm.select();
        }
      }, [isEditing]);
      React212.useEffect(() => {
        const text2 = rText.current;
        const { size } = shape;
        const { offsetHeight: currTextHeight } = text2;
        const minTextHeight = MIN_CONTAINER_HEIGHT - PADDING * 2;
        const prevTextHeight = size[1] - PADDING * 2;
        if (currTextHeight === prevTextHeight)
          return;
        if (currTextHeight > minTextHeight) {
          onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, size: [size[0], currTextHeight + PADDING * 2] });
          return;
        }
        if (currTextHeight < minTextHeight && size[1] > MIN_CONTAINER_HEIGHT) {
          onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, size: [size[0], MIN_CONTAINER_HEIGHT] });
          return;
        }
        const textarea = rTextArea.current;
        textarea == null ? void 0 : textarea.focus();
      }, [shape.text, shape.size[1], shape.style]);
      const style = {
        font,
        color,
        textShadow: meta.isDarkMode ? `0.5px 0.5px 2px rgba(255, 255, 255,.25)` : `0.5px 0.5px 2px rgba(255, 255, 255,.5)`
      };
      return /* @__PURE__ */ React212.createElement(HTMLContainer, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React212.createElement(StyledStickyContainer, {
        ref: rContainer,
        isDarkMode: meta.isDarkMode,
        isGhost,
        style: __spreadValues4({ backgroundColor: fill }, style)
      }, isBinding && /* @__PURE__ */ React212.createElement("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: -this.bindingDistance,
          left: -this.bindingDistance,
          width: `calc(100% + ${this.bindingDistance * 2}px)`,
          height: `calc(100% + ${this.bindingDistance * 2}px)`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), /* @__PURE__ */ React212.createElement(StyledText, {
        ref: rText,
        isEditing,
        alignment: shape.style.textAlign
      }, isEditing ? rTextContent.current : shape.text, "\u200B"), isEditing && /* @__PURE__ */ React212.createElement(StyledTextArea, {
        ref: rTextArea,
        onPointerDown: handlePointerDown,
        value: isEditing ? rTextContent.current : shape.text,
        onChange: handleTextChange,
        onKeyDown: handleKeyDown,
        onFocus: handleFocus,
        onBlur: handleBlur,
        tabIndex: -1,
        autoComplete: "false",
        autoCapitalize: "false",
        autoCorrect: "false",
        autoSave: "false",
        autoFocus: true,
        spellCheck: true,
        alignment: shape.style.textAlign,
        onContextMenu: stopPropagation
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const {
        size: [width, height]
      } = shape;
      return /* @__PURE__ */ React212.createElement("rect", {
        x: 0,
        y: 0,
        rx: 3,
        ry: 3,
        width: Math.max(1, width),
        height: Math.max(1, height)
      });
    }));
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style || next.text !== prev.text;
    });
    __publicField3(this, "transform", (shape, bounds, { scaleX, scaleY, transformOrigin }) => {
      const point = Vec.toFixed([
        bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),
        bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])
      ]);
      return {
        point
      };
    });
    __publicField3(this, "transformSingle", (shape) => {
      return shape;
    });
    __publicField3(this, "getSvgElement", (shape) => {
      const bounds = this.getBounds(shape);
      const textBounds = Utils.expandBounds(bounds, -PADDING);
      const textElm = getTextSvgElement(shape.text, shape.style, textBounds);
      const style = getStickyShapeStyle(shape.style);
      textElm.setAttribute("fill", style.color);
      textElm.setAttribute("transform", `translate(${PADDING}, ${PADDING})`);
      const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", bounds.width + "");
      rect.setAttribute("height", bounds.height + "");
      rect.setAttribute("fill", style.fill);
      rect.setAttribute("rx", "3");
      rect.setAttribute("ry", "3");
      g6.appendChild(rect);
      g6.appendChild(textElm);
      return g6;
    });
  }
};
var PADDING = 16;
var MIN_CONTAINER_HEIGHT = 200;
var StyledStickyContainer = styled("div", {
  pointerEvents: "all",
  position: "relative",
  backgroundColor: "rgba(255, 220, 100)",
  fontFamily: "sans-serif",
  height: "100%",
  width: "100%",
  padding: PADDING + "px",
  borderRadius: "3px",
  perspective: "800px",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isDarkMode: {
      true: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)"
      },
      false: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)"
      }
    }
  }
});
var commonTextWrapping2 = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var StyledText = styled("div", __spreadValues4({
  position: "absolute",
  top: PADDING,
  left: PADDING,
  width: `calc(100% - ${PADDING * 2}px)`,
  height: "fit-content",
  font: "inherit",
  pointerEvents: "none",
  userSelect: "none",
  variants: {
    isEditing: {
      true: {
        opacity: 1
      },
      false: {
        opacity: 1
      }
    },
    alignment: {
      ["start"]: {
        textAlign: "left"
      },
      ["middle"]: {
        textAlign: "center"
      },
      ["end"]: {
        textAlign: "right"
      },
      ["justify"]: {
        textAlign: "justify"
      }
    }
  }
}, commonTextWrapping2));
var StyledTextArea = styled("textarea", __spreadProps4(__spreadValues4({
  width: "100%",
  height: "100%",
  border: "none",
  overflow: "hidden",
  background: "none",
  outline: "none",
  textAlign: "left",
  font: "inherit",
  padding: 0,
  color: "transparent",
  verticalAlign: "top",
  resize: "none",
  caretColor: "black"
}, commonTextWrapping2), {
  variants: {
    alignment: {
      ["start"]: {
        textAlign: "left"
      },
      ["middle"]: {
        textAlign: "center"
      },
      ["end"]: {
        textAlign: "right"
      },
      ["justify"]: {
        textAlign: "justify"
      }
    }
  }
}));
var TextUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "text");
    __publicField3(this, "isAspectRatioLocked", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "canBind", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "bindingDistance", BINDING_DISTANCE / 2);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "text",
        name: "Text",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        text: " ",
        style: defaultTextStyle
      }, props);
    });
    __publicField3(this, "texts", /* @__PURE__ */ new Map());
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {
      const { text: text2, style } = shape;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const font = getFontStyle(shape.style);
      const rInput = React223.useRef(null);
      const rIsMounted = React223.useRef(false);
      const handleChange = React223.useCallback((e11) => {
        let delta = [0, 0];
        const newText = TLDR.normalizeText(e11.currentTarget.value);
        const currentBounds = this.getBounds(shape);
        this.texts.set(shape.id, newText);
        const nextBounds = this.getBounds(__spreadProps4(__spreadValues4({}, shape), {
          text: newText
        }));
        switch (shape.style.textAlign) {
          case "start": {
            break;
          }
          case "middle": {
            delta = Vec.div([nextBounds.width - currentBounds.width, 0], 2);
            break;
          }
          case "end": {
            delta = [nextBounds.width - currentBounds.width, 0];
            break;
          }
        }
        onShapeChange == null ? void 0 : onShapeChange(__spreadProps4(__spreadValues4({}, shape), {
          id: shape.id,
          point: Vec.sub(shape.point, delta),
          text: newText
        }));
      }, [shape.id, shape.point]);
      const onChange2 = React223.useCallback((text22) => {
        this.texts.set(shape.id, TLDR.normalizeText(text22));
        onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, text: this.texts.get(shape.id) });
      }, [shape.id]);
      const handleKeyDown = useTextKeyboardEvents(onChange2);
      const handleBlur = React223.useCallback((e11) => {
        e11.currentTarget.setSelectionRange(0, 0);
        onShapeBlur == null ? void 0 : onShapeBlur();
      }, []);
      const handleFocus = React223.useCallback((e11) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        if (document.activeElement === e11.currentTarget) {
          e11.currentTarget.select();
        }
      }, [isEditing]);
      const handlePointerDown = React223.useCallback((e11) => {
        if (isEditing) {
          e11.stopPropagation();
        }
      }, [isEditing]);
      React223.useEffect(() => {
        if (isEditing) {
          this.texts.set(shape.id, text2);
          requestAnimationFrame(() => {
            rIsMounted.current = true;
            const elm = rInput.current;
            if (elm) {
              elm.focus();
              elm.select();
            }
          });
        } else {
          onShapeBlur == null ? void 0 : onShapeBlur();
        }
      }, [isEditing]);
      return /* @__PURE__ */ React223.createElement(HTMLContainer, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ React223.createElement(Wrapper, {
        isGhost,
        isEditing,
        onPointerDown: handlePointerDown
      }, /* @__PURE__ */ React223.createElement(InnerWrapper2, {
        style: {
          font,
          color: styles22.stroke,
          textAlign: getTextAlign(style.textAlign)
        }
      }, isBinding && /* @__PURE__ */ React223.createElement("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: -this.bindingDistance,
          left: -this.bindingDistance,
          width: `calc(100% + ${this.bindingDistance * 2}px)`,
          height: `calc(100% + ${this.bindingDistance * 2}px)`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), isEditing ? /* @__PURE__ */ React223.createElement(TextArea2, {
        ref: rInput,
        style: {
          font,
          color: styles22.stroke
        },
        name: "text",
        tabIndex: -1,
        autoComplete: "false",
        autoCapitalize: "false",
        autoCorrect: "false",
        autoSave: "false",
        autoFocus: true,
        placeholder: "",
        spellCheck: "true",
        wrap: "off",
        dir: "auto",
        datatype: "wysiwyg",
        defaultValue: text2,
        color: styles22.stroke,
        onFocus: handleFocus,
        onChange: handleChange,
        onKeyDown: handleKeyDown,
        onBlur: handleBlur,
        onPointerDown: handlePointerDown,
        onContextMenu: stopPropagation
      }) : text2, "\u200B")));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { width, height } = this.getBounds(shape);
      return /* @__PURE__ */ React223.createElement("rect", {
        x: 0,
        y: 0,
        width,
        height
      });
    }));
    __publicField3(this, "getBounds", (shape) => {
      const bounds = Utils.getFromCache(this.boundsCache, shape, () => {
        var _a2;
        if (!melm2) {
          return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };
        }
        if (!melm2.parentNode)
          document.body.appendChild(melm2);
        melm2.style.font = getFontStyle(shape.style);
        melm2.textContent = (_a2 = this.texts.get(shape.id)) != null ? _a2 : shape.text;
        const width = melm2.offsetWidth || 1;
        const height = melm2.offsetHeight || 1;
        return {
          minX: 0,
          maxX: width,
          minY: 0,
          maxY: height,
          width,
          height
        };
      });
      return Utils.translateBounds(bounds, shape.point);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style;
    });
    __publicField3(this, "transform", (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const {
        rotation = 0,
        style: { scale = 1 }
      } = initialShape;
      const nextScale = scale * Math.abs(Math.min(scaleX, scaleY));
      return {
        point: [bounds.minX, bounds.minY],
        rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation,
        style: __spreadProps4(__spreadValues4({}, initialShape.style), {
          scale: nextScale
        })
      };
    });
    __publicField3(this, "transformSingle", (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const {
        style: { scale = 1 }
      } = initialShape;
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        style: __spreadProps4(__spreadValues4({}, initialShape.style), {
          scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX))
        })
      };
    });
    __publicField3(this, "onDoubleClickBoundsHandle", (shape) => {
      const center = this.getCenter(shape);
      const newCenter = this.getCenter(__spreadProps4(__spreadValues4({}, shape), {
        style: __spreadProps4(__spreadValues4({}, shape.style), {
          scale: 1
        })
      }));
      return {
        style: __spreadProps4(__spreadValues4({}, shape.style), {
          scale: 1
        }),
        point: Vec.toFixed(Vec.add(shape.point, Vec.sub(center, newCenter)))
      };
    });
    __publicField3(this, "getSvgElement", (shape) => {
      const bounds = this.getBounds(shape);
      const elm = getTextSvgElement(shape.text, shape.style, bounds);
      elm.setAttribute("fill", getShapeStyle(shape.style).stroke);
      return elm;
    });
  }
};
var melm2;
function getMeasurementDiv2() {
  var _a2;
  (_a2 = document.getElementById("__textMeasure")) == null ? void 0 : _a2.remove();
  const pre = document.createElement("pre");
  pre.id = "__textMeasure";
  Object.assign(pre.style, {
    whiteSpace: "pre",
    width: "auto",
    border: "1px solid transparent",
    padding: "4px",
    margin: "0px",
    letterSpacing: LETTER_SPACING,
    opacity: "0",
    position: "absolute",
    top: "-500px",
    left: "0px",
    zIndex: "9999",
    pointerEvents: "none",
    userSelect: "none",
    alignmentBaseline: "mathematical",
    dominantBaseline: "mathematical"
  });
  pre.tabIndex = -1;
  document.body.appendChild(pre);
  return pre;
}
if (typeof window !== "undefined") {
  melm2 = getMeasurementDiv2();
}
var Wrapper = styled("div", {
  width: "100%",
  height: "100%",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isEditing: {
      false: {
        pointerEvents: "all",
        userSelect: "all"
      },
      true: {
        pointerEvents: "none",
        userSelect: "none"
      }
    }
  }
});
var commonTextWrapping3 = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var InnerWrapper2 = styled("div", __spreadValues4({
  position: "absolute",
  width: "100%",
  height: "100%",
  padding: "4px",
  zIndex: 1,
  minHeight: 1,
  minWidth: 1,
  lineHeight: 1,
  letterSpacing: LETTER_SPACING,
  outline: 0,
  fontWeight: "500",
  backfaceVisibility: "hidden",
  userSelect: "none",
  pointerEvents: "none",
  WebkitUserSelect: "none",
  WebkitTouchCallout: "none",
  isEditing: {
    false: {},
    true: {
      pointerEvents: "all",
      background: "$boundsBg",
      userSelect: "text",
      WebkitUserSelect: "text"
    }
  }
}, commonTextWrapping3));
var TextArea2 = styled("textarea", __spreadValues4({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  width: "100%",
  height: "100%",
  border: "none",
  padding: "4px",
  resize: "none",
  textAlign: "inherit",
  minHeight: "inherit",
  minWidth: "inherit",
  lineHeight: "inherit",
  letterSpacing: "inherit",
  outline: 0,
  fontWeight: "inherit",
  overflow: "hidden",
  backfaceVisibility: "hidden",
  display: "inline-block",
  pointerEvents: "all",
  background: "$boundsBg",
  userSelect: "text",
  WebkitUserSelect: "text"
}, commonTextWrapping3));
var simulatePressureSettings = {
  easing: (t12) => Math.sin(t12 * Math.PI / 2),
  simulatePressure: true
};
var realPressureSettings = {
  easing: (t12) => t12 * t12,
  simulatePressure: false
};
function getFreehandOptions(shape) {
  const styles22 = getShapeStyle(shape.style);
  const options2 = __spreadProps4(__spreadValues4({
    size: 1 + styles22.strokeWidth * 1.5,
    thinning: 0.65,
    streamline: 0.65,
    smoothing: 0.65
  }, shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings), {
    last: shape.isComplete
  });
  return options2;
}
function getFillPath(shape) {
  if (shape.points.length < 2)
    return "";
  return Utils.getSvgPathFromStroke(ce(shape.points, getFreehandOptions(shape)).map((pt) => pt.point));
}
function getDrawStrokePoints(shape, options2) {
  return ce(shape.points, options2);
}
function getDrawStrokePathTDSnapshot(shape) {
  if (shape.points.length < 2)
    return "";
  const options2 = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options2);
  const path = Utils.getSvgPathFromStroke(ie(strokePoints, options2));
  return path;
}
function getSolidStrokePathTDSnapshot(shape) {
  const { points } = shape;
  if (points.length < 2)
    return "M 0 0 L 0 0";
  const options2 = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options2).map((pt) => pt.point.slice(0, 2));
  const last2 = points[points.length - 1].slice(0, 2);
  if (!src_default.isEqual(strokePoints[0], last2))
    strokePoints.push(last2);
  const path = Utils.getSvgPathFromStroke(strokePoints, false);
  return path;
}
var DrawUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "draw");
    __publicField3(this, "pointsBoundsCache", /* @__PURE__ */ new WeakMap([]));
    __publicField3(this, "shapeBoundsCache", /* @__PURE__ */ new Map());
    __publicField3(this, "rotatedCache", /* @__PURE__ */ new WeakMap([]));
    __publicField3(this, "pointCache", {});
    __publicField3(this, "canClone", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "id",
        type: "draw",
        name: "Draw",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        style: defaultStyle,
        points: [],
        isComplete: false
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, meta, isSelected, isGhost, events }, ref) => {
      const { points, style, isComplete } = shape;
      const polygonPathTDSnapshot = React232.useMemo(() => {
        return getFillPath(shape);
      }, [points, style.size]);
      const pathTDSnapshot = React232.useMemo(() => {
        return style.dash === "draw" ? getDrawStrokePathTDSnapshot(shape) : getSolidStrokePathTDSnapshot(shape);
      }, [points, style.size, style.dash, isComplete]);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const { stroke, fill, strokeWidth } = styles22;
      const bounds = this.getBounds(shape);
      const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2;
      if (verySmall) {
        const sw2 = 1 + strokeWidth;
        return /* @__PURE__ */ React232.createElement(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), /* @__PURE__ */ React232.createElement("circle", {
          r: sw2,
          fill: stroke,
          stroke,
          pointerEvents: "all",
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }));
      }
      const shouldFill = style.isFilled && points.length > 3 && Vec.dist(points[0], points[points.length - 1]) < strokeWidth * 2;
      if (shape.style.dash === "draw") {
        return /* @__PURE__ */ React232.createElement(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), /* @__PURE__ */ React232.createElement("g", {
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }, /* @__PURE__ */ React232.createElement("path", {
          className: shouldFill || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
          d: pathTDSnapshot
        }), shouldFill && /* @__PURE__ */ React232.createElement("path", {
          d: polygonPathTDSnapshot,
          stroke: "none",
          fill,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        }), /* @__PURE__ */ React232.createElement("path", {
          d: pathTDSnapshot,
          fill: stroke,
          stroke,
          strokeWidth: strokeWidth / 2,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        })));
      }
      const strokeDasharray = {
        ["draw"]: "none",
        ["solid"]: `none`,
        ["dotted"]: `0.1 ${strokeWidth * 4}`,
        ["dashed"]: `${strokeWidth * 4} ${strokeWidth * 4}`
      }[style.dash];
      const strokeDashoffset = {
        ["draw"]: "none",
        ["solid"]: `none`,
        ["dotted"]: `0`,
        ["dashed"]: `0`
      }[style.dash];
      const sw = 1 + strokeWidth * 1.5;
      return /* @__PURE__ */ React232.createElement(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), /* @__PURE__ */ React232.createElement("g", {
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, /* @__PURE__ */ React232.createElement("path", {
        className: shouldFill && isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        d: pathTDSnapshot
      }), /* @__PURE__ */ React232.createElement("path", {
        d: pathTDSnapshot,
        fill: shouldFill ? fill : "none",
        stroke: "none",
        strokeWidth: Math.min(4, strokeWidth * 2),
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none"
      }), /* @__PURE__ */ React232.createElement("path", {
        d: pathTDSnapshot,
        fill: "none",
        stroke,
        strokeWidth: sw,
        strokeDasharray,
        strokeDashoffset,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none"
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const { points } = shape;
      const pathTDSnapshot = React232.useMemo(() => {
        return getSolidStrokePathTDSnapshot(shape);
      }, [points]);
      const bounds = this.getBounds(shape);
      const verySmall = bounds.width < 4 && bounds.height < 4;
      if (verySmall) {
        return /* @__PURE__ */ React232.createElement("circle", {
          x: bounds.width / 2,
          y: bounds.height / 2,
          r: 1
        });
      }
      return /* @__PURE__ */ React232.createElement("path", {
        d: pathTDSnapshot
      });
    }));
    __publicField3(this, "transform", (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const initialShapeBounds = Utils.getFromCache(this.boundsCache, initialShape, () => Utils.getBoundsFromPoints(initialShape.points));
      const points = initialShape.points.map(([x6, y5, r12]) => {
        return [
          bounds.width * (scaleX < 0 ? 1 - x6 / initialShapeBounds.width : x6 / initialShapeBounds.width),
          bounds.height * (scaleY < 0 ? 1 - y5 / initialShapeBounds.height : y5 / initialShapeBounds.height),
          r12
        ];
      });
      const newBounds = Utils.getBoundsFromPoints(shape.points);
      const point = Vec.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);
      return {
        points,
        point
      };
    });
    __publicField3(this, "getBounds", (shape) => {
      const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points);
      const pointHasChanged = !(this.pointCache[shape.id] === shape.point);
      if (pointsHaveChanged) {
        const bounds = Utils.getBoundsFromPoints(shape.points);
        this.pointsBoundsCache.set(shape.points, bounds);
        this.shapeBoundsCache.set(shape.id, Utils.translateBounds(bounds, shape.point));
        this.pointCache[shape.id] = shape.point;
      } else if (pointHasChanged && !pointsHaveChanged) {
        this.pointCache[shape.id] = shape.point;
        this.shapeBoundsCache.set(shape.id, Utils.translateBounds(this.pointsBoundsCache.get(shape.points), shape.point));
      }
      return this.shapeBoundsCache.get(shape.id);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.points !== prev.points || next.style !== prev.style || next.isComplete !== prev.isComplete;
    });
    __publicField3(this, "hitTestPoint", (shape, point) => {
      const ptA = Vec.sub(point, shape.point);
      return Utils.pointInPolyline(ptA, shape.points);
    });
    __publicField3(this, "hitTestLineSegment", (shape, A3, B4) => {
      const { points, point } = shape;
      const ptA = Vec.sub(A3, point);
      const ptB = Vec.sub(B4, point);
      const bounds = this.getBounds(shape);
      if (points.length <= 2) {
        return Vec.distanceToLineSegment(A3, B4, shape.point) < 4;
      }
      if (intersectLineSegmentBounds(ptA, ptB, bounds)) {
        for (let i8 = 1; i8 < points.length; i8++) {
          if (intersectLineSegmentLineSegment(points[i8 - 1], points[i8], ptA, ptB).didIntersect) {
            return true;
          }
        }
      }
      return false;
    });
    __publicField3(this, "hitTestBounds", (shape, bounds) => {
      if (!shape.rotation) {
        const shapeBounds = this.getBounds(shape);
        return Utils.boundsContain(bounds, shapeBounds) || (Utils.boundsContain(shapeBounds, bounds) || intersectBoundsBounds(shapeBounds, bounds).length > 0) && intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), shape.points).length > 0;
      }
      const rBounds = this.getRotatedBounds(shape);
      const rotatedBounds = Utils.getFromCache(this.rotatedCache, shape, () => {
        const c8 = Utils.getBoundsCenter(Utils.getBoundsFromPoints(shape.points));
        return shape.points.map((pt) => Vec.rotWith(pt, c8, shape.rotation || 0));
      });
      return Utils.boundsContain(bounds, rBounds) || intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), rotatedBounds).length > 0;
    });
  }
};
var ImageUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "image");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "isAspectRatioLocked", true);
    __publicField3(this, "showCloneHandles", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "image",
        type: "image",
        name: "Image",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: __spreadProps4(__spreadValues4({}, defaultStyle), { isFilled: true }),
        assetId: "assetId"
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, asset = { src: "" }, isBinding, isGhost, meta, events, onShapeChange }, ref) => {
      const { size, style } = shape;
      const rImage = React242.useRef(null);
      const rWrapper = React242.useRef(null);
      React242.useLayoutEffect(() => {
        const wrapper = rWrapper.current;
        if (!wrapper)
          return;
        const [width, height] = size;
        wrapper.style.width = `${width}px`;
        wrapper.style.height = `${height}px`;
      }, [size]);
      return /* @__PURE__ */ React242.createElement(HTMLContainer, __spreadValues4({
        ref
      }, events), isBinding && /* @__PURE__ */ React242.createElement("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: `calc(${-this.bindingDistance}px * var(--tl-zoom))`,
          left: `calc(${-this.bindingDistance}px * var(--tl-zoom))`,
          width: `calc(100% + ${this.bindingDistance * 2}px * var(--tl-zoom))`,
          height: `calc(100% + ${this.bindingDistance * 2}px * var(--tl-zoom))`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), /* @__PURE__ */ React242.createElement(Wrapper2, {
        ref: rWrapper,
        isDarkMode: meta.isDarkMode,
        isFilled: style.isFilled,
        isGhost
      }, /* @__PURE__ */ React242.createElement(ImageElement, {
        id: shape.id + "_image",
        ref: rImage,
        src: asset.src,
        alt: "tl_image_asset",
        draggable: false
      })));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const {
        size: [width, height]
      } = shape;
      return /* @__PURE__ */ React242.createElement("rect", {
        x: 0,
        y: 0,
        rx: 2,
        ry: 2,
        width: Math.max(1, width),
        height: Math.max(1, height)
      });
    }));
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style;
    });
    __publicField3(this, "transform", transformRectangle);
    __publicField3(this, "transformSingle", transformSingleRectangle);
    __publicField3(this, "getSvgElement", (shape) => {
      const bounds = this.getBounds(shape);
      const elm = document.createElementNS("http://www.w3.org/2000/svg", "image");
      elm.setAttribute("width", `${bounds.width}`);
      elm.setAttribute("height", `${bounds.height}`);
      elm.setAttribute("xmlns:xlink", `http://www.w3.org/1999/xlink`);
      return elm;
    });
  }
};
var Wrapper2 = re("div", {
  pointerEvents: "all",
  position: "relative",
  fontFamily: "sans-serif",
  fontSize: "2em",
  height: "100%",
  width: "100%",
  borderRadius: "3px",
  perspective: "800px",
  overflow: "hidden",
  p: {
    userSelect: "none"
  },
  img: {
    userSelect: "none"
  },
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isFilled: {
      true: {},
      false: {}
    },
    isDarkMode: {
      true: {},
      false: {}
    }
  },
  compoundVariants: [
    {
      isFilled: true,
      isDarkMode: true,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)"
      }
    },
    {
      isFilled: true,
      isDarkMode: false,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)"
      }
    }
  ]
});
var ImageElement = re("img", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  maxWidth: "100%",
  minWidth: "100%",
  pointerEvents: "none",
  objectFit: "cover",
  userSelect: "none",
  borderRadius: 2
});
var VideoUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "video");
    __publicField3(this, "canBind", true);
    __publicField3(this, "canEdit", true);
    __publicField3(this, "canClone", true);
    __publicField3(this, "isAspectRatioLocked", true);
    __publicField3(this, "showCloneHandles", true);
    __publicField3(this, "isStateful", true);
    __publicField3(this, "getShape", (props) => {
      return Utils.deepMerge({
        id: "video",
        type: "video",
        name: "Video",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle,
        assetId: "assetId",
        isPlaying: true,
        currentTime: 0
      }, props);
    });
    __publicField3(this, "Component", TDShapeUtil.Component(({ shape, asset = { src: "" }, isBinding, isEditing, isGhost, meta, events, onShapeChange }, ref) => {
      const rVideo = React252.useRef(null);
      const rWrapper = React252.useRef(null);
      const { currentTime = 0, size, isPlaying, style } = shape;
      React252.useLayoutEffect(() => {
        const wrapper = rWrapper.current;
        if (!wrapper)
          return;
        const [width, height] = size;
        wrapper.style.width = `${width}px`;
        wrapper.style.height = `${height}px`;
      }, [size]);
      React252.useLayoutEffect(() => {
        const video = rVideo.current;
        if (!video)
          return;
        if (isPlaying)
          video.play();
        else
          video.pause();
      }, [isPlaying]);
      React252.useLayoutEffect(() => {
        const video = rVideo.current;
        if (!video)
          return;
        if (currentTime !== video.currentTime) {
          video.currentTime = currentTime;
        }
      }, [currentTime]);
      const handlePlay = React252.useCallback(() => {
        onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, isPlaying: true });
      }, []);
      const handlePause = React252.useCallback(() => {
        onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, isPlaying: false });
      }, []);
      const handleSetCurrentTime = React252.useCallback(() => {
        const video = rVideo.current;
        if (!video)
          return;
        if (!isEditing)
          return;
        onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, currentTime: video.currentTime });
      }, [isEditing]);
      return /* @__PURE__ */ React252.createElement(HTMLContainer, __spreadValues4({
        ref
      }, events), isBinding && /* @__PURE__ */ React252.createElement("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: -this.bindingDistance,
          left: -this.bindingDistance,
          width: `calc(100% + ${this.bindingDistance * 2}px)`,
          height: `calc(100% + ${this.bindingDistance * 2}px)`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), /* @__PURE__ */ React252.createElement(Wrapper3, {
        ref: rWrapper,
        isDarkMode: meta.isDarkMode,
        isGhost,
        isFilled: style.isFilled
      }, /* @__PURE__ */ React252.createElement(VideoElement, {
        ref: rVideo,
        id: shape.id + "_video",
        muted: true,
        loop: true,
        playsInline: true,
        disableRemotePlayback: true,
        disablePictureInPicture: true,
        controls: isEditing,
        autoPlay: isPlaying,
        onPlay: handlePlay,
        onPause: handlePause,
        onTimeUpdate: handleSetCurrentTime
      }, /* @__PURE__ */ React252.createElement("source", {
        src: asset.src
      }))));
    }));
    __publicField3(this, "Indicator", TDShapeUtil.Indicator(({ shape }) => {
      const {
        size: [width, height]
      } = shape;
      return /* @__PURE__ */ React252.createElement("rect", {
        x: 0,
        y: 0,
        rx: 2,
        ry: 2,
        width: Math.max(1, width),
        height: Math.max(1, height)
      });
    }));
    __publicField3(this, "getBounds", (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    });
    __publicField3(this, "shouldRender", (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style || next.isPlaying !== prev.isPlaying;
    });
    __publicField3(this, "getSvgElement", (shape) => {
      const bounds = this.getBounds(shape);
      const elm = document.createElementNS("http://www.w3.org/2000/svg", "image");
      elm.setAttribute("width", `${bounds.width}`);
      elm.setAttribute("height", `${bounds.height}`);
      elm.setAttribute("xmlns:xlink", `http://www.w3.org/1999/xlink`);
      return elm;
    });
    __publicField3(this, "transform", transformRectangle);
    __publicField3(this, "transformSingle", transformSingleRectangle);
  }
};
var Wrapper3 = re("div", {
  pointerEvents: "all",
  position: "relative",
  fontFamily: "sans-serif",
  fontSize: "2em",
  height: "100%",
  width: "100%",
  borderRadius: "3px",
  perspective: "800px",
  overflow: "hidden",
  p: {
    userSelect: "none"
  },
  img: {
    userSelect: "none"
  },
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isFilled: {
      true: {},
      false: {}
    },
    isDarkMode: {
      true: {},
      false: {}
    }
  },
  compoundVariants: [
    {
      isFilled: true,
      isDarkMode: true,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)"
      }
    },
    {
      isFilled: true,
      isDarkMode: false,
      css: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)"
      }
    }
  ]
});
var VideoElement = re("video", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  maxWidth: "100%",
  minWidth: "100%",
  pointerEvents: "none",
  objectFit: "cover",
  userSelect: "none",
  borderRadius: 2
});
var Rectangle = new RectangleUtil();
var Triangle = new TriangleUtil();
var Ellipse = new EllipseUtil();
var Draw = new DrawUtil();
var Arrow6 = new ArrowUtil();
var Text = new TextUtil();
var Group2 = new GroupUtil();
var Sticky = new StickyUtil();
var Image2 = new ImageUtil();
var Video = new VideoUtil();
var shapeUtils = {
  ["rectangle"]: Rectangle,
  ["triangle"]: Triangle,
  ["ellipse"]: Ellipse,
  ["draw"]: Draw,
  ["arrow"]: Arrow6,
  ["text"]: Text,
  ["group"]: Group2,
  ["sticky"]: Sticky,
  ["image"]: Image2,
  ["video"]: Video
};
var getShapeUtil = (shape) => {
  if (typeof shape === "string")
    return shapeUtils[shape];
  return shapeUtils[shape.type];
};
function deepCopy(target) {
  if (target === null) {
    return target;
  }
  if (target instanceof Date) {
    return new Date(target.getTime());
  }
  if (typeof target === "object") {
    if (typeof target[Symbol.iterator] === "function") {
      const cp = [];
      if (target.length > 0) {
        for (const arrayMember of target) {
          cp.push(deepCopy(arrayMember));
        }
      }
      return cp;
    } else {
      const targetKeys = Object.keys(target);
      const cp = {};
      if (targetKeys.length > 0) {
        for (const key of targetKeys) {
          cp[key] = deepCopy(target[key]);
        }
      }
      return cp;
    }
  }
  return target;
}
var isDev = false;
var _TLDR = class {
  static getShapeUtil(shape) {
    return getShapeUtil(shape);
  }
  static getSelectedShapes(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    return selectedIds.map((id) => page.shapes[id]);
  }
  static screenToWorld(data, point) {
    const camera = _TLDR.getPageState(data, data.appState.currentPageId).camera;
    return Vec.sub(Vec.div(point, camera.zoom), camera.point);
  }
  static getCameraZoom(zoom) {
    return Utils.clamp(zoom, 0.1, 5);
  }
  static getPage(data, pageId) {
    return data.document.pages[pageId];
  }
  static getPageState(data, pageId) {
    return data.document.pageStates[pageId];
  }
  static getSelectedIds(data, pageId) {
    return _TLDR.getPageState(data, pageId).selectedIds;
  }
  static getShapes(data, pageId) {
    return Object.values(_TLDR.getPage(data, pageId).shapes);
  }
  static getCamera(data, pageId) {
    return _TLDR.getPageState(data, pageId).camera;
  }
  static getShape(data, shapeId, pageId) {
    return _TLDR.getPage(data, pageId).shapes[shapeId];
  }
  static getCenter(shape) {
    return _TLDR.getShapeUtil(shape).getCenter(shape);
  }
  static getBounds(shape) {
    return _TLDR.getShapeUtil(shape).getBounds(shape);
  }
  static getRotatedBounds(shape) {
    return _TLDR.getShapeUtil(shape).getRotatedBounds(shape);
  }
  static getSelectedBounds(data) {
    return Utils.getCommonBounds(_TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) => _TLDR.getShapeUtil(shape).getBounds(shape)));
  }
  static getParentId(data, id, pageId) {
    return _TLDR.getShape(data, id, pageId).parentId;
  }
  static getDocumentBranch(data, id, pageId) {
    const shape = _TLDR.getShape(data, id, pageId);
    if (shape.children === void 0)
      return [id];
    return [
      id,
      ...shape.children.flatMap((childId) => _TLDR.getDocumentBranch(data, childId, pageId))
    ];
  }
  static getSelectedBranchSnapshot(data, pageId, fn) {
    const page = _TLDR.getPage(data, pageId);
    const copies = _TLDR.getSelectedIds(data, pageId).flatMap((id) => _TLDR.getDocumentBranch(data, id, pageId).map((id2) => page.shapes[id2])).filter((shape) => !shape.isLocked).map(Utils.deepClone);
    if (fn !== void 0) {
      return copies.map((shape) => __spreadValues4({ id: shape.id }, fn(shape)));
    }
    return copies;
  }
  static getSelectedShapeSnapshot(data, pageId, fn) {
    const copies = _TLDR.getSelectedShapes(data, pageId).filter((shape) => !shape.isLocked).map(Utils.deepClone);
    if (fn !== void 0) {
      return copies.map((shape) => __spreadValues4({ id: shape.id }, fn(shape)));
    }
    return copies;
  }
  static getAllEffectedShapeIds(data, ids, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const visited = new Set(ids);
    ids.forEach((id) => {
      const shape = page.shapes[id];
      function collectDescendants(shape2) {
        if (shape2.children === void 0)
          return;
        shape2.children.filter((childId) => !visited.has(childId)).forEach((childId) => {
          visited.add(childId);
          collectDescendants(page.shapes[childId]);
        });
      }
      collectDescendants(shape);
      function collectAscendants(shape2) {
        const parentId = shape2.parentId;
        if (parentId === page.id)
          return;
        if (visited.has(parentId))
          return;
        visited.add(parentId);
        collectAscendants(page.shapes[parentId]);
      }
      collectAscendants(shape);
      visited.forEach((id2) => {
        Object.values(page.bindings).filter((binding) => binding.fromId === id2 || binding.toId === id2).forEach((binding) => visited.add(binding.fromId === id2 ? binding.toId : binding.fromId));
      });
    });
    return Array.from(visited.values());
  }
  static getLinkedShapeIds(data, pageId, direction, includeArrows = true) {
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    const page = _TLDR.getPage(data, pageId);
    const linkedIds = new Set(selectedIds);
    const checkedIds = /* @__PURE__ */ new Set();
    const idsToCheck = [...selectedIds];
    const arrows = new Set(Object.values(page.shapes).filter((shape) => {
      var _a2;
      return shape.type === "arrow" && (shape.handles.start.bindingId || ((_a2 = shape.handles) == null ? void 0 : _a2.end.bindingId));
    }));
    while (idsToCheck.length) {
      const id = idsToCheck.pop();
      if (!(id && arrows.size))
        break;
      if (checkedIds.has(id))
        continue;
      checkedIds.add(id);
      arrows.forEach((arrow) => {
        var _a2, _b;
        const {
          handles: {
            start: { bindingId: startBindingId },
            end: { bindingId: endBindingId }
          }
        } = arrow;
        const startBinding = startBindingId ? page.bindings[startBindingId] : null;
        const endBinding = endBindingId ? page.bindings[endBindingId] : null;
        let hit = false;
        if (startBinding && startBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (((_a2 = arrow.decorations) == null ? void 0 : _a2.start) && endBinding) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow.id);
            linkedIds.add(id);
            if (endBinding) {
              linkedIds.add(endBinding.toId);
              idsToCheck.push(endBinding.toId);
            }
          }
        } else if (endBinding && endBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (((_b = arrow.decorations) == null ? void 0 : _b.end) && startBinding) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow.id);
            linkedIds.add(id);
            if (startBinding) {
              linkedIds.add(startBinding.toId);
              idsToCheck.push(startBinding.toId);
            }
          }
        }
        if ((!startBinding || linkedIds.has(startBinding.toId)) && (!endBinding || linkedIds.has(endBinding.toId))) {
          arrows.delete(arrow);
        }
      });
    }
    return Array.from(linkedIds.values());
  }
  static getChildIndexAbove(data, id, pageId) {
    const page = data.document.pages[pageId];
    const shape = page.shapes[id];
    let siblings;
    if (shape.parentId === page.id) {
      siblings = Object.values(page.shapes).filter((shape2) => shape2.parentId === page.id).sort((a7, b7) => a7.childIndex - b7.childIndex);
    } else {
      const parent = page.shapes[shape.parentId];
      if (!parent.children)
        throw Error("No children in parent!");
      siblings = parent.children.map((childId) => page.shapes[childId]).sort((a7, b7) => a7.childIndex - b7.childIndex);
    }
    const index2 = siblings.indexOf(shape);
    const nextSibling = siblings[index2 + 1];
    if (!nextSibling)
      return shape.childIndex + 1;
    return nextSibling.childIndex;
  }
  static getBeforeShape(shape, change) {
    return Object.fromEntries(Object.keys(change).map((k4) => [k4, shape[k4]]));
  }
  static mutateShapes(data, ids, fn, pageId) {
    const beforeShapes = {};
    const afterShapes = {};
    ids.forEach((id, i8) => {
      const shape = _TLDR.getShape(data, id, pageId);
      if (shape.isLocked)
        return;
      const change = fn(shape, i8);
      if (change) {
        beforeShapes[id] = _TLDR.getBeforeShape(shape, change);
        afterShapes[id] = change;
      }
    });
    const dataWithMutations = Utils.deepMerge(data, {
      document: {
        pages: {
          [data.appState.currentPageId]: {
            shapes: afterShapes
          }
        }
      }
    });
    return {
      before: beforeShapes,
      after: afterShapes,
      data: dataWithMutations
    };
  }
  static createShapes(data, shapes, pageId) {
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapes.flatMap((shape) => {
              const results = [[shape.id, void 0]];
              if (shape.parentId !== pageId) {
                const parent = _TLDR.getShape(data, shape.parentId, pageId);
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([parent.id, { children: parent.children }]);
              }
              return results;
            })))
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              shapes: __spreadValues4({}, Object.fromEntries(shapes.flatMap((shape) => {
                const results = [[shape.id, shape]];
                if (shape.parentId !== pageId) {
                  const parent = _TLDR.getShape(data, shape.parentId, pageId);
                  if (!parent.children)
                    throw Error("No children in parent!");
                  results.push([parent.id, { children: [...parent.children, shape.id] }]);
                }
                return results;
              })))
            }
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static deleteShapes(data, shapes, pageId) {
    pageId = pageId ? pageId : data.appState.currentPageId;
    const page = _TLDR.getPage(data, pageId);
    const shapeIds = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapeIds.flatMap((id) => {
              const shape = page.shapes[id];
              const results = [[shape.id, shape]];
              if (shape.parentId !== pageId) {
                const parent = page.shapes[shape.parentId];
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([parent.id, { children: parent.children }]);
              }
              return results;
            }))),
            bindings: __spreadValues4({}, Object.fromEntries(Object.values(page.bindings).filter((binding) => {
              return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId);
            }).map((binding) => {
              return [binding.id, binding];
            })))
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapeIds.flatMap((id) => {
              const shape = page.shapes[id];
              const results = [[shape.id, void 0]];
              if (shape.parentId !== page.id) {
                const parent = page.shapes[shape.parentId];
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([
                  parent.id,
                  { children: parent.children.filter((id2) => id2 !== shape.id) }
                ]);
              }
              return results;
            })))
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static onSessionComplete(shape) {
    var _a2, _b;
    const delta = (_b = (_a2 = _TLDR.getShapeUtil(shape)).onSessionComplete) == null ? void 0 : _b.call(_a2, shape);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static onChildrenChange(data, shape, pageId) {
    var _a2, _b;
    if (!shape.children)
      return;
    const delta = (_b = (_a2 = _TLDR.getShapeUtil(shape)).onChildrenChange) == null ? void 0 : _b.call(_a2, shape, shape.children.map((id) => _TLDR.getShape(data, id, pageId)));
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static updateArrowBindings(page, arrowShape) {
    var _a2, _b, _c, _d, _e, _f;
    const result = {
      start: deepCopy(arrowShape.handles.start),
      end: deepCopy(arrowShape.handles.end)
    };
    let start = {
      isBound: false,
      handle: arrowShape.handles.start,
      point: Vec.add(arrowShape.handles.start.point, arrowShape.point)
    };
    let end = {
      isBound: false,
      handle: arrowShape.handles.end,
      point: Vec.add(arrowShape.handles.end.point, arrowShape.point)
    };
    if (arrowShape.handles.start.bindingId) {
      const hasDecoration = ((_a2 = arrowShape.decorations) == null ? void 0 : _a2.start) !== void 0;
      const handle = arrowShape.handles.start;
      const binding = page.bindings[arrowShape.handles.start.bindingId];
      if (!binding)
        throw Error("Could not find a binding to match the start handle's bindingId");
      const target = page.shapes[binding.toId];
      const util = _TLDR.getShapeUtil(target);
      const bounds = util.getBounds(target);
      const expandedBounds = util.getExpandedBounds(target);
      const intersectBounds = hasDecoration ? Utils.expandBounds(bounds, binding.distance) : bounds;
      const { minX, minY, width, height } = expandedBounds;
      const anchorPoint = Vec.add([minX, minY], Vec.mulV([width, height], Vec.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));
      start = {
        isBound: true,
        hasDecoration,
        binding,
        handle,
        point: anchorPoint,
        util,
        target,
        bounds,
        expandedBounds,
        intersectBounds,
        center: util.getCenter(target)
      };
    }
    if (arrowShape.handles.end.bindingId) {
      const hasDecoration = ((_b = arrowShape.decorations) == null ? void 0 : _b.end) !== void 0;
      const handle = arrowShape.handles.end;
      const binding = page.bindings[arrowShape.handles.end.bindingId];
      if (!binding)
        throw Error("Could not find a binding to match the end handle's bindingId");
      const target = page.shapes[binding.toId];
      const util = _TLDR.getShapeUtil(target);
      const bounds = util.getBounds(target);
      const expandedBounds = util.getExpandedBounds(target);
      const intersectBounds = hasDecoration ? Utils.expandBounds(bounds, binding.distance) : bounds;
      const { minX, minY, width, height } = expandedBounds;
      const anchorPoint = Vec.add([minX, minY], Vec.mulV([width, height], Vec.rotWith(binding.point, [0.5, 0.5], target.rotation || 0)));
      end = {
        isBound: true,
        hasDecoration,
        binding,
        handle,
        point: anchorPoint,
        util,
        target,
        bounds,
        expandedBounds,
        intersectBounds,
        center: util.getCenter(target)
      };
    }
    for (const ID2 of ["end", "start"]) {
      const A3 = ID2 === "start" ? start : end;
      const B4 = ID2 === "start" ? end : start;
      if (A3.isBound) {
        if (!A3.binding.distance) {
          result[ID2].point = Vec.sub(A3.point, arrowShape.point);
        } else {
          const direction = Vec.uni(Vec.sub(A3.point, B4.point));
          switch (A3.target.type) {
            case "ellipse": {
              const hits = intersectRayEllipse(B4.point, direction, A3.center, A3.target.radius[0] + (A3.hasDecoration ? A3.binding.distance : 0), A3.target.radius[1] + (A3.hasDecoration ? A3.binding.distance : 0), A3.target.rotation || 0).points.sort((a7, b7) => Vec.dist(a7, B4.point) - Vec.dist(b7, B4.point));
              if (hits[0] !== void 0) {
                result[ID2].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point));
              }
              break;
            }
            case "triangle": {
              const targetPoint = A3.target.point;
              const points = getTrianglePoints(A3.target.size, A3.hasDecoration ? BINDING_DISTANCE : 0, A3.target.rotation).map((pt) => Vec.add(pt, targetPoint));
              const hits = Utils.pointsToLineSegments(points, true).map(([p0, p1]) => intersectRayLineSegment(B4.point, direction, p0, p1)).filter((intersection) => intersection.didIntersect).flatMap((intersection) => intersection.points).sort((a7, b7) => Vec.dist(a7, B4.point) - Vec.dist(b7, B4.point));
              if (hits[0] !== void 0) {
                result[ID2].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point));
              }
              break;
            }
            default: {
              const hits = intersectRayBounds(B4.point, direction, A3.intersectBounds, A3.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b7) => Vec.dist(a7, B4.point) - Vec.dist(b7, B4.point));
              if (!hits[0])
                continue;
              let bHit = void 0;
              if (B4.isBound) {
                const bHits = intersectRayBounds(B4.point, direction, B4.intersectBounds, B4.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a7, b7) => Vec.dist(a7, B4.point) - Vec.dist(b7, B4.point));
                bHit = bHits[0];
              }
              if (B4.isBound && (hits.length < 2 || bHit && hits[0] && Math.ceil(Vec.dist(hits[0], bHit)) < BINDING_DISTANCE * 2.5 || Utils.boundsContain(A3.expandedBounds, B4.expandedBounds) || Utils.boundsCollide(A3.expandedBounds, B4.expandedBounds))) {
                const shortArrowDirection = Vec.uni(Vec.sub(B4.point, A3.point));
                const shortArrowHits = intersectRayBounds(A3.point, shortArrowDirection, A3.bounds, A3.target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]);
                if (!shortArrowHits[0])
                  continue;
                result[ID2].point = Vec.toFixed(Vec.sub(shortArrowHits[0], arrowShape.point));
                result[ID2 === "start" ? "end" : "start"].point = Vec.toFixed(Vec.add(Vec.sub(shortArrowHits[0], arrowShape.point), Vec.mul(shortArrowDirection, Math.min(Vec.dist(shortArrowHits[0], B4.point), BINDING_DISTANCE * 2.5 * (Utils.boundsContain(B4.bounds, A3.intersectBounds) ? -1 : 1)))));
              } else if (!B4.isBound && (hits[0] && Vec.dist(hits[0], B4.point) < BINDING_DISTANCE * 2.5 || Utils.pointInBounds(B4.point, A3.intersectBounds))) {
                const shortArrowDirection = Vec.uni(Vec.sub(A3.center, B4.point));
                return (_d = (_c = _TLDR.getShapeUtil(arrowShape)).onHandleChange) == null ? void 0 : _d.call(_c, arrowShape, {
                  [ID2]: __spreadProps4(__spreadValues4({}, arrowShape.handles[ID2]), {
                    point: Vec.toFixed(Vec.add(Vec.sub(B4.point, arrowShape.point), Vec.mul(shortArrowDirection, BINDING_DISTANCE * 2.5)))
                  })
                });
              } else if (hits[0]) {
                result[ID2].point = Vec.toFixed(Vec.sub(hits[0], arrowShape.point));
              }
            }
          }
        }
      }
    }
    return (_f = (_e = _TLDR.getShapeUtil(arrowShape)).onHandleChange) == null ? void 0 : _f.call(_e, arrowShape, result);
  }
  static transform(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transform(shape, bounds, info);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static transformSingle(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static getRotatedShapeMutation(shape, center, origin, delta) {
    var _a2, _b;
    const relativeCenter = Vec.sub(center, shape.point);
    const rotatedCenter = Vec.rotWith(center, origin, delta);
    const nextPoint = Vec.toFixed(Vec.sub(rotatedCenter, relativeCenter));
    if (shape.handles !== void 0) {
      const change = (_b = (_a2 = this.getShapeUtil(shape)).onHandleChange) == null ? void 0 : _b.call(_a2, __spreadProps4(__spreadValues4({}, shape), { point: nextPoint }), Object.fromEntries(Object.entries(shape.handles).map(([handleId, handle]) => {
        const point = Vec.toFixed(Vec.rotWith(handle.point, relativeCenter, delta));
        return [handleId, __spreadProps4(__spreadValues4({}, handle), { point })];
      })));
      return change;
    }
    const nextRotation = Utils.clampRadians((shape.rotation || 0) + delta);
    return {
      point: nextPoint,
      rotation: nextRotation
    };
  }
  static updateParents(data, pageId, changedShapeIds) {
    const page = _TLDR.getPage(data, pageId);
    if (changedShapeIds.length === 0)
      return;
    const { shapes } = _TLDR.getPage(data, pageId);
    const parentToUpdateIds = Array.from(new Set(changedShapeIds.map((id) => shapes[id].parentId).values())).filter((id) => id !== page.id);
    for (const parentId of parentToUpdateIds) {
      const parent = shapes[parentId];
      if (!parent.children) {
        throw Error("A shape is parented to a shape without a children array.");
      }
      _TLDR.onChildrenChange(data, parent, pageId);
    }
    _TLDR.updateParents(data, pageId, parentToUpdateIds);
  }
  static getBinding(data, id, pageId) {
    return _TLDR.getPage(data, pageId).bindings[id];
  }
  static getBindings(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    return Object.values(page.bindings);
  }
  static getBindableShapeIds(data) {
    return _TLDR.getShapes(data, data.appState.currentPageId).filter((shape) => _TLDR.getShapeUtil(shape).canBind).sort((a7, b7) => b7.childIndex - a7.childIndex).map((shape) => shape.id);
  }
  static getBindingsWithShapeIds(data, ids, pageId) {
    return Array.from(new Set(_TLDR.getBindings(data, pageId).filter((binding) => {
      return ids.includes(binding.toId) || ids.includes(binding.fromId);
    })).values());
  }
  static getRelatedBindings(data, ids, pageId) {
    const changedShapeIds = new Set(ids);
    const page = _TLDR.getPage(data, pageId);
    const bindingsArr = Object.values(page.bindings);
    const bindingsToUpdate = new Set(bindingsArr.filter((binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)));
    let prevSize2 = bindingsToUpdate.size;
    let delta = -1;
    while (delta !== 0) {
      bindingsToUpdate.forEach((binding) => {
        const fromId = binding.fromId;
        for (const otherBinding of bindingsArr) {
          if (otherBinding.fromId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
          if (otherBinding.toId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
        }
      });
      delta = bindingsToUpdate.size - prevSize2;
      prevSize2 = bindingsToUpdate.size;
    }
    return Array.from(bindingsToUpdate.values());
  }
  static normalizeText(text2) {
    return text2.replace(_TLDR.fixNewLines, "\n").split("\n").map((x6) => x6 || " ").join("\n");
  }
  static assertShapeHasProperty(shape, prop) {
    if (shape[prop] === void 0) {
      throw new Error();
    }
  }
  static warn(e11) {
    if (isDev) {
      console.warn(e11);
    }
  }
  static error(e11) {
    if (isDev) {
      console.error(e11);
    }
  }
};
var TLDR = _TLDR;
__publicField3(TLDR, "copyStringToClipboard", (string) => {
  try {
    navigator.clipboard.writeText(string);
  } catch (e11) {
    const textarea = document.createElement("textarea");
    textarea.setAttribute("position", "fixed");
    textarea.setAttribute("top", "0");
    textarea.setAttribute("readonly", "true");
    textarea.setAttribute("contenteditable", "true");
    textarea.style.position = "fixed";
    textarea.value = string;
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    try {
      const range = document.createRange();
      range.selectNodeContents(textarea);
      const sel = window.getSelection();
      if (sel) {
        sel.removeAllRanges();
        sel.addRange(range);
        textarea.setSelectionRange(0, textarea.value.length);
      }
    } catch (err) {
      null;
    } finally {
      document.body.removeChild(textarea);
    }
  }
});
__publicField3(TLDR, "flattenShape", (data, shape) => {
  var _a2;
  return [
    shape,
    ...((_a2 = shape.children) != null ? _a2 : []).map((childId) => _TLDR.getShape(data, childId, data.appState.currentPageId)).sort((a7, b7) => a7.childIndex - b7.childIndex).flatMap((shape2) => _TLDR.flattenShape(data, shape2))
  ];
});
__publicField3(TLDR, "flattenPage", (data, pageId) => {
  return Object.values(data.document.pages[pageId].shapes).sort((a7, b7) => a7.childIndex - b7.childIndex).reduce((acc, shape) => [...acc, ..._TLDR.flattenShape(data, shape)], []);
});
__publicField3(TLDR, "getTopChildIndex", (data, pageId) => {
  const shapes = _TLDR.getShapes(data, pageId);
  return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === pageId).sort((a7, b7) => b7.childIndex - a7.childIndex)[0].childIndex + 1;
});
__publicField3(TLDR, "fixNewLines", /\r?\n|\r/g);
function alignShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => {
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: TLDR.getBounds(shape)
    };
  });
  const commonBounds = Utils.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds));
  const midX = commonBounds.minX + commonBounds.width / 2;
  const midY = commonBounds.minY + commonBounds.height / 2;
  const deltaMap = Object.fromEntries(boundsForShapes.map(({ id, point, bounds }) => {
    return [
      id,
      {
        prev: point,
        next: {
          ["centerVertical"]: [point[0], midY - bounds.height / 2],
          ["centerHorizontal"]: [midX - bounds.width / 2, point[1]],
          ["top"]: [point[0], commonBounds.minY],
          ["bottom"]: [point[0], commonBounds.maxY - bounds.height],
          ["left"]: [commonBounds.minX, point[1]],
          ["right"]: [commonBounds.maxX - bounds.width, point[1]]
        }[type]
      }
    ];
  }));
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    if (!deltaMap[shape.id])
      return shape;
    return { point: deltaMap[shape.id].next };
  }, currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === "group") {
      const delta = Vec.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: Vec.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "align",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function changePage(app, pageId) {
  return {
    id: "change_page",
    before: {
      appState: {
        currentPageId: app.currentPageId
      }
    },
    after: {
      appState: {
        currentPageId: pageId
      }
    }
  };
}
function createPage(app, center, pageId = Utils.uniqueId()) {
  const { currentPageId } = app;
  const topPage = Object.values(app.state.document.pages).sort((a7, b7) => (b7.childIndex || 0) - (a7.childIndex || 0))[0];
  const nextChildIndex = (topPage == null ? void 0 : topPage.childIndex) ? (topPage == null ? void 0 : topPage.childIndex) + 1 : 1;
  const nextName = `New Page`;
  const page = {
    id: pageId,
    name: nextName,
    childIndex: nextChildIndex,
    shapes: {},
    bindings: {}
  };
  const pageState = {
    id: pageId,
    selectedIds: [],
    camera: { point: center, zoom: 1 },
    editingId: void 0,
    bindingId: void 0,
    hoveredId: void 0,
    pointedId: void 0
  };
  return {
    id: "create_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: page.id
      },
      document: {
        pages: {
          [pageId]: page
        },
        pageStates: {
          [pageId]: pageState
        }
      }
    }
  };
}
function createShapes(app, shapes, bindings = []) {
  const { currentPageId } = app;
  const beforeShapes = {};
  const afterShapes = {};
  shapes.forEach((shape) => {
    beforeShapes[shape.id] = void 0;
    afterShapes[shape.id] = shape;
  });
  const beforeBindings = {};
  const afterBindings = {};
  bindings.forEach((binding) => {
    beforeBindings[binding.id] = void 0;
    afterBindings[binding.id] = binding;
  });
  return {
    id: "create",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: [...app.selectedIds]
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes,
            bindings: afterBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: shapes.map((shape) => shape.id)
          }
        }
      }
    }
  };
}
function deletePage(app, pageId) {
  const {
    currentPageId,
    document: { pages, pageStates }
  } = app;
  const pagesArr = Object.values(pages).sort((a7, b7) => (a7.childIndex || 0) - (b7.childIndex || 0));
  const currentIndex = pagesArr.findIndex((page) => page.id === pageId);
  let nextCurrentPageId;
  if (pageId === currentPageId) {
    if (currentIndex === pagesArr.length - 1) {
      nextCurrentPageId = pagesArr[pagesArr.length - 2].id;
    } else {
      nextCurrentPageId = pagesArr[currentIndex + 1].id;
    }
  } else {
    nextCurrentPageId = currentPageId;
  }
  return {
    id: "delete_page",
    before: {
      appState: {
        currentPageId: pageId
      },
      document: {
        pages: {
          [pageId]: __spreadValues4({}, pages[pageId])
        },
        pageStates: {
          [pageId]: __spreadValues4({}, pageStates[pageId])
        }
      }
    },
    after: {
      appState: {
        currentPageId: nextCurrentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    }
  };
}
function removeShapesFromPage(data, ids, pageId) {
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const parentsToUpdate = [];
  const deletedIds = /* @__PURE__ */ new Set();
  const assetsToRemove = /* @__PURE__ */ new Set();
  ids.filter((id) => !TLDR.getShape(data, id, pageId).isLocked).forEach((id) => {
    deletedIds.add(id);
    const shape = TLDR.getShape(data, id, pageId);
    before.shapes[id] = shape;
    after.shapes[id] = void 0;
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        deletedIds.add(childId);
        const child = TLDR.getShape(data, childId, pageId);
        before.shapes[childId] = child;
        after.shapes[childId] = void 0;
      });
    }
    if (shape.parentId !== pageId) {
      parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId));
    }
    if (shape.assetId) {
      assetsToRemove.add(shape.assetId);
    }
  });
  parentsToUpdate.forEach((parent) => {
    var _a2;
    if (ids.includes(parent.id))
      return;
    deletedIds.add(parent.id);
    before.shapes[parent.id] = { children: parent.children };
    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) };
    if (((_a2 = after.shapes[parent.id]) == null ? void 0 : _a2.children.length) === 0) {
      after.shapes[parent.id] = void 0;
      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId);
    }
  });
  const page = TLDR.getPage(data, pageId);
  Object.values(page.bindings).filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId)).forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (after.shapes[id] === void 0) {
        before.bindings[binding.id] = binding;
        after.bindings[binding.id] = void 0;
        const shape = page.shapes[id];
        if (shape && shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            var _a2, _b, _c, _d, _e, _f;
            before.shapes[id] = __spreadProps4(__spreadValues4({}, before.shapes[id]), {
              handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[id]) == null ? void 0 : _a2.handles), {
                [handle.id]: __spreadProps4(__spreadValues4({}, (_c = (_b = before.shapes[id]) == null ? void 0 : _b.handles) == null ? void 0 : _c[handle.id]), {
                  bindingId: binding.id
                })
              })
            });
            if (!deletedIds.has(id)) {
              after.shapes[id] = __spreadProps4(__spreadValues4({}, after.shapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_d = after.shapes[id]) == null ? void 0 : _d.handles), {
                  [handle.id]: __spreadProps4(__spreadValues4({}, (_f = (_e = after.shapes[id]) == null ? void 0 : _e.handles) == null ? void 0 : _f[handle.id]), {
                    bindingId: void 0
                  })
                })
              });
            }
          });
        }
      }
    }
  });
  Object.values(data.document.pages).flatMap((page2) => Object.values(page2.shapes)).forEach((shape) => {
    if ("assetId" in shape && shape.assetId && !deletedIds.has(shape.id)) {
      assetsToRemove.delete(shape.assetId);
    }
  });
  return { before, after, assetsToRemove: Array.from(assetsToRemove) };
}
var removeAssetsFromDocument = (assets, idsToRemove) => {
  const afterAssets = __spreadValues4({}, assets);
  idsToRemove.forEach((id) => afterAssets[id] = void 0);
  return afterAssets;
};
function deleteShapes(app, ids, pageId = app.currentPageId) {
  const {
    pageState,
    selectedIds,
    document: { assets: beforeAssets }
  } = app;
  const { before, after, assetsToRemove } = removeShapesFromPage(app.state, ids, pageId);
  const afterAssets = removeAssetsFromDocument(beforeAssets, assetsToRemove);
  return {
    id: "delete",
    before: {
      document: {
        assets: beforeAssets,
        pages: {
          [pageId]: before
        },
        pageStates: {
          [pageId]: { selectedIds: [...app.selectedIds] }
        }
      }
    },
    after: {
      document: {
        assets: afterAssets,
        pages: {
          [pageId]: after
        },
        pageStates: {
          [pageId]: {
            selectedIds: selectedIds.filter((id) => !ids.includes(id)),
            hoveredId: pageState.hoveredId && ids.includes(pageState.hoveredId) ? void 0 : pageState.hoveredId
          }
        }
      }
    }
  };
}
function distributeShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d7) => [d7.id, d7]));
  const { before, after } = TLDR.mutateShapes(app.state, ids.filter((id) => deltaMap[id] !== void 0), (shape) => ({ point: deltaMap[shape.id].next }), currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === "group") {
      const delta = src_default.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: src_default.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "distribute",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function getDistributions(initialShapes, type) {
  const entries = initialShapes.map((shape) => {
    const utils = TLDR.getShapeUtil(shape);
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: utils.getBounds(shape),
      center: utils.getCenter(shape)
    };
  });
  const len = entries.length;
  const commonBounds = Utils.getCommonBounds(entries.map(({ bounds }) => bounds));
  const results = [];
  switch (type) {
    case "horizontal": {
      const span = entries.reduce((a7, c8) => a7 + c8.bounds.width, 0);
      if (span > commonBounds.width) {
        const left = entries.sort((a7, b7) => a7.bounds.minX - b7.bounds.minX)[0];
        const right = entries.sort((a7, b7) => b7.bounds.maxX - a7.bounds.maxX)[0];
        const entriesToMove = entries.filter((a7) => a7 !== left && a7 !== right).sort((a7, b7) => a7.center[0] - b7.center[0]);
        const step = (right.center[0] - left.center[0]) / (len - 1);
        const x6 = left.center[0] + step;
        entriesToMove.forEach(({ id, point, bounds }, i8) => {
          results.push({
            id,
            prev: point,
            next: [x6 + step * i8 - bounds.width / 2, bounds.minY]
          });
        });
      } else {
        const entriesToMove = entries.sort((a7, b7) => a7.center[0] - b7.center[0]);
        let x6 = commonBounds.minX;
        const step = (commonBounds.width - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [x6, bounds.minY] });
          x6 += bounds.width + step;
        });
      }
      break;
    }
    case "vertical": {
      const span = entries.reduce((a7, c8) => a7 + c8.bounds.height, 0);
      if (span > commonBounds.height) {
        const top2 = entries.sort((a7, b7) => a7.bounds.minY - b7.bounds.minY)[0];
        const bottom = entries.sort((a7, b7) => b7.bounds.maxY - a7.bounds.maxY)[0];
        const entriesToMove = entries.filter((a7) => a7 !== top2 && a7 !== bottom).sort((a7, b7) => a7.center[1] - b7.center[1]);
        const step = (bottom.center[1] - top2.center[1]) / (len - 1);
        const y5 = top2.center[1] + step;
        entriesToMove.forEach(({ id, point, bounds }, i8) => {
          results.push({
            id,
            prev: point,
            next: [bounds.minX, y5 + step * i8 - bounds.height / 2]
          });
        });
      } else {
        const entriesToMove = entries.sort((a7, b7) => a7.center[1] - b7.center[1]);
        let y5 = commonBounds.minY;
        const step = (commonBounds.height - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [bounds.minX, y5] });
          y5 += bounds.height + step;
        });
      }
      break;
    }
  }
  return results;
}
function duplicatePage(app, pageId) {
  const newId = Utils.uniqueId();
  const {
    currentPageId,
    page,
    pageState: { camera }
  } = app;
  const nextPage = __spreadProps4(__spreadValues4({}, page), {
    id: newId,
    name: page.name + " Copy",
    shapes: Object.fromEntries(Object.entries(page.shapes).map(([id, shape]) => {
      return [
        id,
        __spreadProps4(__spreadValues4({}, shape), {
          parentId: shape.parentId === pageId ? newId : shape.parentId
        })
      ];
    }))
  });
  return {
    id: "duplicate_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [newId]: void 0
        },
        pageStates: {
          [newId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: newId
      },
      document: {
        pages: {
          [newId]: nextPage
        },
        pageStates: {
          [newId]: __spreadProps4(__spreadValues4({}, page), {
            id: newId,
            selectedIds: [],
            camera: __spreadValues4({}, camera),
            editingId: void 0,
            bindingId: void 0,
            hoveredId: void 0,
            pointedId: void 0
          })
        }
      }
    }
  };
}
function duplicateShapes(app, ids, point) {
  const { selectedIds, currentPageId, page, shapes } = app;
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const duplicateMap = {};
  const shapesToDuplicate = ids.map((id) => app.getShape(id)).filter((shape) => !ids.includes(shape.parentId));
  shapesToDuplicate.forEach((shape) => {
    const duplicatedId = Utils.uniqueId();
    before.shapes[duplicatedId] = void 0;
    after.shapes[duplicatedId] = __spreadProps4(__spreadValues4({}, Utils.deepClone(shape)), {
      id: duplicatedId,
      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId)
    });
    if (shape.children) {
      after.shapes[duplicatedId].children = [];
    }
    if (shape.parentId !== currentPageId) {
      const parent = app.getShape(shape.parentId);
      before.shapes[parent.id] = __spreadProps4(__spreadValues4({}, before.shapes[parent.id]), {
        children: parent.children
      });
      after.shapes[parent.id] = __spreadProps4(__spreadValues4({}, after.shapes[parent.id]), {
        children: [...(after.shapes[parent.id] || parent).children, duplicatedId]
      });
    }
    duplicateMap[shape.id] = duplicatedId;
  });
  shapesToDuplicate.forEach((shape) => {
    if (shape.children) {
      shape.children.forEach((childId) => {
        var _a2, _b;
        const child = app.getShape(childId);
        const duplicatedId = Utils.uniqueId();
        const duplicatedParentId = duplicateMap[shape.id];
        before.shapes[duplicatedId] = void 0;
        after.shapes[duplicatedId] = __spreadProps4(__spreadValues4({}, Utils.deepClone(child)), {
          id: duplicatedId,
          parentId: duplicatedParentId,
          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId)
        });
        duplicateMap[childId] = duplicatedId;
        (_b = (_a2 = after.shapes[duplicateMap[shape.id]]) == null ? void 0 : _a2.children) == null ? void 0 : _b.push(duplicatedId);
      });
    }
  });
  const dupedShapeIds = new Set(Object.keys(duplicateMap));
  Object.values(page.bindings).filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId)).forEach((binding) => {
    if (dupedShapeIds.has(binding.fromId)) {
      if (dupedShapeIds.has(binding.toId)) {
        const duplicatedBindingId = Utils.uniqueId();
        const duplicatedBinding = __spreadProps4(__spreadValues4({}, Utils.deepClone(binding)), {
          id: duplicatedBindingId,
          fromId: duplicateMap[binding.fromId],
          toId: duplicateMap[binding.toId]
        });
        before.bindings[duplicatedBindingId] = void 0;
        after.bindings[duplicatedBindingId] = duplicatedBinding;
        const boundShape = after.shapes[duplicatedBinding.fromId];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = duplicatedBindingId;
          }
        });
      } else {
        const boundShape = after.shapes[duplicateMap[binding.fromId]];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = void 0;
          }
        });
      }
    }
  });
  const shapesToMove = Object.values(after.shapes);
  if (point) {
    const commonBounds = Utils.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));
    const center = Utils.getBoundsCenter(commonBounds);
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = Vec.sub(point, Vec.sub(center, shape.point));
    });
  } else {
    const offset = [16, 16];
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = Vec.add(shape.point, offset);
    });
  }
  shapesToMove.forEach((shape) => {
    if (shape.isLocked) {
      shape.isLocked = false;
    }
  });
  return {
    id: "duplicate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: { selectedIds }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: Array.from(dupedShapeIds.values()).map((id) => duplicateMap[id])
          }
        }
      }
    }
  };
}
function flipShapes(app, ids, type) {
  const { selectedIds, currentPageId, shapes } = app;
  const boundsForShapes = shapes.map((shape) => TLDR.getBounds(shape));
  const commonBounds = Utils.getCommonBounds(boundsForShapes);
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    const shapeBounds = TLDR.getBounds(shape);
    switch (type) {
      case "horizontal": {
        const newShapeBounds = Utils.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, true, false);
        return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: -1,
          scaleY: 1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
      case "vertical": {
        const newShapeBounds = Utils.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, false, true);
        return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: 1,
          scaleY: -1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
    }
  }, currentPageId);
  return {
    id: "flip",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function groupShapes(app, ids, groupId, pageId) {
  var _a2, _b;
  if (ids.length < 2)
    return;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const idsToGroup = [...ids];
  const shapesToGroup = [];
  const deletedGroupIds = [];
  const otherEffectedGroups = [];
  for (const id of ids) {
    const shape = app.getShape(id);
    if (shape.isLocked)
      continue;
    if (shape.children === void 0) {
      shapesToGroup.push(shape);
    } else {
      const childIds = shape.children.filter((id2) => !app.getShape(id2).isLocked);
      otherEffectedGroups.push(shape);
      idsToGroup.push(...childIds);
      shapesToGroup.push(...childIds.map((id2) => app.getShape(id2)).filter(Boolean));
    }
  }
  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId)) {
    if (shapesToGroup[0].parentId !== pageId) {
      const commonParent = app.getShape(shapesToGroup[0].parentId);
      if (((_a2 = commonParent.children) == null ? void 0 : _a2.length) === idsToGroup.length) {
        return;
      }
    }
  }
  const flattenedShapes = TLDR.flattenPage(app.state, pageId);
  const shapeIndexMap = Object.fromEntries(shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)]));
  const sortedShapes = shapesToGroup.sort((a7, b7) => shapeIndexMap[a7.id] - shapeIndexMap[b7.id]);
  const groupParentId = pageId;
  const groupChildIndex = (sortedShapes.filter((shape) => shape.parentId === pageId)[0] || sortedShapes[0]).childIndex;
  const groupBounds = Utils.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)));
  beforeShapes[groupId] = void 0;
  afterShapes[groupId] = TLDR.getShapeUtil("group").create({
    id: groupId,
    childIndex: groupChildIndex,
    parentId: groupParentId,
    point: [groupBounds.minX, groupBounds.minY],
    size: [groupBounds.width, groupBounds.height],
    children: sortedShapes.map((shape) => shape.id)
  });
  sortedShapes.forEach((shape, index2) => {
    if (shape.parentId !== pageId) {
      const parentShape = app.getShape(shape.parentId);
      otherEffectedGroups.push(parentShape);
    }
    beforeShapes[shape.id] = __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
      parentId: shape.parentId,
      childIndex: shape.childIndex
    });
    afterShapes[shape.id] = __spreadProps4(__spreadValues4({}, afterShapes[shape.id]), {
      parentId: groupId,
      childIndex: index2 + 1
    });
  });
  while (otherEffectedGroups.length > 0) {
    const shape = otherEffectedGroups.pop();
    if (!shape)
      break;
    const nextChildren = (((_b = beforeShapes[shape.id]) == null ? void 0 : _b.children) || shape.children).filter((childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId)));
    if (nextChildren.length === 0) {
      beforeShapes[shape.id] = shape;
      afterShapes[shape.id] = void 0;
      if (shape.parentId !== pageId) {
        deletedGroupIds.push(shape.id);
        otherEffectedGroups.push(app.getShape(shape.parentId));
      }
    } else {
      beforeShapes[shape.id] = __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
        children: shape.children
      });
      afterShapes[shape.id] = __spreadProps4(__spreadValues4({}, afterShapes[shape.id]), {
        children: nextChildren
      });
    }
  }
  const { bindings } = app;
  const deletedGroupIdsSet = new Set(deletedGroupIds);
  bindings.forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (deletedGroupIdsSet.has(id)) {
        beforeBindings[binding.id] = binding;
        afterBindings[binding.id] = void 0;
        const shape = app.getShape(id);
        if (shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            var _a22, _b2;
            beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), {
              handles: __spreadProps4(__spreadValues4({}, (_a22 = beforeShapes[id]) == null ? void 0 : _a22.handles), {
                [handle.id]: { bindingId: binding.id }
              })
            });
            if (!deletedGroupIds.includes(id)) {
              afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_b2 = afterShapes[id]) == null ? void 0 : _b2.handles), {
                  [handle.id]: { bindingId: void 0 }
                })
              });
            }
          });
        }
      }
    }
  });
  return {
    id: "group",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: [groupId]
          }
        }
      }
    }
  };
}
function moveShapesToPage(app, ids, viewportBounds, fromPageId, toPageId) {
  const { page } = app;
  const fromPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const toPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const movingShapeIds = /* @__PURE__ */ new Set();
  const shapesToMove = /* @__PURE__ */ new Set();
  ids.map((id) => app.getShape(id, fromPageId)).filter((shape) => !shape.isLocked).forEach((shape) => {
    movingShapeIds.add(shape.id);
    shapesToMove.add(shape);
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        movingShapeIds.add(childId);
        shapesToMove.add(app.getShape(childId, fromPageId));
      });
    }
  });
  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId);
  const movingShapes = Array.from(shapesToMove.values());
  movingShapes.forEach((shape, i8) => {
    fromPage.before.shapes[shape.id] = shape;
    fromPage.after.shapes[shape.id] = void 0;
    toPage.before.shapes[shape.id] = void 0;
    toPage.after.shapes[shape.id] = shape;
    if (!movingShapeIds.has(shape.parentId)) {
      toPage.after.shapes[shape.id] = __spreadProps4(__spreadValues4({}, shape), {
        parentId: toPageId,
        childIndex: startingChildIndex + i8
      });
      if (shape.parentId !== fromPageId) {
        const parent = app.getShape(shape.parentId, fromPageId);
        fromPage.before.shapes[parent.id] = {
          children: parent.children
        };
        fromPage.after.shapes[parent.id] = {
          children: parent.children.filter((childId) => childId !== shape.id)
        };
      }
    }
  });
  Object.values(page.bindings).filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId)).forEach((binding) => {
    fromPage.before.bindings[binding.id] = binding;
    fromPage.after.bindings[binding.id] = void 0;
    const fromBoundShape = app.getShape(binding.fromId, fromPageId);
    const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId);
    if (shouldCopy) {
      toPage.before.bindings[binding.id] = void 0;
      toPage.after.bindings[binding.id] = binding;
    } else {
      if (movingShapeIds.has(binding.fromId)) {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        const handleId = handle.id;
        const toPageShape = toPage.after.shapes[fromShape.id];
        toPageShape.handles = __spreadProps4(__spreadValues4({}, toPageShape.handles), {
          [handleId]: __spreadProps4(__spreadValues4({}, toPageShape.handles[handleId]), {
            bindingId: void 0
          })
        });
      } else {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        fromPage.before.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: binding.id } }
        };
        fromPage.after.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: void 0 } }
        };
      }
    }
  });
  const toPageState = app.state.document.pageStates[toPageId];
  const bounds = Utils.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)));
  const zoom = TLDR.getCameraZoom(viewportBounds.width < viewportBounds.height ? (viewportBounds.width - 128) / bounds.width : (viewportBounds.height - 128) / bounds.height);
  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom;
  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom;
  const point = Vec.toFixed(Vec.add([-bounds.minX, -bounds.minY], [mx, my]));
  return {
    id: "move_to_page",
    before: {
      appState: {
        currentPageId: fromPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.before,
          [toPageId]: toPage.before
        },
        pageStates: {
          [fromPageId]: { selectedIds: ids },
          [toPageId]: {
            selectedIds: toPageState.selectedIds,
            camera: toPageState.camera
          }
        }
      }
    },
    after: {
      appState: {
        currentPageId: toPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.after,
          [toPageId]: toPage.after
        },
        pageStates: {
          [fromPageId]: { selectedIds: [] },
          [toPageId]: {
            selectedIds: ids,
            camera: {
              zoom,
              point
            }
          }
        }
      }
    }
  };
}
function reorderShapes(app, ids, type) {
  const { currentPageId, page } = app;
  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId));
  let result = { before: {}, after: {} };
  let startIndex;
  let startChildIndex;
  let step;
  Array.from(parentIds.values()).forEach((parentId) => {
    let sortedChildren = [];
    if (parentId === page.id) {
      sortedChildren = Object.values(page.shapes).sort((a7, b7) => a7.childIndex - b7.childIndex);
    } else {
      const parent = app.getShape(parentId);
      if (!parent.children)
        throw Error("No children in parent!");
      sortedChildren = parent.children.map((childId) => app.getShape(childId)).sort((a7, b7) => a7.childIndex - b7.childIndex);
    }
    const sortedChildIds = sortedChildren.map((shape) => shape.id);
    const sortedIndicesToMove = ids.filter((id) => sortedChildIds.includes(id)).map((id) => sortedChildIds.indexOf(id)).sort((a7, b7) => a7 - b7);
    if (sortedIndicesToMove.length === sortedChildIds.length)
      return;
    switch (type) {
      case "toBack": {
        for (let i8 = 0; i8 < sortedChildIds.length; i8++) {
          if (sortedIndicesToMove.includes(i8))
            continue;
          startIndex = i8;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = startChildIndex / (sortedIndicesToMove.length + 1);
        result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id).reverse(), (_shape, i8) => ({
          childIndex: startChildIndex - (i8 + 1) * step
        }), currentPageId);
        break;
      }
      case "toFront": {
        for (let i8 = sortedChildIds.length - 1; i8 >= 0; i8--) {
          if (sortedIndicesToMove.includes(i8))
            continue;
          startIndex = i8;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = 1;
        result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (_shape, i8) => ({
          childIndex: startChildIndex + (i8 + 1)
        }), currentPageId);
        break;
      }
      case "backward": {
        const indexMap = {};
        for (let i8 = sortedChildIds.length - 1; i8 >= 0; i8--) {
          if (sortedIndicesToMove.includes(i8)) {
            for (let j4 = i8; j4 >= 0; j4--) {
              if (!sortedIndicesToMove.includes(j4)) {
                const endChildIndex = sortedChildren[j4].childIndex;
                let startChildIndex2;
                let step2;
                if (j4 === 0) {
                  startChildIndex2 = endChildIndex / 2;
                  step2 = endChildIndex / 2 / (i8 - j4 + 1);
                } else {
                  startChildIndex2 = sortedChildren[j4 - 1].childIndex;
                  step2 = (endChildIndex - startChildIndex2) / (i8 - j4 + 1);
                  startChildIndex2 += step2;
                }
                for (let k4 = 0; k4 < i8 - j4; k4++) {
                  indexMap[sortedChildren[j4 + k4 + 1].id] = startChildIndex2 + step2 * k4;
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (shape) => ({
            childIndex: indexMap[shape.id]
          }), currentPageId);
        }
        break;
      }
      case "forward": {
        const indexMap = {};
        for (let i8 = 0; i8 < sortedChildIds.length; i8++) {
          if (sortedIndicesToMove.includes(i8)) {
            for (let j4 = i8; j4 < sortedChildIds.length; j4++) {
              if (!sortedIndicesToMove.includes(j4)) {
                startChildIndex = sortedChildren[j4].childIndex;
                const step2 = j4 === sortedChildIds.length - 1 ? 1 : (sortedChildren[j4 + 1].childIndex - startChildIndex) / (j4 - i8 + 1);
                for (let k4 = 0; k4 < j4 - i8; k4++) {
                  indexMap[sortedChildren[i8 + k4].id] = startChildIndex + step2 * (k4 + 1);
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (shape) => ({
            childIndex: indexMap[shape.id]
          }), currentPageId);
        }
        break;
      }
    }
  });
  return {
    id: "move",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function renamePage(app, pageId, name) {
  const { page } = app;
  return {
    id: "rename_page",
    before: {
      document: {
        pages: {
          [pageId]: { name: page.name }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: { name }
        }
      }
    }
  };
}
function resetBounds(app, ids, pageId) {
  const { currentPageId } = app;
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    var _a2, _b;
    return (_b = (_a2 = app.getShapeUtil(shape)).onDoubleClickBoundsHandle) == null ? void 0 : _b.call(_a2, shape);
  }, pageId);
  return {
    id: "reset_bounds",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
var PI23 = Math.PI * 2;
function rotateShapes(app, ids, delta = -PI23 / 4) {
  const { currentPageId } = app;
  const before = {};
  const after = {};
  const shapesToRotate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape;
  }).filter((shape) => !shape.isLocked);
  const origin = Utils.getBoundsCenter(Utils.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape))));
  shapesToRotate.forEach((shape) => {
    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta);
    if (!change)
      return;
    before[shape.id] = TLDR.getBeforeShape(shape, change);
    after[shape.id] = change;
  });
  return {
    id: "rotate",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function stretchShapes(app, ids, type) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape));
  const commonBounds = Utils.getCommonBounds(boundsForShapes);
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const { before, after } = TLDR.mutateShapes(app.state, idsToMutate, (shape) => {
    const bounds = TLDR.getBounds(shape);
    switch (type) {
      case "horizontal": {
        const newBounds = __spreadProps4(__spreadValues4({}, bounds), {
          minX: commonBounds.minX,
          maxX: commonBounds.maxX,
          width: commonBounds.width
        });
        return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: newBounds.width / bounds.width,
          scaleY: 1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
      case "vertical": {
        const newBounds = __spreadProps4(__spreadValues4({}, bounds), {
          minY: commonBounds.minY,
          maxY: commonBounds.maxY,
          height: commonBounds.height
        });
        return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: 1,
          scaleY: newBounds.height / bounds.height,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
    }
  }, currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === "group") {
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "stretch",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function styleShapes(app, ids, changes) {
  const { currentPageId, selectedIds } = app;
  const shapeIdsToMutate = ids.flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId)).filter((id) => !app.getShape(id).isLocked);
  const beforeShapes = {};
  const afterShapes = {};
  shapeIdsToMutate.map((id) => app.getShape(id)).filter((shape) => !shape.isLocked).forEach((shape) => {
    beforeShapes[shape.id] = {
      style: __spreadValues4({}, Object.fromEntries(Object.keys(changes).map((key) => [key, shape.style[key]])))
    };
    afterShapes[shape.id] = {
      style: changes
    };
    if (shape.type === "text") {
      beforeShapes[shape.id].point = shape.point;
      afterShapes[shape.id].point = Vec.toFixed(Vec.add(shape.point, Vec.sub(app.getShapeUtil(shape).getCenter(shape), app.getShapeUtil(shape).getCenter(__spreadProps4(__spreadValues4({}, shape), {
        style: __spreadValues4(__spreadValues4({}, shape.style), changes)
      })))));
    }
  });
  return {
    id: "style",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      },
      appState: {
        currentStyle: __spreadValues4({}, app.appState.currentStyle)
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      },
      appState: {
        currentStyle: changes
      }
    }
  };
}
function toggleShapesDecoration(app, ids, decorationId) {
  const { currentPageId, selectedIds } = app;
  const beforeShapes = Object.fromEntries(ids.map((id) => {
    var _a2;
    return [
      id,
      {
        decorations: {
          [decorationId]: (_a2 = app.getShape(id).decorations) == null ? void 0 : _a2[decorationId]
        }
      }
    ];
  }));
  const afterShapes = Object.fromEntries(ids.filter((id) => !app.getShape(id).isLocked).map((id) => {
    var _a2;
    return [
      id,
      {
        decorations: {
          [decorationId]: ((_a2 = app.getShape(id).decorations) == null ? void 0 : _a2[decorationId]) ? void 0 : "arrow"
        }
      }
    ];
  }));
  return {
    id: "toggle_decorations",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: beforeShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: afterShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function toggleShapeProp(app, ids, prop) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => prop === "isLocked" ? true : !shape.isLocked);
  const isAllToggled = initialShapes.every((shape) => shape[prop]);
  const before = {};
  const after = {};
  initialShapes.forEach((shape) => {
    before[shape.id] = { [prop]: shape[prop] };
    after[shape.id] = { [prop]: !isAllToggled };
  });
  return {
    id: "toggle",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function translateShapes(app, ids, delta) {
  const { currentPageId, selectedIds } = app;
  app.rotationInfo.selectedIds = [...selectedIds];
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const change = TLDR.mutateShapes(app.state, idsToMutate, (shape) => ({
    point: Vec.toFixed(Vec.add(shape.point, delta))
  }), currentPageId);
  before.shapes = change.before;
  after.shapes = change.after;
  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter((binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId));
  bindingsToDelete.forEach((binding) => {
    before.bindings[binding.id] = binding;
    after.bindings[binding.id] = void 0;
    for (const id of [binding.toId, binding.fromId]) {
      const shape = app.getShape(id);
      if (!shape.handles)
        continue;
      Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
        var _a2, _b;
        before.shapes[id] = __spreadProps4(__spreadValues4({}, before.shapes[id]), {
          handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[id]) == null ? void 0 : _a2.handles), {
            [handle.id]: { bindingId: binding.id }
          })
        });
        after.shapes[id] = __spreadProps4(__spreadValues4({}, after.shapes[id]), {
          handles: __spreadProps4(__spreadValues4({}, (_b = after.shapes[id]) == null ? void 0 : _b.handles), { [handle.id]: { bindingId: void 0 } })
        });
      });
    }
  });
  return {
    id: "translate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function ungroupShapes(app, selectedIds, groupShapes2, pageId) {
  const { bindings } = app;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const beforeSelectedIds = selectedIds;
  const afterSelectedIds = selectedIds.filter((id) => !groupShapes2.find((shape) => shape.id === id));
  groupShapes2.filter((shape) => !shape.isLocked).forEach((groupShape) => {
    const shapesToReparent = [];
    const deletedGroupIds = [];
    beforeShapes[groupShape.id] = groupShape;
    afterShapes[groupShape.id] = void 0;
    groupShape.children.forEach((id) => {
      afterSelectedIds.push(id);
      const shape = app.getShape(id, pageId);
      shapesToReparent.push(shape);
    });
    const startingChildIndex = groupShape.childIndex;
    const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId);
    const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length;
    const sortedShapes = shapesToReparent.sort((a7, b7) => a7.childIndex - b7.childIndex);
    sortedShapes.forEach((shape, index2) => {
      beforeShapes[shape.id] = {
        parentId: shape.parentId,
        childIndex: shape.childIndex
      };
      afterShapes[shape.id] = {
        parentId: pageId,
        childIndex: startingChildIndex + step * index2
      };
    });
    bindings.filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id).forEach((binding) => {
      for (const id of [binding.toId, binding.fromId]) {
        if (afterShapes[id] === void 0) {
          beforeBindings[binding.id] = binding;
          afterBindings[binding.id] = void 0;
          const shape = app.getShape(id, pageId);
          if (shape.handles) {
            Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
              var _a2, _b;
              beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_a2 = beforeShapes[id]) == null ? void 0 : _a2.handles), {
                  [handle.id]: { bindingId: binding.id }
                })
              });
              if (!deletedGroupIds.includes(id)) {
                afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), {
                  handles: __spreadProps4(__spreadValues4({}, (_b = afterShapes[id]) == null ? void 0 : _b.handles), {
                    [handle.id]: { bindingId: void 0 }
                  })
                });
              }
            });
          }
        }
      }
    });
  });
  return {
    id: "ungroup",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: beforeSelectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: afterSelectedIds
          }
        }
      }
    }
  };
}
function updateShapes(app, updates, pageId) {
  const ids = updates.map((update) => update.id);
  const change = TLDR.mutateShapes(app.state, ids.filter((id) => !app.getShape(id, pageId).isLocked), (_shape, i8) => updates[i8], pageId);
  return {
    id: "update",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.before
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.after
          }
        }
      }
    }
  };
}
function setShapesProps(app, ids, partial) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => partial["isLocked"] ? true : !shape.isLocked);
  const before = {};
  const after = {};
  const keys2 = Object.keys(partial);
  initialShapes.forEach((shape) => {
    before[shape.id] = Object.fromEntries(keys2.map((key) => [key, shape[key]]));
    after[shape.id] = partial;
  });
  return {
    id: "set_props",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    }
  };
}
var BaseSession = class {
  constructor(app) {
    this.app = app;
  }
};
var ArrowSession = class extends BaseSession {
  constructor(app, shapeId, handleId, isCreate = false) {
    super(app);
    __publicField3(this, "type", "arrow");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "translatingHandle");
    __publicField3(this, "newStartBindingId", Utils.uniqueId());
    __publicField3(this, "draggedBindingId", Utils.uniqueId());
    __publicField3(this, "didBind", false);
    __publicField3(this, "initialShape");
    __publicField3(this, "handleId");
    __publicField3(this, "bindableShapeIds");
    __publicField3(this, "initialBinding");
    __publicField3(this, "startBindingShapeId");
    __publicField3(this, "isCreate");
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      var _a3, _b2, _c2;
      const { initialShape } = this;
      const {
        currentPoint,
        shiftKey,
        altKey,
        metaKey,
        currentGrid,
        settings: { showGrid }
      } = this.app;
      const shape = this.app.getShape(initialShape.id);
      if (shape.isLocked)
        return;
      const { handles } = initialShape;
      const handleId2 = this.handleId;
      if (!handles[handleId2].canBind)
        return;
      let delta = Vec.sub(currentPoint, Vec.add(handles[handleId2].point, initialShape.point));
      if (shiftKey) {
        const A3 = altKey ? Vec.med(handles.start.point, handles.end.point) : handles[handleId2 === "start" ? "end" : "start"].point;
        const B4 = handles[handleId2].point;
        const C6 = Vec.add(B4, delta);
        const angle = Vec.angle(A3, C6);
        const adjusted = Vec.rotWith(C6, A3, Utils.snapAngleToSegments(angle, 24) - angle);
        delta = Vec.add(delta, Vec.sub(adjusted, C6));
      }
      const nextPoint = Vec.add(handles[handleId2].point, delta);
      const handleChanges = {
        [handleId2]: __spreadProps4(__spreadValues4({}, handles[handleId2]), {
          point: showGrid ? Vec.snap(nextPoint, currentGrid) : Vec.toFixed(nextPoint),
          bindingId: void 0
        })
      };
      if (altKey) {
        const oppositeHandleId = handleId2 === "start" ? "end" : "start";
        const nextPoint2 = Vec.sub(handles[oppositeHandleId].point, delta);
        handleChanges[oppositeHandleId] = __spreadProps4(__spreadValues4({}, handles[oppositeHandleId]), {
          point: showGrid ? Vec.snap(nextPoint2, currentGrid) : Vec.toFixed(nextPoint2),
          bindingId: void 0
        });
      }
      const utils = shapeUtils["arrow"];
      const handleChange = (_a3 = utils.onHandleChange) == null ? void 0 : _a3.call(utils, initialShape, handleChanges);
      if (!handleChange)
        return;
      const next = {
        shape: Utils.deepMerge(shape, handleChange),
        bindings: {}
      };
      let draggedBinding;
      const draggingHandle = next.shape.handles[this.handleId];
      const oppositeHandle = next.shape.handles[this.handleId === "start" ? "end" : "start"];
      if (this.startBindingShapeId) {
        let nextStartBinding;
        const startTarget = this.app.page.shapes[this.startBindingShapeId];
        const startTargetUtils = TLDR.getShapeUtil(startTarget);
        const center = startTargetUtils.getCenter(startTarget);
        const startHandle = next.shape.handles.start;
        const endHandle = next.shape.handles.end;
        const rayPoint = Vec.add(startHandle.point, next.shape.point);
        if (Vec.isEqual(rayPoint, center))
          rayPoint[1]++;
        const rayOrigin = center;
        const isInsideShape = startTargetUtils.hitTestPoint(startTarget, currentPoint);
        const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin));
        const hasStartBinding = this.app.getBinding(this.newStartBindingId) !== void 0;
        if (!metaKey && !startTargetUtils.hitTestPoint(startTarget, Vec.add(next.shape.point, endHandle.point))) {
          nextStartBinding = this.findBindingPoint(shape, startTarget, "start", this.newStartBindingId, center, rayOrigin, rayDirection, isInsideShape);
        }
        if (nextStartBinding && !hasStartBinding) {
          this.didBind = true;
          next.bindings[this.newStartBindingId] = nextStartBinding;
          next.shape = Utils.deepMerge(next.shape, {
            handles: {
              start: {
                bindingId: nextStartBinding.id
              }
            }
          });
        } else if (!nextStartBinding && hasStartBinding) {
          this.didBind = false;
          next.bindings[this.newStartBindingId] = void 0;
          next.shape = Utils.deepMerge(initialShape, {
            handles: {
              start: {
                bindingId: void 0
              }
            }
          });
        }
      }
      if (!metaKey) {
        const rayOrigin = Vec.add(oppositeHandle.point, next.shape.point);
        const rayPoint = Vec.add(draggingHandle.point, next.shape.point);
        const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin));
        const startPoint = Vec.add(next.shape.point, next.shape.handles.start.point);
        const endPoint = Vec.add(next.shape.point, next.shape.handles.end.point);
        const targets = this.bindableShapeIds.map((id) => this.app.page.shapes[id]).sort((a7, b7) => b7.childIndex - a7.childIndex).filter((shape2) => {
          const utils2 = TLDR.getShapeUtil(shape2);
          return ![startPoint, endPoint].every((point) => utils2.hitTestPoint(shape2, point));
        });
        for (const target of targets) {
          draggedBinding = this.findBindingPoint(shape, target, this.handleId, this.draggedBindingId, rayPoint, rayOrigin, rayDirection, altKey);
          if (draggedBinding)
            break;
        }
      }
      if (draggedBinding) {
        this.didBind = true;
        next.bindings[this.draggedBindingId] = draggedBinding;
        next.shape = Utils.deepMerge(next.shape, {
          handles: {
            [this.handleId]: {
              bindingId: this.draggedBindingId
            }
          }
        });
      } else {
        this.didBind = this.didBind || false;
        const currentBindingId = shape.handles[this.handleId].bindingId;
        if (currentBindingId !== void 0) {
          next.bindings[currentBindingId] = void 0;
          next.shape = Utils.deepMerge(next.shape, {
            handles: {
              [this.handleId]: {
                bindingId: void 0
              }
            }
          });
        }
      }
      const change = (_c2 = (_b2 = TLDR.getShapeUtil(next.shape)).onHandleChange) == null ? void 0 : _c2.call(_b2, next.shape, next.shape.handles);
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [shape.id]: __spreadValues4(__spreadValues4({}, next.shape), change != null ? change : {})
              },
              bindings: next.bindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              bindingId: next.shape.handles[handleId2].bindingId
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this;
      const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);
      const isDeleting = this.isCreate || Vec.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4;
      const afterBindings = {};
      afterBindings[draggedBindingId] = void 0;
      if (initialBinding) {
        afterBindings[initialBinding.id] = isDeleting ? void 0 : initialBinding;
      }
      if (newStartBindingId) {
        afterBindings[newStartBindingId] = void 0;
      }
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [initialShape.id]: isDeleting ? void 0 : initialShape
              },
              bindings: afterBindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: isDeleting ? [] : [initialShape.id],
              bindingId: void 0,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId: handleId2 } = this;
      const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);
      const currentBindingId = currentShape.handles[handleId2].bindingId;
      const length3 = Vec.dist(currentShape.handles.start.point, currentShape.handles.end.point);
      if (!(currentBindingId || initialBinding) && length3 < 4)
        return this.cancel();
      const beforeBindings = {};
      const afterBindings = {};
      if (initialBinding) {
        beforeBindings[initialBinding.id] = this.isCreate ? void 0 : initialBinding;
        afterBindings[initialBinding.id] = void 0;
      }
      if (currentBindingId) {
        beforeBindings[currentBindingId] = void 0;
        afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId];
      }
      if (startBindingShapeId) {
        beforeBindings[newStartBindingId] = void 0;
        afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId];
      }
      return {
        id: "arrow",
        before: {
          document: {
            pages: {
              [this.app.currentPageId]: {
                shapes: {
                  [initialShape.id]: this.isCreate ? void 0 : initialShape
                },
                bindings: beforeBindings
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: this.isCreate ? [] : [initialShape.id],
                bindingId: void 0,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [this.app.currentPageId]: {
                shapes: {
                  [initialShape.id]: currentShape
                },
                bindings: afterBindings
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: [initialShape.id],
                bindingId: void 0,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        }
      };
    });
    __publicField3(this, "findBindingPoint", (shape, target, handleId2, bindingId, point, origin, direction, bindAnywhere) => {
      const util = TLDR.getShapeUtil(target.type);
      const bindingPoint = util.getBindingPoint(target, shape, point, origin, direction, bindAnywhere);
      if (!bindingPoint)
        return;
      return {
        id: bindingId,
        type: "arrow",
        fromId: shape.id,
        toId: target.id,
        handleId: handleId2,
        point: Vec.toFixed(bindingPoint.point),
        distance: bindingPoint.distance
      };
    });
    var _a2, _b, _c;
    this.isCreate = isCreate;
    const { currentPageId } = app.state.appState;
    const page = app.state.document.pages[currentPageId];
    this.handleId = handleId;
    this.initialShape = deepCopy(page.shapes[shapeId]);
    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter((id) => !(id === this.initialShape.id || id === this.initialShape.parentId));
    const oppositeHandleBindingId = (_a2 = this.initialShape.handles[handleId === "start" ? "end" : "start"]) == null ? void 0 : _a2.bindingId;
    if (oppositeHandleBindingId) {
      const oppositeToId = (_b = page.bindings[oppositeHandleBindingId]) == null ? void 0 : _b.toId;
      if (oppositeToId) {
        this.bindableShapeIds = this.bindableShapeIds.filter((id) => id !== oppositeToId);
      }
    }
    const { originPoint } = this.app;
    if (this.isCreate) {
      this.startBindingShapeId = (_c = this.bindableShapeIds.map((id) => page.shapes[id]).filter((shape) => Utils.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape))).sort((a7, b7) => {
        return b7.childIndex - a7.childIndex;
      })[0]) == null ? void 0 : _c.id;
      if (this.startBindingShapeId) {
        this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1);
      }
    } else {
      const initialBindingId = this.initialShape.handles[this.handleId].bindingId;
      if (initialBindingId) {
        this.initialBinding = page.bindings[initialBindingId];
      } else {
        this.initialShape.handles[this.handleId].bindingId = void 0;
      }
    }
  }
};
var BrushSession = class extends BaseSession {
  constructor(app) {
    super(app);
    __publicField3(this, "type", "brush");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "brushing");
    __publicField3(this, "initialSelectedIds");
    __publicField3(this, "shapesToTest");
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      const {
        initialSelectedIds,
        shapesToTest,
        app: { metaKey, settings, originPoint, currentPoint }
      } = this;
      const brush = Utils.getBoundsFromPoints([originPoint, currentPoint]);
      const selectByContain = settings.isCadSelectMode ? !metaKey && originPoint[0] < currentPoint[0] : metaKey;
      const hits = /* @__PURE__ */ new Set();
      const selectedIds = new Set(initialSelectedIds);
      shapesToTest.forEach(({ id, selectId }) => {
        const shape = this.app.getShape(id);
        if (!hits.has(selectId)) {
          const util = this.app.getShapeUtil(shape);
          if (selectByContain ? Utils.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {
            hits.add(selectId);
            if (!selectedIds.has(selectId)) {
              selectedIds.add(selectId);
            }
          } else if (selectedIds.has(selectId)) {
            selectedIds.delete(selectId);
          }
        }
      });
      const currentSelectedIds = this.app.selectedIds;
      const didChange = selectedIds.size !== currentSelectedIds.length || currentSelectedIds.some((id) => !selectedIds.has(id));
      const afterSelectedIds = didChange ? Array.from(selectedIds.values()) : currentSelectedIds;
      return {
        appState: {
          selectByContain
        },
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush,
              selectedIds: afterSelectedIds
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      return {
        appState: {
          selectByContain: false
        },
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush: null,
              selectedIds: Array.from(this.initialSelectedIds.values())
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      return {
        appState: {
          selectByContain: false
        },
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush: null,
              selectedIds: [...this.app.selectedIds]
            }
          }
        }
      };
    });
    const { currentPageId } = app;
    this.initialSelectedIds = new Set(this.app.selectedIds);
    this.shapesToTest = this.app.shapes.filter((shape) => !(shape.isLocked || shape.isHidden || shape.parentId !== currentPageId || this.initialSelectedIds.has(shape.id) || this.initialSelectedIds.has(shape.parentId))).map((shape) => ({
      id: shape.id,
      bounds: this.app.getShapeUtil(shape).getBounds(shape),
      selectId: shape.id
    }));
    this.update();
  }
};
var DrawSession = class extends BaseSession {
  constructor(app, id) {
    super(app);
    __publicField3(this, "type", "draw");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "creating");
    __publicField3(this, "topLeft");
    __publicField3(this, "points");
    __publicField3(this, "initialShape");
    __publicField3(this, "lastAdjustedPoint");
    __publicField3(this, "shiftedPoints", []);
    __publicField3(this, "shapeId");
    __publicField3(this, "isLocked");
    __publicField3(this, "isExtending");
    __publicField3(this, "lockedDirection");
    __publicField3(this, "start", () => {
      var _a3;
      const currentPoint2 = this.app.originPoint;
      const newAdjustedPoint = [0, 0, (_a3 = currentPoint2[2]) != null ? _a3 : 0.5];
      this.points.push(newAdjustedPoint);
      const topLeft = [
        Math.min(this.topLeft[0], currentPoint2[0]),
        Math.min(this.topLeft[1], currentPoint2[1])
      ];
      const delta2 = Vec.sub(topLeft, currentPoint2);
      this.topLeft = topLeft;
      this.shiftedPoints = this.points.map((pt) => Vec.toFixed(Vec.sub(pt, delta2)).concat(pt[2]));
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [this.shapeId]: {
                  point: this.topLeft,
                  points: this.shiftedPoints
                }
              }
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: [this.shapeId]
            }
          }
        }
      };
    });
    __publicField3(this, "update", () => {
      const { shapeId } = this;
      const { currentPoint: currentPoint2, originPoint: originPoint2, shiftKey } = this.app;
      if (!this.lockedDirection && this.points.length > 1) {
        const bounds = Utils.getBoundsFromPoints(this.points);
        if (bounds.width > 8 || bounds.height > 8) {
          this.lockedDirection = bounds.width > bounds.height ? "horizontal" : "vertical";
        }
      }
      if (shiftKey) {
        if (!this.isLocked && this.points.length > 2) {
          if (!this.lockedDirection) {
            const bounds = Utils.getBoundsFromPoints(this.points);
            this.lockedDirection = bounds.width > bounds.height ? "horizontal" : "vertical";
          }
          this.isLocked = true;
          const returning = [...this.lastAdjustedPoint];
          if (this.lockedDirection === "vertical") {
            returning[0] = 0;
          } else {
            returning[1] = 0;
          }
          this.points.push(returning.concat(currentPoint2[2]));
        }
      } else if (this.isLocked) {
        this.isLocked = false;
      }
      if (this.isLocked) {
        if (this.lockedDirection === "vertical") {
          currentPoint2[0] = originPoint2[0];
        } else {
          currentPoint2[1] = originPoint2[1];
        }
      }
      const change = this.addPoint(currentPoint2);
      if (!change)
        return;
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [shapeId]: change
              }
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: [shapeId]
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const { shapeId } = this;
      const pageId = this.app.currentPageId;
      return {
        document: {
          pages: {
            [pageId]: {
              shapes: {
                [shapeId]: this.isExtending ? this.initialShape : void 0
              }
            }
          },
          pageStates: {
            [pageId]: {
              selectedIds: []
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const { shapeId } = this;
      const pageId = this.app.currentPageId;
      const shape = this.app.getShape(shapeId);
      return {
        id: "create_draw",
        before: {
          document: {
            pages: {
              [pageId]: {
                shapes: {
                  [shapeId]: this.isExtending ? this.initialShape : void 0
                }
              }
            },
            pageStates: {
              [pageId]: {
                selectedIds: []
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [pageId]: {
                shapes: {
                  [shapeId]: __spreadProps4(__spreadValues4({}, shape), {
                    point: Vec.toFixed(shape.point),
                    points: shape.points.map((pt) => Vec.toFixed(pt)),
                    isComplete: true
                  })
                }
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: []
              }
            }
          }
        }
      };
    });
    __publicField3(this, "addPoint", (currentPoint2) => {
      const { originPoint: originPoint2 } = this.app;
      const newAdjustedPoint = Vec.toFixed(Vec.sub(currentPoint2, originPoint2)).concat(currentPoint2[2]);
      if (Vec.isEqual(this.lastAdjustedPoint, newAdjustedPoint))
        return;
      this.points.push(newAdjustedPoint);
      this.lastAdjustedPoint = newAdjustedPoint;
      const prevTopLeft = [...this.topLeft];
      const topLeft = [
        Math.min(this.topLeft[0], currentPoint2[0]),
        Math.min(this.topLeft[1], currentPoint2[1])
      ];
      const delta2 = Vec.sub(topLeft, originPoint2);
      let points;
      if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {
        this.topLeft = topLeft;
        points = this.points.map((pt) => Vec.toFixed(Vec.sub(pt, delta2)).concat(pt[2]));
      } else {
        points = [...this.shiftedPoints, Vec.sub(newAdjustedPoint, delta2).concat(newAdjustedPoint[2])];
      }
      this.shiftedPoints = points;
      return {
        point: this.topLeft,
        points
      };
    });
    var _a2;
    const { originPoint } = this.app;
    this.shapeId = id;
    this.initialShape = this.app.getShape(id);
    this.topLeft = [...this.initialShape.point];
    const currentPoint = [0, 0, (_a2 = originPoint[2]) != null ? _a2 : 0.5];
    const delta = Vec.sub(originPoint, this.topLeft);
    const initialPoints = this.initialShape.points.map((pt) => Vec.sub(pt, delta).concat(pt[2]));
    this.isExtending = initialPoints.length > 0;
    const newPoints = [];
    if (this.isExtending) {
      const prevPoint = initialPoints[initialPoints.length - 1];
      newPoints.push(prevPoint, prevPoint);
      const len = Math.ceil(Vec.dist(prevPoint, currentPoint) / 16);
      for (let i8 = 0; i8 < len; i8++) {
        const t12 = i8 / (len - 1);
        newPoints.push(Vec.lrp(prevPoint, currentPoint, t12).concat(prevPoint[2]));
      }
    } else {
      newPoints.push(currentPoint);
    }
    this.points = [...initialPoints, ...newPoints];
    this.shiftedPoints = this.points.map((pt) => Vec.add(pt, delta).concat(pt[2]));
    this.lastAdjustedPoint = this.points[this.points.length - 1];
  }
};
var HandleSession = class extends BaseSession {
  constructor(app, shapeId, handleId, commandId = "move_handle") {
    super(app);
    __publicField3(this, "type", "handle");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "translatingHandle");
    __publicField3(this, "commandId");
    __publicField3(this, "topLeft");
    __publicField3(this, "shiftKey", false);
    __publicField3(this, "initialShape");
    __publicField3(this, "handleId");
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      var _a2, _b;
      const {
        initialShape,
        app: { currentPageId, currentPoint }
      } = this;
      const shape = this.app.getShape(initialShape.id);
      if (shape.isLocked)
        return void 0;
      const handles = shape.handles;
      const handleId2 = this.handleId;
      const delta = Vec.sub(currentPoint, handles[handleId2].point);
      const handleChanges = {
        [handleId2]: __spreadProps4(__spreadValues4({}, handles[handleId2]), {
          point: Vec.sub(Vec.add(handles[handleId2].point, delta), shape.point)
        })
      };
      const change = (_b = (_a2 = TLDR.getShapeUtil(shape)).onHandleChange) == null ? void 0 : _b.call(_a2, shape, handleChanges);
      if (!change)
        return;
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [shape.id]: change
              }
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [initialShape.id]: initialShape
              }
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      return {
        id: this.commandId,
        before: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: {
                  [initialShape.id]: initialShape
                }
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: {
                  [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id))
                }
              }
            }
          }
        }
      };
    });
    const { originPoint } = app;
    this.topLeft = [...originPoint];
    this.handleId = handleId;
    this.initialShape = this.app.getShape(shapeId);
    this.commandId = commandId;
  }
};
var RotateSession = class extends BaseSession {
  constructor(app) {
    super(app);
    __publicField3(this, "type", "rotate");
    __publicField3(this, "status", "transforming");
    __publicField3(this, "performanceMode");
    __publicField3(this, "delta", [0, 0]);
    __publicField3(this, "commonBoundsCenter");
    __publicField3(this, "initialAngle");
    __publicField3(this, "initialShapes");
    __publicField3(this, "changes", {});
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      const {
        commonBoundsCenter,
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2, currentPoint, shiftKey }
      } = this;
      const shapes = {};
      let directionDelta = Vec.angle(commonBoundsCenter, currentPoint) - this.initialAngle;
      if (shiftKey) {
        directionDelta = Utils.snapAngleToSegments(directionDelta, 24);
      }
      initialShapes2.forEach(({ center, shape }) => {
        const { rotation = 0 } = shape;
        let shapeDelta = 0;
        if (shiftKey) {
          const snappedRotation = Utils.snapAngleToSegments(rotation, 24);
          shapeDelta = snappedRotation - rotation;
        }
        const change = TLDR.getRotatedShapeMutation(shape, center, commonBoundsCenter, shiftKey ? directionDelta + shapeDelta : directionDelta);
        if (change) {
          shapes[shape.id] = change;
        }
      });
      this.changes = shapes;
      return {
        document: {
          pages: {
            [currentPageId2]: {
              shapes
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const {
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2 }
      } = this;
      const shapes = {};
      initialShapes2.forEach(({ shape }) => shapes[shape.id] = shape);
      return {
        document: {
          pages: {
            [currentPageId2]: {
              shapes
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const {
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2 }
      } = this;
      const beforeShapes = {};
      const afterShapes = this.changes;
      initialShapes2.forEach(({ shape: { id, point, rotation, handles } }) => {
        beforeShapes[id] = { point, rotation, handles };
      });
      return {
        id: "rotate",
        before: {
          document: {
            pages: {
              [currentPageId2]: {
                shapes: beforeShapes
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId2]: {
                shapes: afterShapes
              }
            }
          }
        }
      };
    });
    const {
      app: { currentPageId, pageState, originPoint }
    } = this;
    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter((shape) => !shape.isLocked);
    if (initialShapes.length === 0) {
      throw Error("No selected shapes!");
    }
    if (app.rotationInfo.selectedIds === pageState.selectedIds) {
      if (app.rotationInfo.center === void 0) {
        throw Error("We should have a center for rotation!");
      }
      this.commonBoundsCenter = app.rotationInfo.center;
    } else {
      this.commonBoundsCenter = Utils.getBoundsCenter(Utils.getCommonBounds(initialShapes.map(TLDR.getBounds)));
      app.rotationInfo.selectedIds = pageState.selectedIds;
      app.rotationInfo.center = this.commonBoundsCenter;
    }
    this.initialShapes = initialShapes.filter((shape) => shape.children === void 0).map((shape) => {
      return {
        shape,
        center: this.app.getShapeUtil(shape).getCenter(shape)
      };
    });
    this.initialAngle = Vec.angle(this.commonBoundsCenter, originPoint);
  }
};
var TransformSession = class extends BaseSession {
  constructor(app, transformType = TLBoundsCorner.BottomRight, isCreate = false) {
    super(app);
    this.transformType = transformType;
    this.isCreate = isCreate;
    __publicField3(this, "type", "transform");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "transforming");
    __publicField3(this, "scaleX", 1);
    __publicField3(this, "scaleY", 1);
    __publicField3(this, "initialShapes");
    __publicField3(this, "initialShapeIds");
    __publicField3(this, "initialSelectedIds");
    __publicField3(this, "shapeBounds");
    __publicField3(this, "hasUnlockedShapes");
    __publicField3(this, "isAllAspectRatioLocked");
    __publicField3(this, "initialCommonBounds");
    __publicField3(this, "snapInfo", { state: "empty" });
    __publicField3(this, "prevPoint", [0, 0]);
    __publicField3(this, "speed", 1);
    __publicField3(this, "start", () => {
      this.snapInfo = {
        state: "ready",
        bounds: this.app.shapes.filter((shape) => !this.initialShapeIds.includes(shape.id)).map((shape) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))
      };
      return void 0;
    });
    __publicField3(this, "update", () => {
      const {
        transformType: transformType2,
        shapeBounds,
        initialCommonBounds,
        isAllAspectRatioLocked,
        app: {
          currentPageId,
          pageState: { camera },
          viewport,
          currentPoint,
          previousPoint,
          originPoint,
          shiftKey,
          altKey,
          metaKey,
          currentGrid,
          settings: { isSnapping, showGrid }
        }
      } = this;
      const shapes = {};
      const delta = altKey ? Vec.mul(Vec.sub(currentPoint, originPoint), 2) : Vec.sub(currentPoint, originPoint);
      let newBounds = Utils.getTransformedBoundingBox(initialCommonBounds, transformType2, delta, 0, shiftKey || isAllAspectRatioLocked);
      if (altKey) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialCommonBounds)));
      }
      if (showGrid) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.snapBoundsToGrid(newBounds, currentGrid));
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const speedChange = speed - this.speed;
      this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
      let snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(newBounds), this.snapInfo.bounds.filter((bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          snapLines = snapResult.snapLines;
          newBounds = Utils.getTransformedBoundingBox(initialCommonBounds, transformType2, Vec.sub(delta, snapResult.offset), 0, shiftKey || isAllAspectRatioLocked);
        }
      }
      this.scaleX = newBounds.scaleX;
      this.scaleY = newBounds.scaleY;
      shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {
        let newShapeBounds = Utils.getRelativeTransformedBoundingBox(newBounds, initialCommonBounds, initialShapeBounds, this.scaleX < 0, this.scaleY < 0);
        if (showGrid) {
          newShapeBounds = Utils.snapBoundsToGrid(newShapeBounds, currentGrid);
        }
        const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {
          type: this.transformType,
          initialShape,
          scaleX: this.scaleX,
          scaleY: this.scaleY,
          transformOrigin
        });
        shapes[initialShape.id] = afterShape;
      });
      return {
        appState: {
          snapLines
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const {
        shapeBounds,
        app: { currentPageId }
      } = this;
      const shapes = {};
      if (this.isCreate) {
        shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = void 0);
      } else {
        shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = shape.initialShape);
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id)
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const {
        isCreate: isCreate2,
        shapeBounds,
        hasUnlockedShapes,
        app: { currentPageId }
      } = this;
      if (!hasUnlockedShapes)
        return;
      if (this.isCreate && Vec.dist(this.app.originPoint, this.app.currentPoint) < 2) {
        return this.cancel();
      }
      const beforeShapes = {};
      const afterShapes = {};
      let beforeSelectedIds;
      let afterSelectedIds;
      if (isCreate2) {
        beforeSelectedIds = [];
        afterSelectedIds = [];
        shapeBounds.forEach(({ initialShape }) => {
          beforeShapes[initialShape.id] = void 0;
          afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
        });
      } else {
        beforeSelectedIds = this.initialSelectedIds;
        afterSelectedIds = this.initialSelectedIds;
        shapeBounds.forEach(({ initialShape }) => {
          beforeShapes[initialShape.id] = initialShape;
          afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
        });
      }
      return {
        id: "transform",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: beforeSelectedIds,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: afterSelectedIds,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        }
      };
    });
    this.initialSelectedIds = [...this.app.selectedIds];
    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds];
    this.initialShapes = TLDR.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((shape) => !shape.isLocked);
    this.initialShapeIds = this.initialShapes.map((shape) => shape.id);
    this.hasUnlockedShapes = this.initialShapes.length > 0;
    this.isAllAspectRatioLocked = this.initialShapes.every((shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked);
    const shapesBounds = Object.fromEntries(this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)]));
    const boundsArr = Object.values(shapesBounds);
    this.initialCommonBounds = Utils.getCommonBounds(boundsArr);
    const initialInnerBounds = Utils.getBoundsFromPoints(boundsArr.map(Utils.getBoundsCenter));
    this.shapeBounds = this.initialShapes.map((shape) => {
      const initialShapeBounds = shapesBounds[shape.id];
      const ic = Utils.getBoundsCenter(initialShapeBounds);
      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;
      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;
      return {
        initialShape: shape,
        initialShapeBounds,
        transformOrigin: [ix, iy]
      };
    });
  }
};
var TransformSingleSession = class extends BaseSession {
  constructor(app, id, transformType, isCreate = false) {
    super(app);
    __publicField3(this, "type", "transformSingle");
    __publicField3(this, "status", "transforming");
    __publicField3(this, "performanceMode");
    __publicField3(this, "transformType");
    __publicField3(this, "scaleX", 1);
    __publicField3(this, "scaleY", 1);
    __publicField3(this, "isCreate");
    __publicField3(this, "initialShape");
    __publicField3(this, "initialShapeBounds");
    __publicField3(this, "initialCommonBounds");
    __publicField3(this, "snapInfo", { state: "empty" });
    __publicField3(this, "prevPoint", [0, 0]);
    __publicField3(this, "speed", 1);
    __publicField3(this, "start", () => {
      this.snapInfo = {
        state: "ready",
        bounds: this.app.shapes.filter((shape2) => shape2.id !== this.initialShape.id).map((shape2) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape2)))
      };
      return void 0;
    });
    __publicField3(this, "update", () => {
      const {
        transformType: transformType2,
        initialShape,
        initialShapeBounds,
        app: {
          settings: { isSnapping, showGrid },
          currentPageId,
          pageState: { camera },
          viewport,
          currentPoint,
          previousPoint,
          originPoint,
          currentGrid,
          shiftKey,
          altKey,
          metaKey
        }
      } = this;
      if (initialShape.isLocked)
        return void 0;
      const shapes = {};
      const delta = altKey ? Vec.mul(Vec.sub(currentPoint, originPoint), 2) : Vec.sub(currentPoint, originPoint);
      const shape2 = this.app.getShape(initialShape.id);
      const utils = TLDR.getShapeUtil(shape2);
      let newBounds = Utils.getTransformedBoundingBox(initialShapeBounds, transformType2, delta, shape2.rotation, shiftKey || shape2.isAspectRatioLocked || utils.isAspectRatioLocked);
      if (altKey) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialShapeBounds)));
      }
      if (showGrid) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.snapBoundsToGrid(newBounds, currentGrid));
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const speedChange = speed - this.speed;
      this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
      let snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && !initialShape.rotation && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(newBounds), this.snapInfo.bounds.filter((bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          snapLines = snapResult.snapLines;
          newBounds = Utils.getTransformedBoundingBox(initialShapeBounds, transformType2, Vec.sub(delta, snapResult.offset), shape2.rotation, shiftKey || shape2.isAspectRatioLocked || utils.isAspectRatioLocked);
        }
      }
      const afterShape = TLDR.getShapeUtil(shape2).transformSingle(shape2, newBounds, {
        initialShape,
        type: this.transformType,
        scaleX: newBounds.scaleX,
        scaleY: newBounds.scaleY,
        transformOrigin: [0.5, 0.5]
      });
      if (afterShape) {
        shapes[shape2.id] = afterShape;
      }
      if (showGrid && afterShape && afterShape.point) {
        afterShape.point = Vec.snap(afterShape.point, currentGrid);
      }
      return {
        appState: {
          snapLines
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      const shapes = {};
      if (this.isCreate) {
        shapes[initialShape.id] = void 0;
      } else {
        shapes[initialShape.id] = initialShape;
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : [initialShape.id]
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      if (initialShape.isLocked)
        return;
      if (this.isCreate && Vec.dist(this.app.originPoint, this.app.currentPoint) < 2) {
        return this.cancel();
      }
      const beforeShapes = {};
      const afterShapes = {};
      beforeShapes[initialShape.id] = this.isCreate ? void 0 : initialShape;
      afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id));
      return {
        id: "transform_single",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: this.isCreate ? [] : [initialShape.id],
                editingId: void 0,
                hoveredId: void 0
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: [initialShape.id],
                editingId: void 0,
                hoveredId: void 0
              }
            }
          }
        }
      };
    });
    this.isCreate = isCreate;
    this.transformType = transformType;
    const shape = this.app.getShape(id);
    this.initialShape = shape;
    this.initialShapeBounds = TLDR.getBounds(shape);
    this.initialCommonBounds = TLDR.getRotatedBounds(shape);
    this.app.rotationInfo.selectedIds = [shape.id];
  }
};
var TranslateSession = class extends BaseSession {
  constructor(app, isCreate = false, link = false) {
    super(app);
    __publicField3(this, "performanceMode");
    __publicField3(this, "type", "translate");
    __publicField3(this, "status", "translating");
    __publicField3(this, "delta", [0, 0]);
    __publicField3(this, "prev", [0, 0]);
    __publicField3(this, "prevPoint", [0, 0]);
    __publicField3(this, "speed", 1);
    __publicField3(this, "cloneInfo", {
      state: "empty"
    });
    __publicField3(this, "snapInfo", {
      state: "empty"
    });
    __publicField3(this, "snapLines", []);
    __publicField3(this, "isCloning", false);
    __publicField3(this, "isCreate");
    __publicField3(this, "link");
    __publicField3(this, "initialIds");
    __publicField3(this, "hasUnlockedShapes");
    __publicField3(this, "initialSelectedIds");
    __publicField3(this, "initialCommonBounds");
    __publicField3(this, "initialShapes");
    __publicField3(this, "initialParentChildren");
    __publicField3(this, "bindingsToDelete");
    __publicField3(this, "start", () => {
      const {
        bindingsToDelete,
        initialIds,
        app: { currentPageId: currentPageId2, page: page2 }
      } = this;
      const allBounds = [];
      const otherBounds = [];
      Object.values(page2.shapes).forEach((shape) => {
        const bounds = Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape));
        allBounds.push(bounds);
        if (!initialIds.has(shape.id)) {
          otherBounds.push(bounds);
        }
      });
      this.snapInfo = {
        state: "ready",
        bounds: allBounds,
        others: otherBounds
      };
      if (bindingsToDelete.length === 0)
        return;
      const nextBindings = {};
      bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);
      return {
        document: {
          pages: {
            [currentPageId2]: {
              bindings: nextBindings
            }
          }
        }
      };
    });
    __publicField3(this, "update", () => {
      const {
        initialParentChildren,
        initialShapes,
        initialCommonBounds,
        bindingsToDelete,
        app: {
          pageState: { camera },
          settings: { isSnapping, showGrid },
          currentPageId: currentPageId2,
          viewport,
          selectedIds: selectedIds2,
          currentPoint,
          previousPoint,
          originPoint,
          altKey,
          shiftKey,
          metaKey,
          currentGrid
        }
      } = this;
      const nextBindings = {};
      const nextShapes = {};
      const nextPageState = {};
      let delta = Vec.sub(currentPoint, originPoint);
      let didChangeCloning = false;
      if (!this.isCreate) {
        if (altKey && !this.isCloning) {
          this.isCloning = true;
          didChangeCloning = true;
        } else if (!altKey && this.isCloning) {
          this.isCloning = false;
          didChangeCloning = true;
        }
      }
      if (shiftKey) {
        if (Math.abs(delta[0]) < Math.abs(delta[1])) {
          delta[0] = 0;
        } else {
          delta[1] = 0;
        }
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const change = speed - this.speed;
      this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15);
      this.snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(showGrid ? Utils.snapBoundsToGrid(Utils.translateBounds(initialCommonBounds, delta), currentGrid) : Utils.translateBounds(initialCommonBounds, delta)), (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => {
          return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds);
        }), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          this.snapLines = snapResult.snapLines;
          delta = Vec.sub(delta, snapResult.offset);
        }
      }
      this.prev = delta;
      if (this.isCloning) {
        if (didChangeCloning) {
          if (this.cloneInfo.state === "empty") {
            this.createCloneInfo();
          }
          if (this.cloneInfo.state === "empty") {
            throw Error;
          }
          const { clones, clonedBindings } = this.cloneInfo;
          this.isCloning = true;
          bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);
          initialShapes.forEach((shape) => nextShapes[shape.id] = { point: shape.point });
          clones.forEach((clone) => {
            var _a2;
            nextShapes[clone.id] = __spreadValues4({}, clone);
            if (clone.parentId !== currentPageId2 && !selectedIds2.includes(clone.parentId)) {
              const children = ((_a2 = nextShapes[clone.parentId]) == null ? void 0 : _a2.children) || initialParentChildren[clone.parentId];
              if (!children.includes(clone.id)) {
                nextShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, nextShapes[clone.parentId]), {
                  children: [...children, clone.id]
                });
              }
            }
          });
          for (const binding of clonedBindings) {
            nextBindings[binding.id] = binding;
          }
          nextPageState.selectedIds = clones.map((clone) => clone.id);
          clones.forEach((clone) => {
            nextShapes[clone.id] = __spreadProps4(__spreadValues4({}, clone), {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid) : Vec.toFixed(Vec.add(clone.point, delta))
            });
          });
        } else {
          if (this.cloneInfo.state === "empty")
            throw Error;
          const { clones } = this.cloneInfo;
          clones.forEach((clone) => {
            nextShapes[clone.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid) : Vec.toFixed(Vec.add(clone.point, delta))
            };
          });
        }
      } else {
        if (didChangeCloning) {
          if (this.cloneInfo.state === "empty")
            throw Error;
          const { clones, clonedBindings } = this.cloneInfo;
          this.isCloning = false;
          bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);
          clones.forEach((clone) => {
            if (clone.parentId !== currentPageId2) {
              nextShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, nextShapes[clone.parentId]), {
                children: initialParentChildren[clone.parentId]
              });
            }
          });
          clones.forEach((clone) => nextShapes[clone.id] = void 0);
          initialShapes.forEach((shape) => {
            nextShapes[shape.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid) : Vec.toFixed(Vec.add(shape.point, delta))
            };
          });
          for (const binding of clonedBindings) {
            nextBindings[binding.id] = void 0;
          }
          nextPageState.selectedIds = initialShapes.map((shape) => shape.id);
        } else {
          initialShapes.forEach((shape) => {
            nextShapes[shape.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid) : Vec.toFixed(Vec.add(shape.point, delta))
            };
          });
        }
      }
      return {
        appState: {
          snapLines: this.snapLines
        },
        document: {
          pages: {
            [currentPageId2]: {
              shapes: nextShapes,
              bindings: nextBindings
            }
          },
          pageStates: {
            [currentPageId2]: nextPageState
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const {
        initialShapes,
        initialSelectedIds,
        bindingsToDelete,
        app: { currentPageId: currentPageId2 }
      } = this;
      const nextBindings = {};
      const nextShapes = {};
      const nextPageState = {
        editingId: void 0,
        hoveredId: void 0
      };
      bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);
      if (this.isCreate) {
        initialShapes.forEach(({ id }) => nextShapes[id] = void 0);
        nextPageState.selectedIds = [];
      } else {
        initialShapes.forEach(({ id, point }) => nextShapes[id] = __spreadProps4(__spreadValues4({}, nextShapes[id]), { point }));
        nextPageState.selectedIds = initialSelectedIds;
      }
      if (this.cloneInfo.state === "ready") {
        const { clones, clonedBindings } = this.cloneInfo;
        clones.forEach((clone) => nextShapes[clone.id] = void 0);
        clonedBindings.forEach((binding) => nextBindings[binding.id] = void 0);
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId2]: {
              shapes: nextShapes,
              bindings: nextBindings
            }
          },
          pageStates: {
            [currentPageId2]: nextPageState
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const {
        initialShapes,
        initialParentChildren,
        bindingsToDelete,
        app: { currentPageId: currentPageId2 }
      } = this;
      const beforeBindings = {};
      const beforeShapes = {};
      const afterBindings = {};
      const afterShapes = {};
      if (this.isCloning) {
        if (this.cloneInfo.state === "empty") {
          this.createCloneInfo();
        }
        if (this.cloneInfo.state !== "ready")
          throw Error;
        const { clones, clonedBindings } = this.cloneInfo;
        clones.forEach((clone) => {
          beforeShapes[clone.id] = void 0;
          afterShapes[clone.id] = this.app.getShape(clone.id);
          if (clone.parentId !== currentPageId2) {
            beforeShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, beforeShapes[clone.parentId]), {
              children: initialParentChildren[clone.parentId]
            });
            afterShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, afterShapes[clone.parentId]), {
              children: this.app.getShape(clone.parentId).children
            });
          }
        });
        clonedBindings.forEach((binding) => {
          beforeBindings[binding.id] = void 0;
          afterBindings[binding.id] = this.app.getBinding(binding.id);
        });
      } else {
        initialShapes.forEach((shape) => {
          beforeShapes[shape.id] = this.isCreate ? void 0 : __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
            point: shape.point
          });
          afterShapes[shape.id] = __spreadValues4(__spreadValues4({}, afterShapes[shape.id]), this.isCreate ? this.app.getShape(shape.id) : { point: this.app.getShape(shape.id).point });
        });
      }
      bindingsToDelete.forEach((binding) => {
        beforeBindings[binding.id] = binding;
        for (const id of [binding.toId, binding.fromId]) {
          const shape = this.app.getShape(id);
          if (!shape.handles)
            continue;
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), { handles: {} });
            afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), { handles: {} });
            beforeShapes[id].handles[handle.id] = {
              bindingId: binding.id
            };
            afterShapes[id].handles[handle.id] = {
              bindingId: void 0
            };
          });
        }
      });
      return {
        id: "translate",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId2]: {
                shapes: beforeShapes,
                bindings: beforeBindings
              }
            },
            pageStates: {
              [currentPageId2]: {
                selectedIds: this.isCreate ? [] : [...this.initialSelectedIds]
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId2]: {
                shapes: afterShapes,
                bindings: afterBindings
              }
            },
            pageStates: {
              [currentPageId2]: {
                selectedIds: [...this.app.selectedIds]
              }
            }
          }
        }
      };
    });
    __publicField3(this, "createCloneInfo", () => {
      const {
        initialShapes,
        initialParentChildren,
        app: { selectedIds: selectedIds2, currentPageId: currentPageId2, page: page2 }
      } = this;
      const cloneMap = {};
      const clonedBindingsMap = {};
      const clonedBindings = [];
      const clones = [];
      initialShapes.forEach((shape) => {
        const newId = Utils.uniqueId();
        initialParentChildren[newId] = initialParentChildren[shape.id];
        cloneMap[shape.id] = newId;
        const clone = __spreadProps4(__spreadValues4({}, Utils.deepClone(shape)), {
          id: newId,
          parentId: shape.parentId,
          childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId2)
        });
        if (clone.type === "video") {
          const element2 = document.getElementById(shape.id + "_video");
          if (element2)
            clone.currentTime = (element2.currentTime + 16) % element2.duration;
        }
        clones.push(clone);
      });
      clones.forEach((clone) => {
        if (clone.children !== void 0) {
          clone.children = clone.children.map((childId) => cloneMap[childId]);
        }
      });
      clones.forEach((clone) => {
        if (selectedIds2.includes(clone.parentId)) {
          clone.parentId = cloneMap[clone.parentId];
        }
      });
      const clonedShapeIds = new Set(Object.keys(cloneMap));
      Object.values(page2.bindings).filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId)).forEach((binding) => {
        if (clonedShapeIds.has(binding.fromId)) {
          if (clonedShapeIds.has(binding.toId)) {
            const cloneId = Utils.uniqueId();
            const cloneBinding = __spreadProps4(__spreadValues4({}, Utils.deepClone(binding)), {
              id: cloneId,
              fromId: cloneMap[binding.fromId] || binding.fromId,
              toId: cloneMap[binding.toId] || binding.toId
            });
            clonedBindingsMap[binding.id] = cloneId;
            clonedBindings.push(cloneBinding);
          }
        }
      });
      clones.forEach((clone) => {
        if (clone.handles) {
          if (clone.handles) {
            for (const id in clone.handles) {
              const handle = clone.handles[id];
              handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : void 0;
            }
          }
        }
      });
      clones.forEach((clone) => {
        if (page2.shapes[clone.id]) {
          throw Error("uh oh, we didn't clone correctly");
        }
      });
      this.cloneInfo = {
        state: "ready",
        clones,
        cloneMap,
        clonedBindings
      };
    });
    this.isCreate = isCreate;
    this.link = link;
    const { currentPageId, selectedIds, page } = this.app;
    this.initialSelectedIds = [...selectedIds];
    const selectedShapes = (link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds).map((id) => this.app.getShape(id)).filter((shape) => !shape.isLocked);
    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id));
    this.hasUnlockedShapes = selectedShapes.length > 0;
    this.initialShapes = Array.from(new Set(selectedShapes.filter((shape) => !selectedShapeIds.has(shape.parentId)).flatMap((shape) => {
      return shape.children ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))] : [shape];
    })).values());
    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id));
    this.bindingsToDelete = [];
    Object.values(page.bindings).filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId)).forEach((binding) => {
      if (this.initialIds.has(binding.fromId)) {
        if (!this.initialIds.has(binding.toId)) {
          this.bindingsToDelete.push(binding);
        }
      }
    });
    this.initialParentChildren = {};
    this.initialShapes.map((s9) => s9.parentId).filter((id) => id !== page.id).forEach((id) => {
      this.initialParentChildren[id] = this.app.getShape(id).children;
    });
    this.initialCommonBounds = Utils.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds));
    this.app.rotationInfo.selectedIds = [...this.app.selectedIds];
  }
};
var EraseSession = class extends BaseSession {
  constructor(app) {
    super(app);
    __publicField3(this, "type", "draw");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "creating");
    __publicField3(this, "isLocked");
    __publicField3(this, "lockedDirection");
    __publicField3(this, "erasedShapes", /* @__PURE__ */ new Set());
    __publicField3(this, "erasedBindings", /* @__PURE__ */ new Set());
    __publicField3(this, "initialSelectedShapes");
    __publicField3(this, "erasableShapes");
    __publicField3(this, "prevPoint");
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      const { page, shiftKey, originPoint, currentPoint } = this.app;
      if (shiftKey) {
        if (!this.isLocked && Vec.dist(originPoint, currentPoint) > 4) {
          if (!this.lockedDirection) {
            const delta = Vec.sub(currentPoint, originPoint);
            this.lockedDirection = delta[0] > delta[1] ? "horizontal" : "vertical";
          }
          this.isLocked = true;
        }
      } else if (this.isLocked) {
        this.isLocked = false;
      }
      if (this.isLocked) {
        if (this.lockedDirection === "vertical") {
          currentPoint[0] = originPoint[0];
        } else {
          currentPoint[1] = originPoint[1];
        }
      }
      const newPoint = Vec.toFixed(Vec.add(originPoint, Vec.sub(currentPoint, originPoint)));
      const deletedShapeIds = /* @__PURE__ */ new Set([]);
      this.erasableShapes.forEach((shape) => {
        if (this.erasedShapes.has(shape))
          return;
        if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {
          this.erasedShapes.add(shape);
          deletedShapeIds.add(shape.id);
          if (shape.children !== void 0) {
            for (const childId of shape.children) {
              this.erasedShapes.add(this.app.getShape(childId));
              deletedShapeIds.add(childId);
            }
          }
        }
      });
      Object.values(page.bindings).forEach((binding) => {
        for (const id of [binding.toId, binding.fromId]) {
          if (deletedShapeIds.has(id)) {
            this.erasedBindings.add(binding);
          }
        }
      });
      this.erasedShapes.forEach((shape) => {
        if (!this.app.getShape(shape.id)) {
          this.erasedShapes.delete(shape);
          this.erasableShapes.delete(shape);
          deletedShapeIds.delete(shape.id);
        }
      });
      const erasedShapes = Array.from(this.erasedShapes.values());
      this.prevPoint = newPoint;
      return {
        document: {
          pages: {
            [page.id]: {
              shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }]))
            }
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const { page } = this.app;
      this.erasedShapes.forEach((shape) => {
        if (!this.app.getShape(shape.id)) {
          this.erasedShapes.delete(shape);
          this.erasableShapes.delete(shape);
        }
      });
      const erasedShapes = Array.from(this.erasedShapes.values());
      return {
        document: {
          pages: {
            [page.id]: {
              shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }]))
            }
          },
          pageStates: {
            [page.id]: {
              selectedIds: this.initialSelectedShapes.map((shape) => shape.id)
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const { page } = this.app;
      this.erasedShapes.forEach((shape) => {
        if (!this.app.getShape(shape.id)) {
          this.erasedShapes.delete(shape);
          this.erasableShapes.delete(shape);
        }
      });
      this.erasedBindings.forEach((binding) => {
        if (!this.app.getBinding(binding.id)) {
          this.erasedBindings.delete(binding);
        }
      });
      const erasedShapes = Array.from(this.erasedShapes.values());
      const erasedBindings = Array.from(this.erasedBindings.values());
      const erasedShapeIds = erasedShapes.map((shape) => shape.id);
      const erasedBindingIds = erasedBindings.map((binding) => binding.id);
      const before = {
        shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),
        bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding]))
      };
      const after = {
        shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, void 0])),
        bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, void 0]))
      };
      this.app.shapes.forEach((shape) => {
        if (shape.handles && !after.shapes[shape.id]) {
          Object.values(shape.handles).forEach((handle) => {
            var _a2, _b;
            if (handle.bindingId && erasedBindingIds.includes(handle.bindingId)) {
              before.shapes[shape.id] = __spreadProps4(__spreadValues4({}, before.shapes[shape.id]), {
                handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[shape.id]) == null ? void 0 : _a2.handles), {
                  [handle.id]: handle
                })
              });
              if (!erasedShapeIds.includes(shape.id)) {
                after.shapes[shape.id] = __spreadProps4(__spreadValues4({}, after.shapes[shape.id]), {
                  handles: __spreadProps4(__spreadValues4({}, (_b = after.shapes[shape.id]) == null ? void 0 : _b.handles), {
                    [handle.id]: __spreadProps4(__spreadValues4({}, handle), {
                      bindingId: void 0
                    })
                  })
                });
              }
            }
          });
        }
      });
      return {
        id: "erase",
        before: {
          document: {
            pages: {
              [page.id]: before
            },
            pageStates: {
              [page.id]: {
                selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).map((shape) => shape.id)
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [page.id]: after
            },
            pageStates: {
              [page.id]: {
                selectedIds: this.initialSelectedShapes.filter((shape) => !!this.app.getShape(shape.id)).filter((shape) => !erasedShapeIds.includes(shape.id)).map((shape) => shape.id)
              }
            }
          }
        }
      };
    });
    this.prevPoint = [...app.originPoint];
    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id));
    this.erasableShapes = new Set(this.app.shapes.filter((shape) => !shape.isLocked));
  }
};
var GridSession = class extends BaseSession {
  constructor(app, id) {
    super(app);
    __publicField3(this, "type", "grid");
    __publicField3(this, "performanceMode");
    __publicField3(this, "status", "translating");
    __publicField3(this, "shape");
    __publicField3(this, "bounds");
    __publicField3(this, "initialSelectedIds");
    __publicField3(this, "initialSiblings");
    __publicField3(this, "grid", {});
    __publicField3(this, "columns", 1);
    __publicField3(this, "rows", 1);
    __publicField3(this, "isCopying", false);
    __publicField3(this, "start", () => void 0);
    __publicField3(this, "update", () => {
      const { currentPageId, altKey, shiftKey, currentPoint } = this.app;
      const nextShapes = {};
      const nextPageState = {};
      const center = Utils.getBoundsCenter(this.bounds);
      const offset = Vec.sub(currentPoint, center);
      if (shiftKey) {
        if (Math.abs(offset[0]) < Math.abs(offset[1])) {
          offset[0] = 0;
        } else {
          offset[1] = 0;
        }
      }
      const gapX = this.bounds.width + 32;
      const gapY = this.bounds.height + 32;
      const columns = Math.ceil(offset[0] / gapX);
      const rows = Math.ceil(offset[1] / gapY);
      const minX = Math.min(columns, 0);
      const minY = Math.min(rows, 0);
      const maxX = Math.max(columns, 1);
      const maxY = Math.max(rows, 1);
      const inGrid = /* @__PURE__ */ new Set();
      const isCopying = altKey;
      if (isCopying !== this.isCopying) {
        Object.values(this.grid).filter((id2) => id2 !== this.shape.id).forEach((id2) => nextShapes[id2] = void 0);
        this.grid = { "0_0": this.shape.id };
        this.isCopying = isCopying;
      }
      for (let x6 = minX; x6 < maxX; x6++) {
        for (let y5 = minY; y5 < maxY; y5++) {
          const position = `${x6}_${y5}`;
          inGrid.add(position);
          if (this.grid[position])
            continue;
          if (x6 === 0 && y5 === 0)
            continue;
          const clone = this.getClone(Vec.add(this.shape.point, [x6 * gapX, y5 * gapY]), isCopying);
          nextShapes[clone.id] = clone;
          this.grid[position] = clone.id;
        }
      }
      Object.entries(this.grid).forEach(([position, id2]) => {
        if (!inGrid.has(position)) {
          nextShapes[id2] = void 0;
          delete this.grid[position];
        }
      });
      if (Object.values(nextShapes).length === 0)
        return;
      if (this.initialSiblings) {
        nextShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, ...Object.values(this.grid)]
        };
      }
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: nextShapes
            }
          },
          pageStates: {
            [currentPageId]: nextPageState
          }
        }
      };
    });
    __publicField3(this, "cancel", () => {
      const { currentPageId } = this.app;
      const nextShapes = {};
      Object.values(this.grid).forEach((id2) => {
        nextShapes[id2] = void 0;
      });
      nextShapes[this.shape.id] = __spreadProps4(__spreadValues4({}, nextShapes[this.shape.id]), { point: this.shape.point });
      if (this.initialSiblings) {
        nextShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, this.shape.id]
        };
      }
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: nextShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: [this.shape.id]
            }
          }
        }
      };
    });
    __publicField3(this, "complete", () => {
      const { currentPageId } = this.app;
      const beforeShapes = {};
      const afterShapes = {};
      const afterSelectedIds = [];
      Object.values(this.grid).forEach((id2) => {
        beforeShapes[id2] = void 0;
        afterShapes[id2] = this.app.getShape(id2);
        afterSelectedIds.push(id2);
      });
      beforeShapes[this.shape.id] = this.shape;
      if (this.initialSiblings) {
        beforeShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, this.shape.id]
        };
        afterShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, ...Object.values(this.grid)]
        };
      }
      if (afterSelectedIds.length === 1)
        return;
      return {
        id: "grid",
        before: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: [],
                hoveredId: void 0
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: afterSelectedIds,
                hoveredId: void 0
              }
            }
          }
        }
      };
    });
    __publicField3(this, "getClone", (point, copy2) => {
      const clone = __spreadProps4(__spreadValues4({}, this.shape), {
        id: Utils.uniqueId(),
        point
      });
      if (!copy2) {
        if (clone.type === "sticky") {
          clone.text = "";
        }
      }
      return clone;
    });
    var _a2;
    this.shape = this.app.getShape(id);
    this.grid["0_0"] = this.shape.id;
    this.bounds = this.app.getShapeBounds(id);
    this.initialSelectedIds = [...this.app.selectedIds];
    if (this.shape.parentId !== this.app.currentPageId) {
      this.initialSiblings = (_a2 = this.app.getShape(this.shape.parentId).children) == null ? void 0 : _a2.filter((id2) => id2 !== this.shape.id);
    }
  }
};
var sessions = {
  ["arrow"]: ArrowSession,
  ["brush"]: BrushSession,
  ["draw"]: DrawSession,
  ["erase"]: EraseSession,
  ["handle"]: HandleSession,
  ["rotate"]: RotateSession,
  ["transform"]: TransformSession,
  ["transformSingle"]: TransformSingleSession,
  ["translate"]: TranslateSession,
  ["grid"]: GridSession
};
var getSession = (type) => {
  return sessions[type];
};
var BaseTool = class extends TDEventHandler {
  constructor(app) {
    super();
    this.app = app;
    __publicField3(this, "type", "select");
    __publicField3(this, "previous");
    __publicField3(this, "status", "idle");
    __publicField3(this, "setStatus", (status) => {
      this.status = status;
      this.app.setStatus(this.status);
    });
    __publicField3(this, "onEnter", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "onExit", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "onCancel", () => {
      if (this.status === "idle") {
        this.app.selectTool("select");
      } else {
        this.setStatus("idle");
      }
      this.app.cancelSession();
    });
    __publicField3(this, "getNextChildIndex", () => {
      const {
        shapes,
        appState: { currentPageId }
      } = this.app;
      return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b7) => b7.childIndex - a7.childIndex)[0].childIndex + 1;
    });
    __publicField3(this, "onPinchStart", () => {
      this.app.cancelSession();
      this.setStatus("pinching");
    });
    __publicField3(this, "onPinchEnd", () => {
      if (Utils.isMobileSafari()) {
        this.app.undoSelect();
      }
      this.setStatus("idle");
    });
    __publicField3(this, "onPinch", (info, e11) => {
      var _a2;
      if (this.status !== "pinching")
        return;
      if (isNaN(info.delta[0]) || isNaN(info.delta[1]))
        return;
      this.app.pinchZoom(info.point, info.delta, info.delta[2]);
      (_a2 = this.onPointerMove) == null ? void 0 : _a2.call(this, info, e11);
    });
    __publicField3(this, "onKeyDown", (key) => {
      if (key === "Escape") {
        this.onCancel();
        return;
      }
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    __publicField3(this, "onKeyUp", (key) => {
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    __publicField3(this, "onPointerMove", () => {
      if (this.status === "creating") {
        this.app.updateSession();
      }
    });
    __publicField3(this, "onPointerUp", () => {
      if (this.status === "creating") {
        this.app.completeSession();
        const { isToolLocked } = this.app.appState;
        if (!isToolLocked) {
          this.app.selectTool("select");
        }
      }
      this.setStatus("idle");
    });
  }
};
var SelectTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "select");
    __publicField3(this, "pointedId");
    __publicField3(this, "selectedGroupId");
    __publicField3(this, "pointedHandleId");
    __publicField3(this, "pointedBoundsHandle");
    __publicField3(this, "pointedLinkHandleId");
    __publicField3(this, "onEnter", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "onExit", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "clonePaint", (point) => {
      if (this.app.selectedIds.length === 0)
        return;
      const shapes = this.app.selectedIds.map((id) => this.app.getShape(id));
      const bounds = Utils.expandBounds(Utils.getCommonBounds(shapes.map(TLDR.getBounds)), 16);
      const center = Utils.getBoundsCenter(bounds);
      const size = [bounds.width, bounds.height];
      const gridPoint = [
        center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),
        center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1])
      ];
      const centeredBounds = Utils.centerBounds(bounds, gridPoint);
      const hit = this.app.shapes.some((shape) => TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds));
      if (!hit) {
        this.app.duplicate(this.app.selectedIds, gridPoint);
      }
    });
    __publicField3(this, "getShapeClone", (id, side) => {
      const shape = this.app.getShape(id);
      const utils = TLDR.getShapeUtil(shape);
      if (utils.canClone) {
        const bounds = utils.getBounds(shape);
        const center = utils.getCenter(shape);
        let point = {
          top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],
          right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],
          bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],
          left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],
          topLeft: [
            bounds.minX - (bounds.width + CLONING_DISTANCE),
            bounds.minY - (bounds.height + CLONING_DISTANCE)
          ],
          topRight: [
            bounds.maxX + CLONING_DISTANCE,
            bounds.minY - (bounds.height + CLONING_DISTANCE)
          ],
          bottomLeft: [
            bounds.minX - (bounds.width + CLONING_DISTANCE),
            bounds.maxY + CLONING_DISTANCE
          ],
          bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE]
        }[side];
        if (shape.rotation !== 0) {
          const newCenter = src_default.add(point, [bounds.width / 2, bounds.height / 2]);
          const rotatedCenter = src_default.rotWith(newCenter, center, shape.rotation || 0);
          point = src_default.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2]);
        }
        const id2 = Utils.uniqueId();
        const clone = __spreadProps4(__spreadValues4({}, shape), {
          id: id2,
          point
        });
        if (clone.type === "sticky") {
          clone.text = "";
        }
        return clone;
      }
      return;
    });
    __publicField3(this, "onCancel", () => {
      if (this.app.pageState.editingId) {
        this.app.setEditingId();
      } else {
        this.selectNone();
      }
      this.app.cancelSession();
      this.setStatus("idle");
    });
    __publicField3(this, "onKeyDown", (key, info, e11) => {
      switch (key) {
        case "Escape": {
          this.onCancel();
          break;
        }
        case "Tab": {
          if (!this.app.pageState.editingId && this.status === "idle" && this.app.selectedIds.length === 1) {
            const [selectedId] = this.app.selectedIds;
            const clonedShape = this.getShapeClone(selectedId, "right");
            if (clonedShape) {
              this.app.createShapes(clonedShape);
              this.setStatus("idle");
              if (clonedShape.type === "sticky") {
                this.app.select(clonedShape.id);
                this.app.setEditingId(clonedShape.id);
              }
            }
          }
          break;
        }
        case "Meta":
        case "Control":
        case "Alt": {
          this.app.updateSession();
          break;
        }
        case "Enter": {
          const { pageState } = this.app;
          if (pageState.selectedIds.length === 1 && !pageState.editingId) {
            this.app.setEditingId(pageState.selectedIds[0]);
            e11.preventDefault();
          }
        }
      }
    });
    __publicField3(this, "onKeyUp", (key, info) => {
      if (this.status === "clonePainting" && !(info.altKey && info.shiftKey)) {
        this.setStatus("idle");
        return;
      }
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    __publicField3(this, "onPointerMove", (info, e11) => {
      const { originPoint, currentPoint } = this.app;
      switch (this.status) {
        case "pointingBoundsHandle": {
          if (!this.pointedBoundsHandle)
            throw Error("No pointed bounds handle");
          if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
            if (this.pointedBoundsHandle === "rotate") {
              this.setStatus("rotating");
              this.app.startSession("rotate");
            } else if (this.pointedBoundsHandle === "center" || this.pointedBoundsHandle === "left" || this.pointedBoundsHandle === "right") {
              this.setStatus("translating");
              this.app.startSession("translate", false, this.pointedBoundsHandle);
            } else {
              this.setStatus("transforming");
              const idsToTransform = this.app.selectedIds.flatMap((id) => TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId));
              if (idsToTransform.length === 1) {
                this.app.startSession("transformSingle", idsToTransform[0], this.pointedBoundsHandle);
              } else {
                this.app.startSession("transform", this.pointedBoundsHandle);
              }
            }
            this.app.updateSession();
          }
          break;
        }
        case "pointingCanvas": {
          if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
            this.app.startSession("brush");
            this.setStatus("brushing");
          }
          break;
        }
        case "pointingClone": {
          if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
            this.setStatus("translatingClone");
            this.app.startSession("translate");
            this.app.updateSession();
          }
          break;
        }
        case "pointingBounds": {
          if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
            this.setStatus("translating");
            this.app.startSession("translate");
            this.app.updateSession();
          }
          break;
        }
        case "pointingHandle": {
          if (!this.pointedHandleId)
            throw Error("No pointed handle");
          if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
            this.setStatus("translatingHandle");
            const selectedShape = this.app.getShape(this.app.selectedIds[0]);
            if (selectedShape) {
              if (this.pointedHandleId === "bend") {
                this.app.startSession("handle", selectedShape.id, this.pointedHandleId);
                this.app.updateSession();
              } else {
                this.app.startSession("arrow", selectedShape.id, this.pointedHandleId, false);
                this.app.updateSession();
              }
            }
          }
          break;
        }
        case "clonePainting": {
          this.clonePaint(currentPoint);
          break;
        }
        default: {
          if (this.app.session) {
            this.app.updateSession();
            break;
          }
        }
      }
    });
    __publicField3(this, "onPointerDown", (info, e11) => {
      if (info.target === "canvas" && this.status === "idle") {
        const { currentPoint } = this.app;
        if (info.spaceKey && e11.buttons === 1)
          return;
        if (this.status === "idle" && info.altKey && info.shiftKey) {
          this.setStatus("clonePainting");
          this.clonePaint(currentPoint);
          return;
        }
        if (!info.shiftKey) {
          this.app.onShapeBlur();
          if (info.altKey && this.app.selectedIds.length > 0) {
            this.app.duplicate(this.app.selectedIds, currentPoint);
            return;
          }
          this.selectNone();
        }
        this.setStatus("pointingCanvas");
      }
    });
    __publicField3(this, "onPointerUp", (info) => {
      if (this.status === "translatingClone" || this.status === "pointingClone") {
        if (this.pointedId) {
          this.app.completeSession();
          this.app.setEditingId(this.pointedId);
        }
        this.setStatus("idle");
        this.pointedId = void 0;
        return;
      }
      if (this.status === "pointingBounds") {
        if (info.target === "bounds") {
          this.selectNone();
        } else if (this.app.isSelected(info.target)) {
          if (info.shiftKey) {
            if (this.pointedId !== info.target) {
              this.deselect(info.target);
            }
          } else {
            if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {
              this.select(info.target);
            }
          }
        } else if (this.pointedId === info.target) {
          if (this.app.getShape(info.target).isLocked)
            return;
          if (info.shiftKey) {
            this.pushSelect(info.target);
          } else {
            this.select(info.target);
          }
        }
      }
      this.app.completeSession();
      this.setStatus("idle");
      this.pointedBoundsHandle = void 0;
      this.pointedHandleId = void 0;
      this.pointedId = void 0;
    });
    __publicField3(this, "onDoubleClickCanvas", () => {
    });
    __publicField3(this, "onPointShape", (info, e11) => {
      if (info.spaceKey && e11.buttons === 1)
        return;
      if (this.app.getShape(info.target).isLocked)
        return;
      const { editingId, hoveredId } = this.app.pageState;
      if (editingId && info.target !== editingId) {
        this.app.onShapeBlur();
      }
      if ((this.status === "idle" || this.status === "pointingBounds") && info.metaKey && info.shiftKey && hoveredId) {
        this.pointedId = hoveredId;
        if (this.app.isSelected(hoveredId)) {
          this.deselect(hoveredId);
        } else {
          this.pushSelect(hoveredId);
          this.setStatus("pointingBounds");
        }
        return;
      }
      if (this.status === "pointingBounds") {
        const { parentId } = this.app.getShape(info.target);
        this.pointedId = parentId === this.app.currentPageId ? info.target : parentId;
        return;
      }
      if (this.status === "idle") {
        this.setStatus("pointingBounds");
        if (info.metaKey) {
          if (!info.shiftKey) {
            this.selectNone();
          }
          this.app.startSession("brush");
          this.setStatus("brushing");
          return;
        }
        let shapeIdToSelect;
        const { parentId } = this.app.getShape(info.target);
        if (parentId === this.app.currentPageId) {
          shapeIdToSelect = info.target;
          this.selectedGroupId = void 0;
        } else {
          if (parentId === this.selectedGroupId) {
            shapeIdToSelect = info.target;
          } else {
            shapeIdToSelect = parentId;
            this.selectedGroupId = void 0;
          }
        }
        if (!this.app.isSelected(shapeIdToSelect)) {
          this.pointedId = shapeIdToSelect;
          if (info.shiftKey) {
            this.pushSelect(shapeIdToSelect);
          } else {
            this.select(shapeIdToSelect);
          }
        }
      }
    });
    __publicField3(this, "onDoubleClickShape", (info) => {
      const shape = this.app.getShape(info.target);
      if (shape.isLocked) {
        this.app.select(info.target);
        return;
      }
      if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {
        this.app.setEditingId(info.target);
      }
      if (shape.parentId !== this.app.currentPageId) {
        this.selectedGroupId = shape.parentId;
      }
      this.app.select(info.target);
    });
    __publicField3(this, "onRightPointShape", (info) => {
      if (!this.app.isSelected(info.target)) {
        this.app.select(info.target);
      }
    });
    __publicField3(this, "onHoverShape", (info) => {
      this.app.setHoveredId(info.target);
    });
    __publicField3(this, "onUnhoverShape", (info) => {
      const { currentPageId: oldCurrentPageId } = this.app;
      requestAnimationFrame(() => {
        if (oldCurrentPageId === this.app.currentPageId && this.app.pageState.hoveredId === info.target) {
          this.app.setHoveredId(void 0);
        }
      });
    });
    __publicField3(this, "onPointBounds", (info) => {
      if (info.metaKey) {
        if (!info.shiftKey) {
          this.selectNone();
        }
        this.app.startSession("brush");
        this.setStatus("brushing");
        return;
      }
      this.setStatus("pointingBounds");
    });
    __publicField3(this, "onRightPointBounds", (info, e11) => {
      e11.stopPropagation();
    });
    __publicField3(this, "onReleaseBounds", () => {
      if (this.status === "translating" || this.status === "brushing") {
        this.app.completeSession();
      }
      this.setStatus("idle");
    });
    __publicField3(this, "onPointBoundsHandle", (info) => {
      this.pointedBoundsHandle = info.target;
      this.setStatus("pointingBoundsHandle");
    });
    __publicField3(this, "onDoubleClickBoundsHandle", (info) => {
      switch (info.target) {
        case "center":
        case "left":
        case "right": {
          this.app.select(...TLDR.getLinkedShapeIds(this.app.state, this.app.currentPageId, info.target, info.shiftKey));
          break;
        }
        default: {
          if (this.app.selectedIds.length === 1) {
            this.app.resetBounds(this.app.selectedIds);
            const shape = this.app.getShape(this.app.selectedIds[0]);
            if ("label" in shape) {
              this.app.setEditingId(shape.id);
            }
          }
        }
      }
    });
    __publicField3(this, "onReleaseBoundsHandle", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "onPointHandle", (info) => {
      this.pointedHandleId = info.target;
      this.setStatus("pointingHandle");
    });
    __publicField3(this, "onDoubleClickHandle", (info) => {
      if (info.target === "bend") {
        const { selectedIds } = this.app;
        if (selectedIds.length !== 1)
          return;
        const shape = this.app.getShape(selectedIds[0]);
        if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {
          this.app.setEditingId(shape.id);
        }
        return;
      }
      this.app.toggleDecoration(info.target);
    });
    __publicField3(this, "onReleaseHandle", () => {
      this.setStatus("idle");
    });
    __publicField3(this, "onShapeClone", (info) => {
      const selectedShapeId = this.app.selectedIds[0];
      const clonedShape = this.getShapeClone(selectedShapeId, info.target);
      if (info.target === "left" || info.target === "right" || info.target === "top" || info.target === "bottom") {
        if (clonedShape) {
          this.app.createShapes(clonedShape);
          this.pointedId = clonedShape.id;
          this.setStatus("pointingClone");
        }
      } else {
        this.setStatus("gridCloning");
        this.app.startSession("grid", selectedShapeId);
      }
    });
  }
  deselect(id) {
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id));
  }
  select(id) {
    this.app.select(id);
  }
  pushSelect(id) {
    const shape = this.app.getShape(id);
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id);
  }
  selectNone() {
    this.app.selectNone();
  }
};
var EraseTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "erase");
    __publicField3(this, "status", "idle");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      this.setStatus("pointing");
    });
    __publicField3(this, "onPointerMove", (info) => {
      switch (this.status) {
        case "pointing": {
          if (src_default.dist(info.origin, info.point) > DEAD_ZONE) {
            this.app.startSession("erase");
            this.app.updateSession();
            this.setStatus("erasing");
          }
          break;
        }
        case "erasing": {
          this.app.updateSession();
        }
      }
    });
    __publicField3(this, "onPointerUp", () => {
      switch (this.status) {
        case "pointing": {
          const shapeIdsAtPoint = this.app.shapes.filter((shape) => !shape.isLocked).filter((shape) => this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)).flatMap((shape) => shape.children ? [shape.id, ...shape.children] : shape.id);
          this.app.delete(shapeIdsAtPoint);
          break;
        }
        case "erasing": {
          this.app.completeSession();
        }
      }
      this.setStatus("idle");
    });
    __publicField3(this, "onCancel", () => {
      if (this.status === "idle") {
        if (this.previous) {
          this.app.selectTool(this.previous);
        } else {
          this.app.selectTool("select");
        }
      } else {
        this.setStatus("idle");
      }
      this.app.cancelSession();
    });
  }
};
var TextTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "text");
    __publicField3(this, "stopEditingShape", () => {
      this.setStatus("idle");
      if (!this.app.appState.isToolLocked) {
        this.app.selectTool("select");
      }
    });
    __publicField3(this, "onKeyUp", () => {
    });
    __publicField3(this, "onKeyDown", () => {
    });
    __publicField3(this, "onPointerDown", () => {
      if (this.status === "creating") {
        this.stopEditingShape();
        return;
      }
      if (this.status === "idle") {
        const {
          currentPoint,
          currentGrid,
          settings: { showGrid }
        } = this.app;
        this.app.createTextShapeAtPoint(showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint);
        this.setStatus("creating");
        return;
      }
    });
    __publicField3(this, "onPointerUp", () => {
    });
    __publicField3(this, "onPointShape", (info) => {
      const shape = this.app.getShape(info.target);
      if (shape.type === "text") {
        this.setStatus("idle");
        this.app.setEditingId(shape.id);
      }
    });
    __publicField3(this, "onShapeBlur", () => {
      this.stopEditingShape();
    });
  }
};
var DrawTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "draw");
    __publicField3(this, "lastShapeId");
    __publicField3(this, "onEnter", () => {
      this.lastShapeId = void 0;
    });
    __publicField3(this, "onCancel", () => {
      switch (this.status) {
        case "idle": {
          this.app.selectTool("select");
          break;
        }
        default: {
          this.setStatus("idle");
          break;
        }
      }
      this.app.cancelSession();
    });
    __publicField3(this, "onPointerDown", (info) => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        appState: { currentPageId, currentStyle }
      } = this.app;
      const previous = this.lastShapeId && this.app.getShape(this.lastShapeId);
      if (info.shiftKey && previous) {
        this.app.startSession("draw", previous.id);
        this.setStatus("extending");
      } else {
        const childIndex = this.getNextChildIndex();
        const id = Utils.uniqueId();
        const newShape = Draw.create({
          id,
          parentId: currentPageId,
          childIndex,
          point: currentPoint,
          style: __spreadValues4({}, currentStyle)
        });
        this.lastShapeId = id;
        this.app.patchCreate([newShape]);
        this.app.startSession("draw", id);
        this.setStatus("creating");
      }
    });
    __publicField3(this, "onPointerMove", () => {
      switch (this.status) {
        case "extending":
        case "creating": {
          this.app.updateSession();
        }
      }
    });
    __publicField3(this, "onPointerUp", () => {
      this.app.completeSession();
      this.setStatus("idle");
    });
  }
};
var EllipseTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "ellipse");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Ellipse.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession("transformSingle", newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus("creating");
    });
  }
};
var RectangleTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "rectangle");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Rectangle.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession("transformSingle", newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus("creating");
    });
  }
};
var TriangleTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "triangle");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Triangle.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession("transformSingle", newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus("creating");
    });
  }
};
var LineTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "line");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Arrow6.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        decorations: {
          start: void 0,
          end: void 0
        },
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession("arrow", newShape.id, "end", true);
      this.setStatus("creating");
    });
  }
};
var ArrowTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "arrow");
    __publicField3(this, "onPointerDown", () => {
      if (this.status !== "idle")
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Arrow6.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession("arrow", newShape.id, "end", true);
      this.setStatus("creating");
    });
  }
};
var StickyTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    __publicField3(this, "type", "sticky");
    __publicField3(this, "shapeId");
    __publicField3(this, "onPointerDown", () => {
      if (this.status === "creating") {
        this.setStatus("idle");
        if (!this.app.appState.isToolLocked) {
          this.app.selectTool("select");
        }
        return;
      }
      if (this.status === "idle") {
        const {
          currentPoint,
          currentGrid,
          settings: { showGrid },
          appState: { currentPageId, currentStyle }
        } = this.app;
        const childIndex = this.getNextChildIndex();
        const id = Utils.uniqueId();
        this.shapeId = id;
        const newShape = Sticky.create({
          id,
          parentId: currentPageId,
          childIndex,
          point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
          style: __spreadValues4({}, currentStyle)
        });
        const bounds = Sticky.getBounds(newShape);
        newShape.point = src_default.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
        this.app.createShapes(newShape);
        this.app.startSession("translate");
        this.setStatus("creating");
      }
    });
    __publicField3(this, "onPointerUp", () => {
      if (this.status === "creating") {
        this.setStatus("idle");
        this.app.completeSession();
        this.app.selectTool("select");
        this.app.setEditingId(this.shapeId);
      }
    });
  }
};
var StateManager = class {
  constructor(initialState, id, version, update) {
    __publicField3(this, "_idbId");
    __publicField3(this, "initialState");
    __publicField3(this, "store");
    __publicField3(this, "pointer", -1);
    __publicField3(this, "_state");
    __publicField3(this, "_status", "loading");
    __publicField3(this, "stack", []);
    __publicField3(this, "_snapshot");
    __publicField3(this, "useStore");
    __publicField3(this, "ready");
    __publicField3(this, "isPaused", false);
    __publicField3(this, "persist", (id2) => {
      if (this._status !== "ready")
        return;
      if (this.onPersist) {
        this.onPersist(this._state, id2);
      }
      if (this._idbId) {
        return set4(this._idbId, this._state).catch((e11) => console.error(e11));
      }
    });
    __publicField3(this, "applyPatch", (patch, id2) => {
      const prev = this._state;
      const next = Utils.deepMerge(this._state, patch);
      const final = this.cleanup(next, prev, patch, id2);
      if (this.onStateWillChange) {
        this.onStateWillChange(final, id2);
      }
      this._state = final;
      this.store.setState(this._state, true);
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, id2);
      }
      return this;
    });
    __publicField3(this, "migrate", (next) => {
      return next;
    });
    __publicField3(this, "cleanup", (nextState, prevState, patch, id2) => nextState);
    __publicField3(this, "onStateWillChange");
    __publicField3(this, "onStateDidChange");
    __publicField3(this, "patchState", (patch, id2) => {
      this.applyPatch(patch, id2);
      if (this.onPatch) {
        this.onPatch(this._state, id2);
      }
      return this;
    });
    __publicField3(this, "replaceState", (state, id2) => {
      const final = this.cleanup(state, this._state, state, id2);
      if (this.onStateWillChange) {
        this.onStateWillChange(final, "replace");
      }
      this._state = final;
      this.store.setState(this._state, true);
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, "replace");
      }
      return this;
    });
    __publicField3(this, "setState", (command, id2 = command.id) => {
      if (this.pointer < this.stack.length - 1) {
        this.stack = this.stack.slice(0, this.pointer + 1);
      }
      this.stack.push(__spreadProps4(__spreadValues4({}, command), { id: id2 }));
      this.pointer = this.stack.length - 1;
      this.applyPatch(command.after, id2);
      if (this.onCommand)
        this.onCommand(this._state, id2);
      this.persist(id2);
      return this;
    });
    __publicField3(this, "onReady");
    __publicField3(this, "onPatch");
    __publicField3(this, "onCommand");
    __publicField3(this, "onPersist");
    __publicField3(this, "onReplace");
    __publicField3(this, "onReset");
    __publicField3(this, "onResetHistory");
    __publicField3(this, "onUndo");
    __publicField3(this, "onRedo");
    __publicField3(this, "reset", () => {
      if (this.onStateWillChange) {
        this.onStateWillChange(this.initialState, "reset");
      }
      this._state = this.initialState;
      this.store.setState(this._state, true);
      this.resetHistory();
      this.persist("reset");
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, "reset");
      }
      if (this.onReset) {
        this.onReset(this._state);
      }
      return this;
    });
    __publicField3(this, "replaceHistory", (history, pointer = history.length - 1) => {
      this.stack = history;
      this.pointer = pointer;
      if (this.onReplace) {
        this.onReplace(this._state);
      }
      return this;
    });
    __publicField3(this, "resetHistory", () => {
      this.stack = [];
      this.pointer = -1;
      if (this.onResetHistory) {
        this.onResetHistory(this._state);
      }
      return this;
    });
    __publicField3(this, "undo", () => {
      if (!this.isPaused) {
        if (!this.canUndo)
          return this;
        const command = this.stack[this.pointer];
        this.pointer--;
        this.applyPatch(command.before, `undo`);
        this.persist("undo");
      }
      if (this.onUndo)
        this.onUndo(this._state);
      return this;
    });
    __publicField3(this, "redo", () => {
      if (!this.isPaused) {
        if (!this.canRedo)
          return this;
        this.pointer++;
        const command = this.stack[this.pointer];
        this.applyPatch(command.after, "redo");
        this.persist("undo");
      }
      if (this.onRedo)
        this.onRedo(this._state);
      return this;
    });
    __publicField3(this, "setSnapshot", () => {
      this._snapshot = __spreadValues4({}, this._state);
      return this;
    });
    __publicField3(this, "forceUpdate", () => {
      this.store.setState(this._state, true);
    });
    this._idbId = id;
    this._state = deepCopy(initialState);
    this._snapshot = deepCopy(initialState);
    this.initialState = deepCopy(initialState);
    this.store = createStore2(() => this._state);
    this.useStore = create(this.store);
    this.ready = new Promise((resolve) => {
      let message = "none";
      if (this._idbId) {
        message = "restored";
        get3(this._idbId).then((saved) => __async2(this, null, function* () {
          if (saved) {
            let next = saved;
            if (version) {
              const savedVersion = yield get3(id + "_version");
              if (savedVersion && savedVersion < version) {
                next = update ? update(saved, initialState, savedVersion) : initialState;
                message = "migrated";
              }
            }
            yield set4(id + "_version", version || -1);
            const prevEmpty = this._state.appState.isEmptyCanvas;
            next = this.migrate(next);
            this._state = deepCopy(next);
            this._snapshot = deepCopy(next);
            this._state.appState.isEmptyCanvas = prevEmpty;
            this.store.setState(this._state, true);
          } else {
            yield set4(id + "_version", version || -1);
          }
          this._status = "ready";
          resolve(message);
        })).catch((e11) => console.error(e11));
      } else {
        this._status = "ready";
        resolve(message);
      }
    }).then((message) => {
      if (this.onReady)
        this.onReady(message);
      return message;
    });
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  get canUndo() {
    return this.pointer > -1;
  }
  get canRedo() {
    return this.pointer < this.stack.length - 1;
  }
  get state() {
    return this._state;
  }
  get status() {
    return this._status;
  }
  get snapshot() {
    return this._snapshot;
  }
};
var uuid = Utils.uniqueId();
var _TldrawApp = class extends StateManager {
  constructor(id, callbacks = {}) {
    super(_TldrawApp.defaultState, id, _TldrawApp.version, (prev, next, prevVersion) => {
      return __spreadProps4(__spreadValues4({}, next), {
        document: migrate(__spreadProps4(__spreadValues4(__spreadValues4({}, next.document), prev.document), { version: prevVersion }), _TldrawApp.version)
      });
    });
    __publicField3(this, "callbacks", {});
    __publicField3(this, "tools", {
      select: new SelectTool(this),
      erase: new EraseTool(this),
      ["text"]: new TextTool(this),
      ["draw"]: new DrawTool(this),
      ["ellipse"]: new EllipseTool(this),
      ["rectangle"]: new RectangleTool(this),
      ["triangle"]: new TriangleTool(this),
      ["line"]: new LineTool(this),
      ["arrow"]: new ArrowTool(this),
      ["sticky"]: new StickyTool(this)
    });
    __publicField3(this, "currentTool", this.tools.select);
    __publicField3(this, "session");
    __publicField3(this, "readOnly", false);
    __publicField3(this, "isDirty", false);
    __publicField3(this, "isCreating", false);
    __publicField3(this, "originPoint", [0, 0]);
    __publicField3(this, "currentPoint", [0, 0]);
    __publicField3(this, "previousPoint", [0, 0]);
    __publicField3(this, "shiftKey", false);
    __publicField3(this, "altKey", false);
    __publicField3(this, "metaKey", false);
    __publicField3(this, "ctrlKey", false);
    __publicField3(this, "spaceKey", false);
    __publicField3(this, "isPointing", false);
    __publicField3(this, "isForcePanning", false);
    __publicField3(this, "editingStartTime", -1);
    __publicField3(this, "fileSystemHandle", null);
    __publicField3(this, "viewport", Utils.getBoundsFromPoints([
      [0, 0],
      [100, 100]
    ]));
    __publicField3(this, "rendererBounds", Utils.getBoundsFromPoints([
      [0, 0],
      [100, 100]
    ]));
    __publicField3(this, "selectHistory", {
      stack: [[]],
      pointer: 0
    });
    __publicField3(this, "clipboard");
    __publicField3(this, "rotationInfo", {
      selectedIds: [],
      center: [0, 0]
    });
    __publicField3(this, "pasteInfo", {
      center: [0, 0],
      offset: [0, 0]
    });
    __publicField3(this, "migrate", (state) => {
      return __spreadProps4(__spreadValues4({}, state), {
        document: migrate(state.document, _TldrawApp.version)
      });
    });
    __publicField3(this, "onReady", () => {
      var _a2, _b;
      this.loadDocument(this.document);
      loadFileHandle().then((fileHandle) => {
        this.fileSystemHandle = fileHandle;
      });
      try {
        this.patchState({
          appState: {
            status: "idle"
          },
          document: migrate(this.document, _TldrawApp.version)
        });
      } catch (e11) {
        console.error("The data appears to be corrupted. Resetting!", e11);
        localStorage.setItem(this.document.id + "_corrupted", JSON.stringify(this.document));
        this.patchState(__spreadProps4(__spreadValues4({}, _TldrawApp.defaultState), {
          appState: __spreadProps4(__spreadValues4({}, _TldrawApp.defaultState.appState), {
            status: "idle"
          })
        }));
      }
      (_b = (_a2 = this.callbacks).onMount) == null ? void 0 : _b.call(_a2, this);
    });
    __publicField3(this, "cleanup", (state, prev) => {
      var _a2;
      const next = __spreadValues4({}, state);
      if (next.document !== prev.document) {
        Object.entries(next.document.pages).forEach(([pageId, page]) => {
          if (page === void 0) {
            delete next.document.pages[pageId];
            delete next.document.pageStates[pageId];
            return;
          }
          const prevPage = prev.document.pages[pageId];
          const changedShapes = {};
          if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {
            page.shapes = __spreadValues4({}, page.shapes);
            page.bindings = __spreadValues4({}, page.bindings);
            const groupsToUpdate = /* @__PURE__ */ new Set();
            Object.entries(page.shapes).forEach(([id2, shape]) => {
              var _a22;
              let parentId;
              if (!shape) {
                parentId = (_a22 = prevPage == null ? void 0 : prevPage.shapes[id2]) == null ? void 0 : _a22.parentId;
                delete page.shapes[id2];
              } else {
                parentId = shape.parentId;
              }
              if (page.id === next.appState.currentPageId) {
                if ((prevPage == null ? void 0 : prevPage.shapes[id2]) !== shape) {
                  changedShapes[id2] = shape;
                }
              }
              if (parentId && parentId !== pageId) {
                const group = page.shapes[parentId];
                if (group !== void 0) {
                  groupsToUpdate.add(page.shapes[parentId]);
                }
              }
            });
            Object.keys(page.bindings).forEach((id2) => {
              if (!page.bindings[id2]) {
                delete page.bindings[id2];
              }
            });
            next.document.pages[pageId] = page;
            const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId);
            const visitedShapes = /* @__PURE__ */ new Set();
            bindingsToUpdate.forEach((binding) => {
              if (!page.bindings[binding.id]) {
                return;
              }
              const toShape = page.shapes[binding.toId];
              const fromShape = page.shapes[binding.fromId];
              if (!(toShape && fromShape)) {
                delete next.document.pages[pageId].bindings[binding.id];
                return;
              }
              if (visitedShapes.has(fromShape)) {
                return;
              }
              const fromDelta = TLDR.updateArrowBindings(page, fromShape);
              visitedShapes.add(fromShape);
              if (fromDelta) {
                const nextShape = __spreadValues4(__spreadValues4({}, fromShape), fromDelta);
                page.shapes[fromShape.id] = nextShape;
              }
            });
            groupsToUpdate.forEach((group) => {
              if (!group)
                throw Error("no group!");
              const children = group.children.filter((id2) => page.shapes[id2] !== void 0);
              const commonBounds = Utils.getCommonBounds(children.map((id2) => page.shapes[id2]).filter(Boolean).map((shape) => TLDR.getRotatedBounds(shape)));
              page.shapes[group.id] = __spreadProps4(__spreadValues4({}, group), {
                point: [commonBounds.minX, commonBounds.minY],
                size: [commonBounds.width, commonBounds.height],
                children
              });
            });
          }
          const nextPageState = __spreadValues4({}, next.document.pageStates[pageId]);
          if (!nextPageState.brush) {
            delete nextPageState.brush;
          }
          if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {
            delete nextPageState.hoveredId;
          }
          if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {
            TLDR.warn(`Could not find the binding of ${pageId}`);
            delete nextPageState.bindingId;
          }
          if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {
            TLDR.warn("Could not find the editing shape!");
            delete nextPageState.editingId;
          }
          next.document.pageStates[pageId] = nextPageState;
        });
      }
      Object.keys((_a2 = next.document.assets) != null ? _a2 : {}).forEach((id2) => {
        var _a22, _b;
        if (!((_a22 = next.document.assets) == null ? void 0 : _a22[id2])) {
          (_b = next.document.assets) == null ? true : delete _b[id2];
        }
      });
      const currentPageId = next.appState.currentPageId;
      const currentPageState = next.document.pageStates[currentPageId];
      if (next.room && next.room !== prev.room) {
        const room2 = __spreadProps4(__spreadValues4({}, next.room), { users: __spreadValues4({}, next.room.users) });
        if (prev.room) {
          Object.values(prev.room.users).filter(Boolean).forEach((user) => {
            if (room2.users[user.id] === void 0) {
              delete room2.users[user.id];
            }
          });
        }
        next.room = room2;
      }
      if (next.room) {
        next.room.users[next.room.userId] = __spreadProps4(__spreadValues4({}, next.room.users[next.room.userId]), {
          point: this.currentPoint,
          selectedIds: currentPageState.selectedIds
        });
      }
      if (this.readOnly) {
        next.document.pages = prev.document.pages;
      }
      return next;
    });
    __publicField3(this, "onPatch", (state, id2) => {
      var _a2, _b;
      (_b = (_a2 = this.callbacks).onPatch) == null ? void 0 : _b.call(_a2, this, id2);
    });
    __publicField3(this, "onCommand", (state, id2) => {
      var _a2, _b;
      this.clearSelectHistory();
      this.isDirty = true;
      (_b = (_a2 = this.callbacks).onCommand) == null ? void 0 : _b.call(_a2, this, id2);
    });
    __publicField3(this, "onReplace", () => {
      this.clearSelectHistory();
      this.isDirty = false;
    });
    __publicField3(this, "onUndo", () => {
      var _a2, _b;
      this.rotationInfo.selectedIds = [...this.selectedIds];
      (_b = (_a2 = this.callbacks).onUndo) == null ? void 0 : _b.call(_a2, this);
    });
    __publicField3(this, "onRedo", () => {
      var _a2, _b;
      this.rotationInfo.selectedIds = [...this.selectedIds];
      (_b = (_a2 = this.callbacks).onRedo) == null ? void 0 : _b.call(_a2, this);
    });
    __publicField3(this, "onPersist", () => {
      var _a2, _b;
      if (this.callbacks.onChangePage) {
        this.broadcastPageChanges();
      }
      (_b = (_a2 = this.callbacks).onPersist) == null ? void 0 : _b.call(_a2, this);
    });
    __publicField3(this, "prevSelectedIds", this.selectedIds);
    __publicField3(this, "onStateDidChange", (_state, id2) => {
      var _a2, _b, _c, _d;
      (_b = (_a2 = this.callbacks).onChange) == null ? void 0 : _b.call(_a2, this, id2);
      if (this.room && this.selectedIds !== this.prevSelectedIds) {
        (_d = (_c = this.callbacks).onChangePresence) == null ? void 0 : _d.call(_c, this, __spreadProps4(__spreadValues4({}, this.room.users[this.room.userId]), {
          selectedIds: this.selectedIds
        }));
        this.prevSelectedIds = this.selectedIds;
      }
    });
    __publicField3(this, "justSent", false);
    __publicField3(this, "prevShapes", this.page.shapes);
    __publicField3(this, "prevBindings", this.page.bindings);
    __publicField3(this, "prevAssets", this.document.assets);
    __publicField3(this, "broadcastPageChanges", () => {
      var _a2, _b;
      const visited = /* @__PURE__ */ new Set();
      const changedShapes = {};
      const changedBindings = {};
      const changedAssets = {};
      this.shapes.forEach((shape) => {
        visited.add(shape.id);
        if (this.prevShapes[shape.id] !== shape) {
          changedShapes[shape.id] = shape;
        }
      });
      Object.keys(this.prevShapes).filter((id2) => !visited.has(id2)).forEach((id2) => {
        changedShapes[id2] = void 0;
      });
      this.bindings.forEach((binding) => {
        visited.add(binding.id);
        if (this.prevBindings[binding.id] !== binding) {
          changedBindings[binding.id] = binding;
        }
      });
      Object.keys(this.prevBindings).filter((id2) => !visited.has(id2)).forEach((id2) => {
        changedBindings[id2] = void 0;
      });
      this.assets.forEach((asset) => {
        visited.add(asset.id);
        if (this.prevAssets[asset.id] !== asset) {
          changedAssets[asset.id] = asset;
        }
      });
      Object.keys(this.prevAssets).filter((id2) => !visited.has(id2)).forEach((id2) => {
        changedAssets[id2] = void 0;
      });
      if (Object.keys(changedBindings).length > 0 || Object.keys(changedShapes).length > 0 || Object.keys(changedAssets).length > 0) {
        this.justSent = true;
        (_b = (_a2 = this.callbacks).onChangePage) == null ? void 0 : _b.call(_a2, this, changedShapes, changedBindings, changedAssets);
        this.prevShapes = this.page.shapes;
        this.prevBindings = this.page.bindings;
        this.prevAssets = this.document.assets;
      }
    });
    __publicField3(this, "getReservedContent", (coreReservedIds, pageId = this.currentPageId) => {
      const { bindings } = this.document.pages[pageId];
      const reservedShapes = {};
      const reservedBindings = {};
      const bindingsArr = Object.values(bindings);
      const boundTos = new Map(bindingsArr.map((binding) => [binding.toId, binding]));
      const boundFroms = new Map(bindingsArr.map((binding) => [binding.fromId, binding]));
      const bindingMaps = [boundTos, boundFroms];
      const reservedShapeIds = [];
      if (this.session)
        coreReservedIds.forEach((id2) => reservedShapeIds.push(id2));
      if (this.pageState.editingId)
        reservedShapeIds.push(this.pageState.editingId);
      const strongReservedShapeIds = new Set(reservedShapeIds);
      const visited = /* @__PURE__ */ new Set();
      while (reservedShapeIds.length > 0) {
        const id2 = reservedShapeIds.pop();
        if (!id2)
          break;
        if (visited.has(id2))
          continue;
        visited.add(id2);
        const shape = this.getShape(id2);
        reservedShapes[id2] = shape;
        if (shape.parentId !== pageId)
          reservedShapeIds.push(shape.parentId);
        if (shape.children)
          reservedShapeIds.push(...shape.children);
        bindingMaps.map((map4) => map4.get(shape.id)).filter(Boolean).forEach((binding) => {
          reservedBindings[binding.id] = binding;
          reservedShapeIds.push(binding.toId, binding.fromId);
        });
      }
      return { reservedShapes, reservedBindings, strongReservedShapeIds };
    });
    __publicField3(this, "replacePageContent", (shapes, bindings, assets, pageId = this.currentPageId) => {
      if (this.justSent) {
        this.justSent = false;
        return this;
      }
      const page = this.document.pages[this.currentPageId];
      Object.values(shapes).forEach((shape) => {
        if (shape.parentId !== pageId && !(page.shapes[shape.parentId] || shapes[shape.parentId])) {
          console.warn("Added a shape without a parent on the page");
          shape.parentId = pageId;
        }
      });
      this.useStore.setState((current) => {
        const { hoveredId, editingId, bindingId, selectedIds } = current.document.pageStates[pageId];
        const coreReservedIds = [...selectedIds];
        const editingShape = editingId && current.document.pages[this.currentPageId].shapes[editingId];
        if (editingShape)
          coreReservedIds.push(editingShape.id);
        const { reservedShapes, reservedBindings, strongReservedShapeIds } = this.getReservedContent(coreReservedIds, this.currentPageId);
        Object.values(reservedShapes).filter((reservedShape) => !("text" in reservedShape)).forEach((reservedShape) => {
          const incomingShape = shapes[reservedShape.id];
          if (!incomingShape)
            return;
          if (!(reservedShape.type === "arrow" || strongReservedShapeIds.has(reservedShape.id))) {
            shapes[reservedShape.id] = incomingShape;
            return;
          }
          if ("decorations" in incomingShape && "decorations" in reservedShape) {
            shapes[reservedShape.id] = __spreadProps4(__spreadValues4({}, reservedShape), { decorations: incomingShape.decorations });
          }
          reservedShape.style = incomingShape.style;
        });
        this.prevShapes = shapes;
        this.prevBindings = bindings;
        this.prevAssets = assets;
        const nextShapes = __spreadValues4(__spreadValues4({}, shapes), reservedShapes);
        if (editingShape) {
          nextShapes[editingShape.id] = editingShape;
        }
        const nextBindings = __spreadValues4(__spreadValues4({}, bindings), reservedBindings);
        const nextAssets = __spreadValues4({}, assets);
        const next = __spreadProps4(__spreadValues4({}, current), {
          document: __spreadProps4(__spreadValues4({}, current.document), {
            pages: {
              [pageId]: __spreadProps4(__spreadValues4({}, current.document.pages[pageId]), {
                shapes: nextShapes,
                bindings: nextBindings
              })
            },
            assets: nextAssets,
            pageStates: __spreadProps4(__spreadValues4({}, current.document.pageStates), {
              [pageId]: __spreadProps4(__spreadValues4({}, current.document.pageStates[pageId]), {
                selectedIds: selectedIds.filter((id2) => nextShapes[id2] !== void 0),
                hoveredId: hoveredId ? nextShapes[hoveredId] === void 0 ? void 0 : hoveredId : void 0,
                editingId,
                bindingId: bindingId ? nextBindings[bindingId] === void 0 ? void 0 : bindingId : void 0
              })
            })
          })
        });
        const page2 = next.document.pages[pageId];
        const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(nextShapes), pageId);
        const visitedShapes = /* @__PURE__ */ new Set();
        bindingsToUpdate.forEach((binding) => {
          if (!page2.bindings[binding.id]) {
            return;
          }
          const fromShape = page2.shapes[binding.fromId];
          if (visitedShapes.has(fromShape)) {
            return;
          }
          const fromDelta = TLDR.updateArrowBindings(page2, fromShape);
          visitedShapes.add(fromShape);
          if (fromDelta) {
            const nextShape = __spreadValues4(__spreadValues4({}, fromShape), fromDelta);
            page2.shapes[fromShape.id] = nextShape;
          }
        });
        Object.values(nextShapes).forEach((shape) => {
          if (shape.type !== "group")
            return;
          const children = shape.children.filter((id2) => page2.shapes[id2] !== void 0);
          const commonBounds = Utils.getCommonBounds(children.map((id2) => page2.shapes[id2]).filter(Boolean).map((shape2) => TLDR.getRotatedBounds(shape2)));
          page2.shapes[shape.id] = __spreadProps4(__spreadValues4({}, shape), {
            point: [commonBounds.minX, commonBounds.minY],
            size: [commonBounds.width, commonBounds.height],
            children
          });
        });
        this.state.document = next.document;
        return next;
      }, true);
      return this;
    });
    __publicField3(this, "updateBounds", (bounds) => {
      this.rendererBounds = bounds;
      const { point, zoom } = this.pageState.camera;
      this.updateViewport(point, zoom);
      if (!this.readOnly && this.session) {
        this.session.update();
      }
    });
    __publicField3(this, "updateViewport", (point, zoom) => {
      const { width, height } = this.rendererBounds;
      const [minX, minY] = Vec.sub(Vec.div([0, 0], zoom), point);
      const [maxX, maxY] = Vec.sub(Vec.div([width, height], zoom), point);
      this.viewport = {
        minX,
        minY,
        maxX,
        maxY,
        height: maxX - minX,
        width: maxY - minY
      };
    });
    __publicField3(this, "setEditingId", (id2) => {
      if (this.readOnly)
        return;
      this.editingStartTime = performance.now();
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: {
              editingId: id2
            }
          }
        }
      }, `set_editing_id`);
    });
    __publicField3(this, "setHoveredId", (id2) => {
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: {
              hoveredId: id2
            }
          }
        }
      }, `set_hovered_id`);
    });
    __publicField3(this, "setSetting", (name, value) => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          [name]: typeof value === "function" ? value(this.settings[name]) : value
        }
      }, `settings:${name}`);
      this.persist();
      return this;
    });
    __publicField3(this, "toggleFocusMode", () => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          isFocusMode: !this.settings.isFocusMode
        }
      }, `settings:toggled_focus_mode`);
      this.persist();
      return this;
    });
    __publicField3(this, "togglePenMode", () => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          isPenMode: !this.settings.isPenMode
        }
      }, `settings:toggled_pen_mode`);
      this.persist();
      return this;
    });
    __publicField3(this, "toggleDarkMode", () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isDarkMode: !this.settings.isDarkMode } }, `settings:toggled_dark_mode`);
      this.persist();
      return this;
    });
    __publicField3(this, "toggleZoomSnap", () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isZoomSnap: !this.settings.isZoomSnap } }, `settings:toggled_zoom_snap`);
      this.persist();
      return this;
    });
    __publicField3(this, "toggleDebugMode", () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isDebugMode: !this.settings.isDebugMode } }, `settings:toggled_debug`);
      this.persist();
      return this;
    });
    __publicField3(this, "setMenuOpen", (isOpen) => {
      this.patchState({ appState: { isMenuOpen: isOpen } }, "ui:toggled_menu_opened");
      this.persist();
      return this;
    });
    __publicField3(this, "setIsLoading", (isLoading) => {
      this.patchState({ appState: { isLoading } }, "ui:toggled_is_loading");
      this.persist();
      return this;
    });
    __publicField3(this, "setDisableAssets", (disableAssets) => {
      this.patchState({ appState: { disableAssets } }, "ui:toggled_disable_images");
      return this;
    });
    __publicField3(this, "toggleGrid", () => {
      if (this.session)
        return this;
      this.patchState({ settings: { showGrid: !this.settings.showGrid } }, "settings:toggled_grid");
      this.persist();
      return this;
    });
    __publicField3(this, "selectTool", (type) => {
      if (this.readOnly || this.session)
        return this;
      this.isPointing = false;
      const tool = this.tools[type];
      if (tool === this.currentTool) {
        this.patchState({
          appState: {
            isToolLocked: false
          }
        });
        return this;
      }
      this.currentTool.onExit();
      tool.previous = this.currentTool.type;
      this.currentTool = tool;
      this.currentTool.onEnter();
      return this.patchState({
        appState: {
          activeTool: type,
          isToolLocked: false
        }
      }, `selected_tool:${type}`);
    });
    __publicField3(this, "toggleToolLock", () => {
      if (this.session)
        return this;
      return this.patchState({
        appState: {
          isToolLocked: !this.appState.isToolLocked
        }
      }, `toggled_tool_lock`);
    });
    __publicField3(this, "resetDocument", () => {
      if (this.session)
        return this;
      this.session = void 0;
      this.pasteInfo.offset = [0, 0];
      this.currentTool = this.tools.select;
      this.resetHistory().clearSelectHistory().loadDocument(migrate(_TldrawApp.defaultDocument, _TldrawApp.version)).persist();
      return this;
    });
    __publicField3(this, "updateUsers", (users, isOwnUpdate = false) => {
      this.patchState({
        room: {
          users: Object.fromEntries(users.map((user) => [user.id, user]))
        }
      }, isOwnUpdate ? "room:self:update" : "room:user:update");
    });
    __publicField3(this, "removeUser", (userId) => {
      this.patchState({
        room: {
          users: {
            [userId]: void 0
          }
        }
      });
    });
    __publicField3(this, "mergeDocument", (document2) => {
      if (this.document.id !== document2.id) {
        this.replaceState(__spreadProps4(__spreadValues4({}, this.state), {
          appState: __spreadProps4(__spreadValues4({}, this.appState), {
            currentPageId: Object.keys(document2.pages)[0]
          }),
          document: migrate(document2, _TldrawApp.version)
        }));
        return this;
      }
      const currentPageStates = __spreadValues4({}, this.document.pageStates);
      const nextAppState = __spreadProps4(__spreadValues4({}, this.appState), {
        currentPageId: document2.pages[this.currentPageId] ? this.currentPageId : Object.keys(document2.pages)[0],
        pages: Object.values(document2.pages).map((page, i8) => ({
          id: page.id,
          name: page.name,
          childIndex: page.childIndex || i8
        }))
      });
      this.resetHistory();
      Object.keys(this.document.pages).forEach((pageId) => {
        if (!document2.pages[pageId]) {
          if (pageId === this.appState.currentPageId) {
            this.cancelSession();
            this.selectNone();
          }
          currentPageStates[pageId] = void 0;
        }
      });
      if (this.session) {
        this.selectedIds.filter((id2) => !document2.pages[this.currentPageId].shapes[id2]).forEach((id2) => document2.pages[this.currentPageId].shapes[id2] = this.page.shapes[id2]);
      }
      Object.entries(currentPageStates).forEach(([pageId, pageState]) => {
        pageState.selectedIds = pageState.selectedIds.filter((id2) => !!document2.pages[pageId].shapes[id2]);
      });
      const { editingId } = this.pageState;
      if (editingId) {
        document2.pages[this.currentPageId].shapes[editingId] = this.page.shapes[editingId];
        currentPageStates[this.currentPageId].selectedIds = [editingId];
      }
      return this.replaceState(__spreadProps4(__spreadValues4({}, this.state), {
        appState: nextAppState,
        document: __spreadProps4(__spreadValues4({}, migrate(document2, _TldrawApp.version)), {
          pageStates: currentPageStates
        })
      }), "merge");
    });
    __publicField3(this, "updateDocument", (document2, reason = "updated_document") => {
      const prevState = this.state;
      const nextState = __spreadProps4(__spreadValues4({}, prevState), { document: __spreadValues4({}, prevState.document) });
      if (!document2.pages[this.currentPageId]) {
        nextState.appState = __spreadProps4(__spreadValues4({}, prevState.appState), {
          currentPageId: Object.keys(document2.pages)[0]
        });
      }
      let i8 = 1;
      for (const nextPage of Object.values(document2.pages)) {
        if (nextPage !== prevState.document.pages[nextPage.id]) {
          nextState.document.pages[nextPage.id] = nextPage;
          if (!nextPage.name) {
            nextState.document.pages[nextPage.id].name = `Page ${i8 + 1}`;
            i8++;
          }
        }
      }
      for (const nextPageState of Object.values(document2.pageStates)) {
        if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {
          nextState.document.pageStates[nextPageState.id] = nextPageState;
          const nextPage = document2.pages[nextPageState.id];
          const keysToCheck = ["bindingId", "editingId", "hoveredId", "pointedId"];
          for (const key of keysToCheck) {
            if (!nextPage.shapes[key]) {
              nextPageState[key] = void 0;
            }
          }
          nextPageState.selectedIds = nextPageState.selectedIds.filter((id2) => !!document2.pages[nextPage.id].shapes[id2]);
        }
      }
      nextState.document = migrate(nextState.document, nextState.document.version || 0);
      return this.replaceState(nextState, `${reason}:${document2.id}`);
    });
    __publicField3(this, "loadRoom", (roomId, userName) => {
      this.patchState({
        room: {
          id: roomId,
          userId: uuid,
          users: {
            [uuid]: {
              id: uuid,
              name: userName,
              color: USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)],
              point: [100, 100],
              selectedIds: [],
              activeShapes: []
            }
          }
        }
      });
      return this;
    });
    __publicField3(this, "loadDocument", (document2) => {
      this.selectNone();
      this.resetHistory();
      this.clearSelectHistory();
      this.session = void 0;
      this.replaceState(__spreadProps4(__spreadValues4({}, _TldrawApp.defaultState), {
        settings: __spreadValues4({}, this.state.settings),
        document: migrate(document2, _TldrawApp.version),
        appState: __spreadProps4(__spreadValues4(__spreadValues4({}, _TldrawApp.defaultState.appState), this.state.appState), {
          currentPageId: Object.keys(document2.pages)[0],
          disableAssets: this.disableAssets
        })
      }), "loaded_document");
      const { point, zoom } = this.pageState.camera;
      this.updateViewport(point, zoom);
      return this;
    });
    __publicField3(this, "newProject", () => {
      if (!this.isLocal)
        return;
      this.fileSystemHandle = null;
      this.resetDocument();
    });
    __publicField3(this, "saveProject", () => __async2(this, null, function* () {
      if (this.readOnly)
        return;
      try {
        const fileHandle = yield saveToFileSystem(migrate(this.document, _TldrawApp.version), this.fileSystemHandle);
        this.fileSystemHandle = fileHandle;
        this.persist();
        this.isDirty = false;
      } catch (e11) {
        console.error(e11.message);
      }
      return this;
    }));
    __publicField3(this, "saveProjectAs", () => __async2(this, null, function* () {
      try {
        const fileHandle = yield saveToFileSystem(this.document, null);
        this.fileSystemHandle = fileHandle;
        this.persist();
        this.isDirty = false;
      } catch (e11) {
        console.error(e11.message);
      }
      return this;
    }));
    __publicField3(this, "openProject", () => __async2(this, null, function* () {
      if (!this.isLocal)
        return;
      try {
        const result = yield openFromFileSystem();
        if (!result) {
          throw Error();
        }
        const { fileHandle, document: document2 } = result;
        this.loadDocument(document2);
        this.fileSystemHandle = fileHandle;
        this.zoomToFit();
        this.persist();
      } catch (e11) {
        console.error(e11);
      } finally {
        this.persist();
      }
    }));
    __publicField3(this, "openAsset", () => __async2(this, null, function* () {
      if (!this.disableAssets)
        try {
          const file = yield openAssetFromFileSystem();
          if (!file)
            return;
          this.addMediaFromFile(file);
        } catch (e11) {
          console.error(e11);
        } finally {
          this.persist();
        }
    }));
    __publicField3(this, "signOut", () => {
    });
    __publicField3(this, "getAppState", () => {
      return this.appState;
    });
    __publicField3(this, "getPage", (pageId = this.currentPageId) => {
      return TLDR.getPage(this.state, pageId || this.currentPageId);
    });
    __publicField3(this, "getShapes", (pageId = this.currentPageId) => {
      return TLDR.getShapes(this.state, pageId || this.currentPageId);
    });
    __publicField3(this, "getBindings", (pageId = this.currentPageId) => {
      return TLDR.getBindings(this.state, pageId || this.currentPageId);
    });
    __publicField3(this, "getShape", (id2, pageId = this.currentPageId) => {
      return TLDR.getShape(this.state, id2, pageId);
    });
    __publicField3(this, "getShapeBounds", (id2, pageId = this.currentPageId) => {
      return TLDR.getBounds(this.getShape(id2, pageId));
    });
    __publicField3(this, "getBinding", (id2, pageId = this.currentPageId) => {
      return TLDR.getBinding(this.state, id2, pageId);
    });
    __publicField3(this, "getPageState", (pageId = this.currentPageId) => {
      return TLDR.getPageState(this.state, pageId || this.currentPageId);
    });
    __publicField3(this, "getPagePoint", (point, pageId = this.currentPageId) => {
      const { camera } = this.getPageState(pageId);
      return Vec.sub(Vec.div(point, camera.zoom), camera.point);
    });
    __publicField3(this, "createPage", (id2) => {
      if (this.readOnly)
        return this;
      const { width, height } = this.rendererBounds;
      return this.setState(createPage(this, [-width / 2, -height / 2], id2));
    });
    __publicField3(this, "changePage", (pageId) => {
      return this.setState(changePage(this, pageId));
    });
    __publicField3(this, "renamePage", (pageId, name) => {
      if (this.readOnly)
        return this;
      return this.setState(renamePage(this, pageId, name));
    });
    __publicField3(this, "duplicatePage", (pageId) => {
      if (this.readOnly)
        return this;
      return this.setState(duplicatePage(this, pageId));
    });
    __publicField3(this, "deletePage", (pageId) => {
      if (this.readOnly)
        return this;
      if (Object.values(this.document.pages).length <= 1)
        return this;
      return this.setState(deletePage(this, pageId ? pageId : this.currentPageId));
    });
    __publicField3(this, "copy", (ids = this.selectedIds) => {
      const copyingShapeIds = ids.flatMap((id2) => TLDR.getDocumentBranch(this.state, id2, this.currentPageId));
      const copyingShapes = copyingShapeIds.map((id2) => Utils.deepClone(this.getShape(id2, this.currentPageId)));
      if (copyingShapes.length === 0)
        return this;
      const copyingBindings = Object.values(this.page.bindings).filter((binding) => copyingShapeIds.includes(binding.fromId) && copyingShapeIds.includes(binding.toId));
      const copyingAssets = copyingShapes.map((shape) => {
        if (!shape.assetId)
          return;
        return this.document.assets[shape.assetId];
      }).filter(Boolean);
      this.clipboard = {
        shapes: copyingShapes,
        bindings: copyingBindings,
        assets: copyingAssets
      };
      try {
        const text2 = JSON.stringify(__spreadValues4({
          type: "tldr/clipboard"
        }, this.clipboard));
        navigator.clipboard.writeText(text2).then(() => {
        }, () => {
        });
      } catch (e11) {
      }
      this.pasteInfo.offset = [0, 0];
      this.pasteInfo.center = [0, 0];
      return this;
    });
    __publicField3(this, "cut", (ids = this.selectedIds) => {
      this.copy(ids);
      this.delete(ids);
      return this;
    });
    __publicField3(this, "paste", (point) => {
      if (this.readOnly)
        return;
      const pasteInCurrentPage = (shapes, bindings, assets) => {
        const idsMap = {};
        const newAssets = assets.filter((asset) => this.document.assets[asset.id] === void 0);
        if (newAssets.length) {
          this.patchState({
            document: {
              assets: Object.fromEntries(newAssets.map((asset) => [asset.id, asset]))
            }
          });
        }
        shapes.forEach((shape) => idsMap[shape.id] = Utils.uniqueId());
        bindings.forEach((binding) => idsMap[binding.id] = Utils.uniqueId());
        let startIndex = TLDR.getTopChildIndex(this.state, this.currentPageId);
        const shapesToPaste = shapes.sort((a7, b7) => a7.childIndex - b7.childIndex).map((shape) => {
          const parentShapeId = idsMap[shape.parentId];
          const copy2 = __spreadProps4(__spreadValues4({}, shape), {
            id: idsMap[shape.id],
            parentId: parentShapeId || this.currentPageId
          });
          if (shape.children) {
            copy2.children = shape.children.map((id2) => idsMap[id2]);
          }
          if (!parentShapeId) {
            copy2.childIndex = startIndex;
            startIndex++;
          }
          if (copy2.handles) {
            Object.values(copy2.handles).forEach((handle) => {
              if (handle.bindingId) {
                handle.bindingId = idsMap[handle.bindingId];
              }
            });
          }
          return copy2;
        });
        const bindingsToPaste = bindings.map((binding) => __spreadProps4(__spreadValues4({}, binding), {
          id: idsMap[binding.id],
          toId: idsMap[binding.toId],
          fromId: idsMap[binding.fromId]
        }));
        const commonBounds = Utils.getCommonBounds(shapesToPaste.map(TLDR.getBounds));
        let center = Vec.toFixed(this.getPagePoint(point || this.centerPoint));
        if (Vec.dist(center, this.pasteInfo.center) < 2 || Vec.dist(center, Vec.toFixed(Utils.getBoundsCenter(commonBounds))) < 2) {
          center = Vec.add(center, this.pasteInfo.offset);
          this.pasteInfo.offset = Vec.add(this.pasteInfo.offset, [GRID_SIZE, GRID_SIZE]);
        } else {
          this.pasteInfo.center = center;
          this.pasteInfo.offset = [0, 0];
        }
        const centeredBounds = Utils.centerBounds(commonBounds, center);
        const delta = Vec.sub(Utils.getBoundsCenter(centeredBounds), Utils.getBoundsCenter(commonBounds));
        this.create(shapesToPaste.map((shape) => TLDR.getShapeUtil(shape.type).create(__spreadProps4(__spreadValues4({}, shape), {
          point: Vec.toFixed(Vec.add(shape.point, delta)),
          parentId: shape.parentId || this.currentPageId
        }))), bindingsToPaste);
      };
      if (!("clipboard" in navigator && navigator.clipboard.readText)) {
        TLDR.warn("This browser does not support the Clipboard API!");
        if (this.clipboard) {
          pasteInCurrentPage(this.clipboard.shapes, this.clipboard.bindings, this.clipboard.assets);
        }
        return;
      }
      navigator.clipboard.readText().then((result) => {
        const data = JSON.parse(result);
        if (data.type === "tldr/clipboard") {
          pasteInCurrentPage(data.shapes, data.bindings, data.assets);
        } else {
          console.log(data.type);
          TLDR.warn("The selected shape was not a tldraw shape, treating as text.");
          const shapeId = Utils.uniqueId();
          this.createShapes({
            id: shapeId,
            type: "text",
            parentId: this.appState.currentPageId,
            text: TLDR.normalizeText(result),
            point: this.getPagePoint(this.centerPoint, this.currentPageId),
            style: __spreadValues4({}, this.appState.currentStyle)
          });
          this.select(shapeId);
        }
      }).catch(() => {
        if (this.clipboard) {
          pasteInCurrentPage(this.clipboard.shapes, this.clipboard.bindings, this.clipboard.assets);
        }
      });
      return this;
    });
    __publicField3(this, "copySvg", (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (ids.length === 0)
        ids = Object.keys(this.page.shapes);
      if (ids.length === 0)
        return;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const style = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style.textContent = `@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Crimson+Pro&display=block');`;
      defs.appendChild(style);
      svg.appendChild(defs);
      const shapes = ids.map((id2) => this.getShape(id2, pageId)).sort((a7, b7) => a7.childIndex - b7.childIndex);
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getRotatedBounds));
      const getSvgElementForShape = (shape) => {
        const util = TLDR.getShapeUtil(shape);
        const bounds = util.getBounds(shape);
        const elm = util.getSvgElement(shape);
        if (!elm)
          return;
        if (shape.type === "image") {
          elm.setAttribute("xlink:href", this.document.assets[shape.assetId].src);
        } else if (shape.type === "video") {
          elm.setAttribute("xlink:href", this.serializeVideo(shape.id));
        }
        elm.setAttribute("transform", `translate(${SVG_EXPORT_PADDING + shape.point[0] - commonBounds.minX}, ${SVG_EXPORT_PADDING + shape.point[1] - commonBounds.minY}) rotate(${(shape.rotation || 0) * 180 / Math.PI}, ${bounds.width / 2}, ${bounds.height / 2})`);
        return elm;
      };
      shapes.forEach((shape) => {
        var _a2;
        if ((_a2 = shape.children) == null ? void 0 : _a2.length) {
          const g6 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          shape.children.forEach((childId) => {
            const shape2 = this.getShape(childId, pageId);
            const elm2 = getSvgElementForShape(shape2);
            if (elm2)
              g6.appendChild(elm2);
          });
          svg.appendChild(g6);
          return;
        }
        const elm = getSvgElementForShape(shape);
        if (elm)
          svg.appendChild(elm);
      });
      svg.setAttribute("viewBox", [
        0,
        0,
        commonBounds.width + SVG_EXPORT_PADDING * 2,
        commonBounds.height + SVG_EXPORT_PADDING * 2
      ].join(" "));
      svg.setAttribute("width", String(commonBounds.width));
      svg.setAttribute("height", String(commonBounds.height));
      svg.setAttribute("fill", "transparent");
      svg.querySelectorAll(".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator").forEach((elm) => elm.remove());
      const svgString = new XMLSerializer().serializeToString(svg).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
      TLDR.copyStringToClipboard(svgString);
      return svgString;
    });
    __publicField3(this, "copyJson", (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (ids.length === 0)
        ids = Object.keys(this.page.shapes);
      if (ids.length === 0)
        return;
      const shapes = ids.map((id2) => this.getShape(id2, pageId));
      const json = JSON.stringify(shapes, null, 2);
      TLDR.copyStringToClipboard(json);
      return json;
    });
    __publicField3(this, "setCamera", (point, zoom, reason) => {
      this.updateViewport(point, zoom);
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: { camera: { point, zoom } }
          }
        }
      }, reason);
      return this;
    });
    __publicField3(this, "resetCamera", () => {
      return this.setCamera(this.centerPoint, 1, `reset_camera`);
    });
    __publicField3(this, "pan", (delta) => {
      const { camera } = this.pageState;
      return this.setCamera(Vec.toFixed(Vec.sub(camera.point, delta)), camera.zoom, `panned`);
    });
    __publicField3(this, "pinchZoom", (point, delta, zoom) => {
      const { camera } = this.pageState;
      const nextPoint = Vec.sub(camera.point, Vec.div(delta, camera.zoom));
      const nextZoom = zoom;
      const p0 = Vec.sub(Vec.div(point, camera.zoom), nextPoint);
      const p1 = Vec.sub(Vec.div(point, nextZoom), nextPoint);
      return this.setCamera(Vec.toFixed(Vec.add(nextPoint, Vec.sub(p1, p0))), nextZoom, `pinch_zoomed`);
    });
    __publicField3(this, "zoomTo", (next, center = this.centerPoint) => {
      const { zoom, point } = this.pageState.camera;
      const p0 = Vec.sub(Vec.div(center, zoom), point);
      const p1 = Vec.sub(Vec.div(center, next), point);
      return this.setCamera(Vec.toFixed(Vec.add(point, Vec.sub(p1, p0))), next, `zoomed_camera`);
    });
    __publicField3(this, "zoomIn", () => {
      const i8 = Math.round(this.pageState.camera.zoom * 100 / 25);
      const nextZoom = TLDR.getCameraZoom((i8 + 1) * 0.25);
      return this.zoomTo(nextZoom);
    });
    __publicField3(this, "zoomOut", () => {
      const i8 = Math.round(this.pageState.camera.zoom * 100 / 25);
      const nextZoom = TLDR.getCameraZoom((i8 - 1) * 0.25);
      return this.zoomTo(nextZoom);
    });
    __publicField3(this, "zoomToFit", () => {
      const {
        shapes,
        pageState: { camera }
      } = this;
      if (shapes.length === 0)
        return this;
      const { rendererBounds } = this;
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds));
      let zoom = TLDR.getCameraZoom(Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height));
      zoom = camera.zoom === zoom || camera.zoom < 1 ? Math.min(1, zoom) : zoom;
      const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])), zoom, `zoomed_to_fit`);
    });
    __publicField3(this, "zoomToSelection", () => {
      if (this.selectedIds.length === 0)
        return this;
      const { rendererBounds } = this;
      const selectedBounds = TLDR.getSelectedBounds(this.state);
      let zoom = TLDR.getCameraZoom(Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height));
      zoom = this.pageState.camera.zoom === zoom || this.pageState.camera.zoom < 1 ? Math.min(1, zoom) : zoom;
      const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])), zoom, `zoomed_to_selection`);
    });
    __publicField3(this, "zoomToContent", () => {
      const shapes = this.shapes;
      const pageState = this.pageState;
      if (shapes.length === 0)
        return this;
      const { rendererBounds } = this;
      const { zoom } = pageState.camera;
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds));
      const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])), this.pageState.camera.zoom, `zoomed_to_content`);
    });
    __publicField3(this, "resetZoom", () => {
      return this.zoomTo(1);
    });
    __publicField3(this, "zoomBy", Utils.throttle((delta, center) => {
      const { zoom } = this.pageState.camera;
      const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);
      return this.zoomTo(nextZoom, center);
    }, 16));
    __publicField3(this, "clearSelectHistory", () => {
      this.selectHistory.pointer = 0;
      this.selectHistory.stack = [this.selectedIds];
      return this;
    });
    __publicField3(this, "addToSelectHistory", (ids) => {
      if (this.selectHistory.pointer < this.selectHistory.stack.length) {
        this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1);
      }
      this.selectHistory.pointer++;
      this.selectHistory.stack.push(ids);
      return this;
    });
    __publicField3(this, "setSelectedIds", (ids, push2 = false) => {
      const nextIds = push2 ? [...this.pageState.selectedIds, ...ids] : [...ids];
      return this.patchState({
        appState: {
          activeTool: "select"
        },
        document: {
          pageStates: {
            [this.currentPageId]: {
              selectedIds: nextIds
            }
          }
        }
      }, `selected`);
    });
    __publicField3(this, "undoSelect", () => {
      if (this.selectHistory.pointer > 0) {
        this.selectHistory.pointer--;
        this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
      }
      return this;
    });
    __publicField3(this, "redoSelect", () => {
      if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {
        this.selectHistory.pointer++;
        this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
      }
      return this;
    });
    __publicField3(this, "select", (...ids) => {
      ids.forEach((id2) => {
        if (!this.page.shapes[id2]) {
          throw Error(`That shape does not exist on page ${this.currentPageId}`);
        }
      });
      this.setSelectedIds(ids);
      this.addToSelectHistory(ids);
      return this;
    });
    __publicField3(this, "selectAll", (pageId = this.currentPageId) => {
      if (this.session)
        return this;
      this.setSelectedIds(Object.values(this.document.pages[pageId].shapes).filter((shape) => shape.parentId === pageId).map((shape) => shape.id));
      this.addToSelectHistory(this.selectedIds);
      this.selectTool("select");
      return this;
    });
    __publicField3(this, "selectNone", () => {
      this.setSelectedIds([]);
      this.addToSelectHistory(this.selectedIds);
      return this;
    });
    __publicField3(this, "startSession", (type, ...args2) => {
      if (this.readOnly && type !== "brush")
        return this;
      if (this.session) {
        TLDR.warn(`Already in a session! (${this.session.constructor.name})`);
        this.cancelSession();
      }
      const Session = getSession(type);
      this.session = new Session(this, ...args2);
      const result = this.session.start();
      if (result) {
        this.patchState(result, `session:start_${this.session.constructor.name}`);
      }
      return this;
    });
    __publicField3(this, "updateSession", () => {
      const { session } = this;
      if (!session)
        return this;
      const patch = session.update();
      if (!patch)
        return this;
      return this.patchState(patch, `session:${session == null ? void 0 : session.constructor.name}`);
    });
    __publicField3(this, "cancelSession", () => {
      const { session } = this;
      if (!session)
        return this;
      this.session = void 0;
      const result = session.cancel();
      if (result) {
        this.patchState(result, `session:cancel:${session.constructor.name}`);
      }
      return this;
    });
    __publicField3(this, "completeSession", () => {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { session } = this;
      if (!session)
        return this;
      this.session = void 0;
      const result = session.complete();
      if (result === void 0) {
        this.isCreating = false;
        return this.patchState({
          appState: {
            status: "idle"
          },
          document: {
            pageStates: {
              [this.currentPageId]: {
                editingId: void 0,
                bindingId: void 0,
                hoveredId: void 0
              }
            }
          }
        }, `session:complete:${session.constructor.name}`);
      } else if ("after" in result) {
        if (this.isCreating) {
          result.before = {
            appState: __spreadProps4(__spreadValues4({}, result.before.appState), {
              status: "idle"
            }),
            document: {
              pages: {
                [this.currentPageId]: {
                  shapes: Object.fromEntries(this.selectedIds.map((id2) => [id2, void 0]))
                }
              },
              pageStates: {
                [this.currentPageId]: {
                  selectedIds: [],
                  editingId: null,
                  bindingId: null,
                  hoveredId: null
                }
              }
            }
          };
          if (this.appState.isToolLocked) {
            const pageState = ((_c = (_b = (_a2 = result.after) == null ? void 0 : _a2.document) == null ? void 0 : _b.pageStates) == null ? void 0 : _c[this.currentPageId]) || {};
            pageState.selectedIds = [];
          }
          this.isCreating = false;
        }
        result.after.appState = __spreadProps4(__spreadValues4({}, result.after.appState), {
          status: "idle"
        });
        result.after.document = __spreadProps4(__spreadValues4({}, result.after.document), {
          pageStates: __spreadProps4(__spreadValues4({}, (_d = result.after.document) == null ? void 0 : _d.pageStates), {
            [this.currentPageId]: __spreadProps4(__spreadValues4({}, (((_e = result.after.document) == null ? void 0 : _e.pageStates) || {})[this.currentPageId]), {
              editingId: null
            })
          })
        });
        this.setState(result, `session:complete:${session.constructor.name}`);
      } else {
        this.patchState(__spreadProps4(__spreadValues4({}, result), {
          appState: __spreadProps4(__spreadValues4({}, result.appState), {
            status: "idle"
          }),
          document: __spreadProps4(__spreadValues4({}, result.document), {
            pageStates: {
              [this.currentPageId]: __spreadProps4(__spreadValues4({}, (_g = (_f = result.document) == null ? void 0 : _f.pageStates) == null ? void 0 : _g[this.currentPageId]), {
                editingId: null
              })
            }
          })
        }), `session:complete:${session.constructor.name}`);
      }
      return this;
    });
    __publicField3(this, "createShapes", (...shapes) => {
      if (shapes.length === 0)
        return this;
      return this.create(shapes.map((shape) => {
        return TLDR.getShapeUtil(shape.type).create(__spreadValues4({
          parentId: this.currentPageId
        }, shape));
      }));
    });
    __publicField3(this, "updateShapes", (...shapes) => {
      const pageShapes = this.document.pages[this.currentPageId].shapes;
      const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id]);
      if (shapesToUpdate.length === 0)
        return this;
      return this.setState(updateShapes(this, shapesToUpdate, this.currentPageId), "updated_shapes");
    });
    __publicField3(this, "create", (shapes = [], bindings = []) => {
      if (shapes.length === 0)
        return this;
      return this.setState(createShapes(this, shapes, bindings));
    });
    __publicField3(this, "patchCreate", (shapes = [], bindings = []) => {
      if (shapes.length === 0)
        return this;
      return this.patchState(createShapes(this, shapes, bindings).after);
    });
    __publicField3(this, "delete", (ids = this.selectedIds) => {
      var _a2, _b;
      if (ids.length === 0)
        return this;
      const drawCommand = deleteShapes(this, ids);
      if (this.callbacks.onAssetDelete && ((_a2 = drawCommand.before.document) == null ? void 0 : _a2.assets) && ((_b = drawCommand.after.document) == null ? void 0 : _b.assets)) {
        const beforeAssetIds = Object.keys(drawCommand.before.document.assets).filter((k4) => !!drawCommand.before.document.assets[k4]);
        const afterAssetIds = Object.keys(drawCommand.after.document.assets).filter((k4) => !!drawCommand.after.document.assets[k4]);
        const intersection = beforeAssetIds.filter((x6) => !afterAssetIds.includes(x6));
        intersection.forEach((id2) => this.callbacks.onAssetDelete(id2));
      }
      return this.setState(drawCommand);
    });
    __publicField3(this, "deleteAll", () => {
      this.selectAll();
      this.delete();
      return this;
    });
    __publicField3(this, "style", (style, ids = this.selectedIds) => {
      return this.setState(styleShapes(this, ids, style));
    });
    __publicField3(this, "align", (type, ids = this.selectedIds) => {
      if (ids.length < 2)
        return this;
      return this.setState(alignShapes(this, ids, type));
    });
    __publicField3(this, "distribute", (direction, ids = this.selectedIds) => {
      if (ids.length < 3)
        return this;
      return this.setState(distributeShapes(this, ids, direction));
    });
    __publicField3(this, "stretch", (direction, ids = this.selectedIds) => {
      if (ids.length < 2)
        return this;
      return this.setState(stretchShapes(this, ids, direction));
    });
    __publicField3(this, "flipHorizontal", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(flipShapes(this, ids, "horizontal"));
    });
    __publicField3(this, "flipVertical", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(flipShapes(this, ids, "vertical"));
    });
    __publicField3(this, "moveToPage", (toPageId, fromPageId = this.currentPageId, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const { rendererBounds } = this;
      this.setState(moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId));
      return this;
    });
    __publicField3(this, "moveToBack", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, "toBack"));
    });
    __publicField3(this, "moveBackward", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, "backward"));
    });
    __publicField3(this, "moveForward", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, "forward"));
    });
    __publicField3(this, "moveToFront", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, "toFront"));
    });
    __publicField3(this, "nudge", (delta, isMajor = false, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const size = isMajor ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;
      return this.setState(translateShapes(this, ids, Vec.mul(delta, size)));
    });
    __publicField3(this, "duplicate", (ids = this.selectedIds, point) => {
      if (this.readOnly)
        return this;
      if (ids.length === 0)
        return this;
      return this.setState(duplicateShapes(this, ids, point));
    });
    __publicField3(this, "resetBounds", (ids = this.selectedIds) => {
      const command = resetBounds(this, ids, this.currentPageId);
      return this.setState(resetBounds(this, ids, this.currentPageId), command.id);
    });
    __publicField3(this, "toggleHidden", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isHidden"));
    });
    __publicField3(this, "toggleLocked", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isLocked"));
    });
    __publicField3(this, "toggleAspectRatioLocked", (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isAspectRatioLocked"));
    });
    __publicField3(this, "toggleDecoration", (handleId, ids = this.selectedIds) => {
      if (ids.length === 0 || !(handleId === "start" || handleId === "end"))
        return this;
      return this.setState(toggleShapesDecoration(this, ids, handleId));
    });
    __publicField3(this, "setShapeProps", (props, ids = this.selectedIds) => {
      return this.setState(setShapesProps(this, ids, props));
    });
    __publicField3(this, "rotate", (delta = Math.PI * -0.5, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const change = rotateShapes(this, ids, delta);
      if (!change)
        return this;
      return this.setState(change);
    });
    __publicField3(this, "group", (ids = this.selectedIds, groupId = Utils.uniqueId(), pageId = this.currentPageId) => {
      if (this.readOnly)
        return this;
      if (ids.length === 1 && this.getShape(ids[0], pageId).type === "group") {
        return this.ungroup(ids, pageId);
      }
      if (ids.length < 2)
        return this;
      const command = groupShapes(this, ids, groupId, pageId);
      if (!command)
        return this;
      return this.setState(command);
    });
    __publicField3(this, "ungroup", (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (this.readOnly)
        return this;
      const groups = ids.map((id2) => this.getShape(id2, pageId)).filter((shape) => shape.type === "group");
      if (groups.length === 0)
        return this;
      const command = ungroupShapes(this, ids, groups, pageId);
      if (!command) {
        return this;
      }
      return this.setState(command);
    });
    __publicField3(this, "cancel", () => {
      var _a2, _b;
      (_b = (_a2 = this.currentTool).onCancel) == null ? void 0 : _b.call(_a2);
      return this;
    });
    __publicField3(this, "addMediaFromFile", (_0, ..._1) => __async2(this, [_0, ..._1], function* (file, point = this.centerPoint) {
      this.setIsLoading(true);
      console.log(this.viewport.width);
      const id2 = Utils.uniqueId();
      const pagePoint = this.getPagePoint(point);
      const extension = file.name.match(/\.[0-9a-z]+$/i);
      if (!extension)
        throw Error("No extension");
      const isImage = IMAGE_EXTENSIONS.includes(extension[0].toLowerCase());
      const isVideo = VIDEO_EXTENSIONS.includes(extension[0].toLowerCase());
      if (!(isImage || isVideo))
        throw Error("Wrong extension");
      const shapeType = isImage ? "image" : "video";
      const assetType = isImage ? "image" : "video";
      let src;
      try {
        if (this.callbacks.onAssetCreate) {
          const result = yield this.callbacks.onAssetCreate(file, id2);
          if (!result)
            throw Error("Asset creation callback returned false");
          src = result;
        } else {
          src = yield fileToBase64(file);
        }
        if (typeof src === "string") {
          let size = [0, 0];
          if (isImage) {
            if (extension[0] == ".svg") {
              let viewBox;
              const svgString = yield fileToText(file);
              const viewBoxAttribute = this.getViewboxFromSVG(svgString);
              if (viewBoxAttribute) {
                viewBox = viewBoxAttribute.split(" ");
                size[0] = parseFloat(viewBox[2]);
                size[1] = parseFloat(viewBox[3]);
              }
            }
            if (Vec.isEqual(size, [0, 0])) {
              size = yield getImageSizeFromSrc(src);
            }
          } else {
            size = yield getVideoSizeFromSrc(src);
          }
          const match = Object.values(this.document.assets).find((asset) => asset.type === assetType && asset.src === src);
          let assetId;
          if (!match) {
            assetId = Utils.uniqueId();
            const asset = {
              id: assetId,
              type: assetType,
              src,
              size
            };
            this.patchState({
              document: {
                assets: {
                  [assetId]: asset
                }
              }
            });
          } else {
            assetId = match.id;
          }
          this.createImageOrVideoShapeAtPoint(id2, shapeType, pagePoint, size, assetId);
        }
      } catch (error) {
        console.warn(error);
        this.setIsLoading(false);
        return this;
      }
      this.setIsLoading(false);
      return this;
    }));
    __publicField3(this, "getViewboxFromSVG", (svgStr) => {
      const viewBoxRegex = /.*?viewBox=["'](-?[\d.]+[, ]+-?[\d.]+[, ][\d.]+[, ][\d.]+)["']/;
      if (typeof svgStr === "string") {
        const matches = svgStr.match(viewBoxRegex);
        return matches && matches.length >= 2 ? matches[1] : null;
      }
      console.warn("could not get viewbox from svg string");
      this.setIsLoading(false);
      return null;
    });
    __publicField3(this, "onKeyDown", (key, info, e11) => {
      var _a2, _b;
      switch (e11.key) {
        case "/": {
          if (this.status === "idle" && !this.pageState.editingId) {
            const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
            this.onPointerDown({
              target: "canvas",
              pointerId: 0,
              origin: info.point,
              point: info.point,
              delta: [0, 0],
              pressure: 0.5,
              shiftKey,
              ctrlKey,
              metaKey,
              altKey,
              spaceKey
            }, {
              shiftKey,
              altKey,
              ctrlKey,
              pointerId: 0,
              clientX: info.point[0],
              clientY: info.point[1]
            });
          }
          break;
        }
        case "Escape": {
          this.cancel();
          break;
        }
        case "Meta": {
          this.metaKey = true;
          break;
        }
        case "Alt": {
          this.altKey = true;
          break;
        }
        case "Control": {
          this.ctrlKey = true;
          break;
        }
        case " ": {
          this.isForcePanning = true;
          this.spaceKey = true;
          break;
        }
      }
      (_b = (_a2 = this.currentTool).onKeyDown) == null ? void 0 : _b.call(_a2, key, info, e11);
      return this;
    });
    __publicField3(this, "onKeyUp", (key, info, e11) => {
      var _a2, _b;
      if (!info)
        return;
      switch (e11.key) {
        case "/": {
          const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
          this.onPointerUp({
            target: "canvas",
            pointerId: 0,
            origin: currentPoint,
            point: currentPoint,
            delta: [0, 0],
            pressure: 0.5,
            shiftKey,
            ctrlKey,
            metaKey,
            altKey,
            spaceKey
          }, {
            shiftKey,
            altKey,
            ctrlKey,
            pointerId: 0,
            clientX: currentPoint[0],
            clientY: currentPoint[1]
          });
          break;
        }
        case "Meta": {
          this.metaKey = false;
          break;
        }
        case "Alt": {
          this.altKey = false;
          break;
        }
        case "Control": {
          this.ctrlKey = false;
          break;
        }
        case " ": {
          this.isForcePanning = false;
          this.spaceKey = false;
          break;
        }
      }
      (_b = (_a2 = this.currentTool).onKeyUp) == null ? void 0 : _b.call(_a2, key, info, e11);
    });
    __publicField3(this, "refreshBoundingBoxes", () => {
      const force = this.shapes.map((shape) => {
        return [
          shape.id,
          __spreadValues4({
            point: [...shape.point]
          }, "label" in shape && { label: "" })
        ];
      });
      const restore = this.shapes.map((shape) => {
        return [
          shape.id,
          __spreadValues4({
            point: [...shape.point]
          }, "label" in shape && { label: shape.label })
        ];
      });
      clearPrevSize();
      this.patchState({
        document: {
          pages: {
            [this.currentPageId]: {
              shapes: Object.fromEntries(force)
            }
          }
        }
      });
      this.patchState({
        document: {
          pages: {
            [this.currentPageId]: {
              shapes: Object.fromEntries(restore)
            }
          }
        }
      });
    });
    __publicField3(this, "onDragOver", (e11) => {
      e11.preventDefault();
    });
    __publicField3(this, "onDrop", (e11) => __async2(this, null, function* () {
      var _a2;
      e11.preventDefault();
      if (this.disableAssets)
        return this;
      if ((_a2 = e11.dataTransfer.files) == null ? void 0 : _a2.length) {
        const file = e11.dataTransfer.files[0];
        this.addMediaFromFile(file, [e11.clientX, e11.clientY]);
      }
      return this;
    }));
    __publicField3(this, "onPinchStart", (info, e11) => {
      var _a2, _b;
      (_b = (_a2 = this.currentTool).onPinchStart) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPinchEnd", (info, e11) => {
      var _a2, _b;
      return (_b = (_a2 = this.currentTool).onPinchEnd) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPinch", (info, e11) => {
      var _a2, _b;
      return (_b = (_a2 = this.currentTool).onPinch) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPan", (info, e11) => {
      if (this.appState.status === "pinching")
        return;
      const delta = Vec.div(info.delta, this.pageState.camera.zoom);
      const prev = this.pageState.camera.point;
      const next = Vec.sub(prev, delta);
      if (Vec.isEqual(next, prev))
        return;
      this.pan(delta);
      if (!this.isForcePanning)
        this.onPointerMove(info, e11);
    });
    __publicField3(this, "onZoom", (info, e11) => {
      if (this.state.appState.status !== "idle")
        return;
      const delta = info.delta[2] / 50;
      this.zoomBy(delta, info.point);
      this.onPointerMove(info, e11);
    });
    __publicField3(this, "updateInputs", (info) => {
      this.currentPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.shiftKey = info.shiftKey;
      this.altKey = info.altKey;
      this.ctrlKey = info.ctrlKey;
      this.metaKey = info.metaKey;
    });
    __publicField3(this, "onPointerMove", (info, e11) => {
      var _a2, _b, _c, _d, _e;
      this.previousPoint = this.currentPoint;
      this.updateInputs(info, e11);
      if (this.isForcePanning && this.isPointing) {
        (_a2 = this.onPan) == null ? void 0 : _a2.call(this, __spreadProps4(__spreadValues4({}, info), { delta: Vec.neg(info.delta) }), e11);
        return;
      }
      (_c = (_b = this.currentTool).onPointerMove) == null ? void 0 : _c.call(_b, info, e11);
      if (this.state.room) {
        const { users, userId } = this.state.room;
        (_e = (_d = this.callbacks).onChangePresence) == null ? void 0 : _e.call(_d, this, __spreadProps4(__spreadValues4({}, users[userId]), {
          point: this.getPagePoint(info.point)
        }));
      }
    });
    __publicField3(this, "onPointerDown", (info, e11) => {
      var _a2, _b;
      if (e11.buttons === 4) {
        this.isForcePanning = true;
      } else if (this.isPointing) {
        return;
      }
      this.isPointing = true;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      if (this.isForcePanning)
        return;
      (_b = (_a2 = this.currentTool).onPointerDown) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointerUp", (info, e11) => {
      var _a2, _b;
      this.isPointing = false;
      if (!this.shiftKey)
        this.isForcePanning = false;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointerUp) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointCanvas", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointCanvas) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDoubleClickCanvas", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDoubleClickCanvas) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onRightPointCanvas", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onRightPointCanvas) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDragCanvas", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDragCanvas) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onReleaseCanvas", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onReleaseCanvas) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointShape", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onReleaseShape", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onReleaseShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDoubleClickShape", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDoubleClickShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onRightPointShape", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onRightPointShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDragShape", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDragShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onHoverShape", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onHoverShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onUnhoverShape", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onUnhoverShape) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointBounds", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDoubleClickBounds", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDoubleClickBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onRightPointBounds", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onRightPointBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDragBounds", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDragBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onHoverBounds", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onHoverBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onUnhoverBounds", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onUnhoverBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onReleaseBounds", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onReleaseBounds) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDoubleClickBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDoubleClickBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
      if (this.selectedIds.length !== 1)
        return;
      const shape = this.getShape(this.selectedIds[0]);
      if (shape.type === "image" || shape.type === "video") {
        const asset = this.document.assets[shape.assetId];
        const util = TLDR.getShapeUtil(shape);
        const centerA = util.getCenter(shape);
        const centerB = util.getCenter(__spreadProps4(__spreadValues4({}, shape), { size: asset.size }));
        const delta = Vec.sub(centerB, centerA);
        this.updateShapes({
          id: shape.id,
          point: Vec.sub(shape.point, delta),
          size: asset.size
        });
      }
    });
    __publicField3(this, "onRightPointBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onRightPointBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDragBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDragBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onHoverBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onHoverBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onUnhoverBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onUnhoverBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onReleaseBoundsHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onReleaseBoundsHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onPointHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onPointHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDoubleClickHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDoubleClickHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onRightPointHandle", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onRightPointHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onDragHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onDragHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onHoverHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onHoverHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onUnhoverHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onUnhoverHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onReleaseHandle", (info, e11) => {
      var _a2, _b;
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onReleaseHandle) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onShapeChange", (shape) => {
      this.updateShapes(shape);
    });
    __publicField3(this, "onShapeBlur", () => {
      var _a2, _b;
      if (performance.now() - this.editingStartTime < 50)
        return;
      const { editingId } = this.pageState;
      const { isToolLocked } = this.getAppState();
      if (editingId) {
        const shape = this.getShape(editingId);
        this.setEditingId();
        if (shape.type === "text") {
          if (shape.text.trim().length <= 0) {
            this.patchState(deleteShapes(this, [editingId]).after, "delete_empty_text");
          } else if (!isToolLocked) {
            this.select(editingId);
          }
        }
      }
      (_b = (_a2 = this.currentTool).onShapeBlur) == null ? void 0 : _b.call(_a2);
    });
    __publicField3(this, "onShapeClone", (info, e11) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point).concat(info.pressure);
      this.updateInputs(info, e11);
      (_b = (_a2 = this.currentTool).onShapeClone) == null ? void 0 : _b.call(_a2, info, e11);
    });
    __publicField3(this, "onRenderCountChange", (ids) => {
      const appState = this.getAppState();
      if (appState.isEmptyCanvas && ids.length > 0) {
        this.patchState({
          appState: {
            isEmptyCanvas: false
          }
        }, "empty_canvas:false");
      } else if (!appState.isEmptyCanvas && ids.length <= 0) {
        this.patchState({
          appState: {
            isEmptyCanvas: true
          }
        }, "empty_canvas:true");
      }
    });
    __publicField3(this, "onError", () => {
    });
    __publicField3(this, "getShapeUtil", TLDR.getShapeUtil);
    this.callbacks = callbacks;
  }
  setStatus(status) {
    return this.patchState({
      appState: { status }
    }, `set_status:${status}`);
  }
  get isMenuOpen() {
    return this.appState.isMenuOpen;
  }
  get isLoading() {
    return this.appState.isLoading;
  }
  get disableAssets() {
    return this.appState.disableAssets;
  }
  get history() {
    return this.stack.slice(0, this.pointer + 1);
  }
  set history(commands) {
    this.replaceHistory(commands);
  }
  get document() {
    return this.state.document;
  }
  get settings() {
    return this.state.settings;
  }
  get appState() {
    return this.state.appState;
  }
  get currentPageId() {
    return this.state.appState.currentPageId;
  }
  get page() {
    return this.state.document.pages[this.currentPageId];
  }
  get shapes() {
    return Object.values(this.page.shapes);
  }
  get bindings() {
    return Object.values(this.page.bindings);
  }
  get assets() {
    return Object.values(this.document.assets);
  }
  get pageState() {
    return this.state.document.pageStates[this.currentPageId];
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  createTextShapeAtPoint(point, id) {
    const {
      shapes,
      appState: { currentPageId, currentStyle }
    } = this;
    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b7) => b7.childIndex - a7.childIndex)[0].childIndex + 1;
    const Text2 = shapeUtils["text"];
    const newShape = Text2.create({
      id: id || Utils.uniqueId(),
      parentId: currentPageId,
      childIndex,
      point,
      style: __spreadValues4({}, currentStyle)
    });
    const bounds = Text2.getBounds(newShape);
    newShape.point = Vec.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
    this.createShapes(newShape);
    this.setEditingId(newShape.id);
    return this;
  }
  createImageOrVideoShapeAtPoint(id, type, point, size, assetId) {
    const {
      shapes,
      appState: { currentPageId, currentStyle }
    } = this;
    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a7, b7) => b7.childIndex - a7.childIndex)[0].childIndex + 1;
    const Shape3 = shapeUtils[type];
    if (size[0] > this.viewport.width) {
      let r12 = size[1] / size[0];
      size[0] = this.viewport.width - FIT_TO_SCREEN_PADDING;
      size[1] = size[0] * r12;
      if (size[1] < 32 || size[1] < 32) {
        size[1] = 32;
        size[0] = size[1] / r12;
      }
    } else if (size[1] > this.viewport.height) {
      let r12 = size[0] / size[1];
      size[1] = this.viewport.height - FIT_TO_SCREEN_PADDING;
      size[0] = size[1] * r12;
      if (size[1] < 32 || size[1] < 32) {
        size[0] = 32;
        size[1] = size[0] / r12;
      }
    }
    const newShape = Shape3.create({
      id,
      parentId: currentPageId,
      childIndex,
      point,
      size,
      style: __spreadValues4({}, currentStyle),
      assetId
    });
    const bounds = Shape3.getBounds(newShape);
    newShape.point = Vec.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
    this.createShapes(newShape);
    return this;
  }
  isSelected(id) {
    return this.selectedIds.includes(id);
  }
  serializeVideo(id) {
    const video = document.getElementById(id + "_video");
    if (video) {
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext("2d").drawImage(video, 0, 0);
      return canvas.toDataURL("image/png");
    } else
      throw new Error("Video with id " + id + " not found");
  }
  serializeImage(id) {
    const image = document.getElementById(id + "_image");
    if (image) {
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      canvas.getContext("2d").drawImage(image, 0, 0);
      return canvas.toDataURL("image/png");
    } else
      throw new Error("Image with id " + id + " not found");
  }
  patchAssets(assets) {
    this.document.assets = __spreadValues4(__spreadValues4({}, this.document.assets), assets);
  }
  exportAllShapesAs(type) {
    return __async2(this, null, function* () {
      const initialSelectedIds = [...this.selectedIds];
      this.selectAll();
      const { width, height } = Utils.expandBounds(TLDR.getSelectedBounds(this.state), 64);
      const idsToExport = TLDR.getAllEffectedShapeIds(this.state, this.selectedIds, this.currentPageId);
      this.setSelectedIds(initialSelectedIds);
      yield this.exportShapesAs(idsToExport, [width, height], type);
    });
  }
  exportSelectedShapesAs(type) {
    return __async2(this, null, function* () {
      const { width, height } = Utils.expandBounds(TLDR.getSelectedBounds(this.state), 64);
      const idsToExport = TLDR.getAllEffectedShapeIds(this.state, this.selectedIds, this.currentPageId);
      yield this.exportShapesAs(idsToExport, [width, height], type);
    });
  }
  exportShapesAs(shapeIds, size, type) {
    return __async2(this, null, function* () {
      var _a2;
      if (!this.callbacks.onExport)
        return;
      this.setIsLoading(true);
      try {
        const assets = {};
        const shapes = shapeIds.map((id) => {
          const shape = __spreadValues4({}, this.getShape(id));
          if (shape.assetId) {
            const asset = __spreadValues4({}, this.document.assets[shape.assetId]);
            if (asset.src.toLowerCase().endsWith("gif")) {
              asset.src = this.serializeImage(shape.id);
            }
            if (shape.type === "video") {
              asset.src = this.serializeVideo(shape.id);
              asset.type = "image";
              shape.type = "image";
            }
            assets[shape.assetId] = asset;
          }
          return shape;
        });
        let serialized;
        if (type === "svg") {
          serialized = this.copySvg(shapeIds);
        } else if (type === "json") {
          serialized = this.copyJson(shapeIds);
        }
        const exportInfo = {
          currentPageId: this.currentPageId,
          name: (_a2 = this.page.name) != null ? _a2 : "export",
          shapes,
          assets,
          type,
          serialized,
          size: type === "png" ? Vec.mul(size, 2) : size
        };
        yield this.callbacks.onExport(exportInfo);
      } catch (error) {
        console.error(error);
      } finally {
        this.setIsLoading(false);
      }
    });
  }
  get room() {
    return this.state.room;
  }
  get isLocal() {
    return this.state.room === void 0 || this.state.room.id === "local";
  }
  get status() {
    return this.appState.status;
  }
  get currentUser() {
    if (!this.state.room)
      return;
    return this.state.room.users[this.state.room.userId];
  }
  get centerPoint() {
    const { width, height } = this.rendererBounds;
    return Vec.toFixed([width / 2, height / 2]);
  }
  get currentGrid() {
    const { zoom } = this.pageState.camera;
    if (zoom < 0.15) {
      return GRID_SIZE * 16;
    } else if (zoom < 1) {
      return GRID_SIZE * 4;
    } else {
      return GRID_SIZE * 1;
    }
  }
};
var TldrawApp = _TldrawApp;
__publicField3(TldrawApp, "version", 15.3);
__publicField3(TldrawApp, "defaultDocument", {
  id: "doc",
  name: "New Document",
  version: _TldrawApp.version,
  pages: {
    page: {
      id: "page",
      name: "Page 1",
      childIndex: 1,
      shapes: {},
      bindings: {}
    }
  },
  pageStates: {
    page: {
      id: "page",
      selectedIds: [],
      camera: {
        point: [0, 0],
        zoom: 1
      }
    }
  },
  assets: {}
});
__publicField3(TldrawApp, "defaultState", {
  settings: {
    isCadSelectMode: false,
    isPenMode: false,
    isDarkMode: false,
    isZoomSnap: false,
    isFocusMode: false,
    isSnapping: false,
    isDebugMode: false,
    isReadonlyMode: false,
    nudgeDistanceLarge: 16,
    nudgeDistanceSmall: 1,
    showRotateHandles: true,
    showBindingHandles: true,
    showCloneHandles: false,
    showGrid: false
  },
  appState: {
    status: "idle",
    activeTool: "select",
    hoveredId: void 0,
    currentPageId: "page",
    currentStyle: defaultStyle,
    isToolLocked: false,
    isMenuOpen: false,
    isEmptyCanvas: false,
    snapLines: [],
    isLoading: false,
    disableAssets: false
  },
  document: _TldrawApp.defaultDocument
});
var tools = {
  select: SelectTool,
  erase: EraseTool,
  ["text"]: TextTool,
  ["draw"]: DrawTool,
  ["ellipse"]: EllipseTool,
  ["rectangle"]: RectangleTool,
  ["triangle"]: TriangleTool,
  ["line"]: LineTool,
  ["arrow"]: ArrowTool,
  ["sticky"]: StickyTool
};
function useKeyboardShortcuts(ref) {
  const app = useTldrawApp();
  const canHandleEvent = React262.useCallback((ignoreMenus = false) => {
    const elm = ref.current;
    if (ignoreMenus && app.isMenuOpen)
      return true;
    return elm && (document.activeElement === elm || elm.contains(document.activeElement));
  }, [ref]);
  React262.useEffect(() => {
    if (!app)
      return;
    const handlePaste = (e11) => {
      var _a2, _b;
      let items = (_b = (_a2 = e11.clipboardData) == null ? void 0 : _a2.items) != null ? _b : [];
      for (var index2 in items) {
        var item = items[index2];
        if (item.kind === "file") {
          var file = item.getAsFile();
          if (file) {
            app.addMediaFromFile(file);
          }
        }
      }
    };
    document.addEventListener("paste", handlePaste);
    return () => {
      document.removeEventListener("paste", handlePaste);
    };
  }, [app]);
  useHotkeys("v,1", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("select");
  }, [app, ref.current]);
  useHotkeys("d,p,2", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("draw");
  }, void 0, [app]);
  useHotkeys("e,3", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("erase");
  }, void 0, [app]);
  useHotkeys("r,4", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("rectangle");
  }, void 0, [app]);
  useHotkeys("o,5", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("ellipse");
  }, void 0, [app]);
  useHotkeys("g,6", () => {
    if (!canHandleEvent())
      return;
    app.selectTool("triangle");
  }, void 0, [app]);
  useHotkeys("l,7", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("line");
  }, void 0, [app]);
  useHotkeys("a,8", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("arrow");
  }, void 0, [app]);
  useHotkeys("t,9", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("text");
  }, void 0, [app]);
  useHotkeys("s,0", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("sticky");
  }, void 0, [app]);
  useHotkeys("ctrl+shift+d,\u2318+shift+d", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.toggleDarkMode();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("ctrl+.,\u2318+.", () => {
    if (!canHandleEvent(true))
      return;
    app.toggleFocusMode();
  }, void 0, [app]);
  useHotkeys("ctrl+shift+g,\u2318+shift+g", () => {
    if (!canHandleEvent(true))
      return;
    app.toggleGrid();
  }, void 0, [app]);
  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs, onOpenMedia } = useFileSystemHandlers();
  useHotkeys("ctrl+n,\u2318+n", (e11) => {
    if (!canHandleEvent())
      return;
    onNewProject(e11);
  }, void 0, [app]);
  useHotkeys("ctrl+s,\u2318+s", (e11) => {
    if (!canHandleEvent())
      return;
    onSaveProject(e11);
  }, void 0, [app]);
  useHotkeys("ctrl+shift+s,\u2318+shift+s", (e11) => {
    if (!canHandleEvent())
      return;
    onSaveProjectAs(e11);
  }, void 0, [app]);
  useHotkeys("ctrl+o,\u2318+o", (e11) => {
    if (!canHandleEvent())
      return;
    onOpenProject(e11);
  }, void 0, [app]);
  useHotkeys("ctrl+u,\u2318+u", (e11) => {
    if (!canHandleEvent())
      return;
    onOpenMedia(e11);
  }, void 0, [app]);
  useHotkeys("\u2318+z,ctrl+z", () => {
    if (!canHandleEvent(true))
      return;
    if (app.session) {
      app.cancelSession();
    } else {
      app.undo();
    }
  }, void 0, [app]);
  useHotkeys("ctrl+shift+z,\u2318+shift+z", () => {
    if (!canHandleEvent(true))
      return;
    if (app.session) {
      app.cancelSession();
    } else {
      app.redo();
    }
  }, void 0, [app]);
  useHotkeys("\u2318+u,ctrl+u", () => {
    if (!canHandleEvent())
      return;
    app.undoSelect();
  }, void 0, [app]);
  useHotkeys("ctrl+shift-u,\u2318+shift+u", () => {
    if (!canHandleEvent())
      return;
    app.redoSelect();
  }, void 0, [app]);
  useHotkeys("ctrl+=,\u2318+=,ctrl+num_subtract,\u2318+num_subtract", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.zoomIn();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("ctrl+-,\u2318+-,ctrl+num_add,\u2318+num_add", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.zoomOut();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("shift+0,ctrl+numpad_0,\u2318+numpad_0", () => {
    if (!canHandleEvent(true))
      return;
    app.resetZoom();
  }, void 0, [app]);
  useHotkeys("shift+1", () => {
    if (!canHandleEvent(true))
      return;
    app.zoomToFit();
  }, void 0, [app]);
  useHotkeys("shift+2", () => {
    if (!canHandleEvent(true))
      return;
    app.zoomToSelection();
  }, void 0, [app]);
  useHotkeys("ctrl+d,\u2318+d", (e11) => {
    if (!canHandleEvent())
      return;
    app.duplicate();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("shift+h", () => {
    if (!canHandleEvent(true))
      return;
    app.flipHorizontal();
  }, void 0, [app]);
  useHotkeys("shift+v", () => {
    if (!canHandleEvent(true))
      return;
    app.flipVertical();
  }, void 0, [app]);
  useHotkeys("escape", () => {
    if (!canHandleEvent(true))
      return;
    app.cancel();
  }, void 0, [app]);
  useHotkeys("backspace,del", () => {
    if (!canHandleEvent())
      return;
    app.delete();
  }, void 0, [app]);
  useHotkeys("\u2318+a,ctrl+a", () => {
    if (!canHandleEvent(true))
      return;
    app.selectAll();
  }, void 0, [app]);
  useHotkeys("up", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, -1], false);
  }, void 0, [app]);
  useHotkeys("right", () => {
    if (!canHandleEvent())
      return;
    app.nudge([1, 0], false);
  }, void 0, [app]);
  useHotkeys("down", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, 1], false);
  }, void 0, [app]);
  useHotkeys("left", () => {
    if (!canHandleEvent())
      return;
    app.nudge([-1, 0], false);
  }, void 0, [app]);
  useHotkeys("shift+up", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, -1], true);
  }, void 0, [app]);
  useHotkeys("shift+right", () => {
    if (!canHandleEvent())
      return;
    app.nudge([1, 0], true);
  }, void 0, [app]);
  useHotkeys("shift+down", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, 1], true);
  }, void 0, [app]);
  useHotkeys("shift+left", () => {
    if (!canHandleEvent())
      return;
    app.nudge([-1, 0], true);
  }, void 0, [app]);
  useHotkeys("\u2318+shift+l,ctrl+shift+l", () => {
    if (!canHandleEvent())
      return;
    app.toggleLocked();
  }, void 0, [app]);
  useHotkeys("\u2318+c,ctrl+c", () => {
    if (!canHandleEvent())
      return;
    app.copy();
  }, void 0, [app]);
  useHotkeys("\u2318+shift+c,ctrl+shift+c", (e11) => {
    if (!canHandleEvent())
      return;
    app.copySvg();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("\u2318+x,ctrl+x", () => {
    if (!canHandleEvent())
      return;
    app.cut();
  }, void 0, [app]);
  useHotkeys("\u2318+v,ctrl+v", () => {
    if (!canHandleEvent())
      return;
    app.paste();
  }, void 0, [app]);
  useHotkeys("\u2318+g,ctrl+g", (e11) => {
    if (!canHandleEvent())
      return;
    app.group();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("\u2318+shift+g,ctrl+shift+g", (e11) => {
    if (!canHandleEvent())
      return;
    app.ungroup();
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("[", () => {
    if (!canHandleEvent(true))
      return;
    app.moveBackward();
  }, void 0, [app]);
  useHotkeys("]", () => {
    if (!canHandleEvent(true))
      return;
    app.moveForward();
  }, void 0, [app]);
  useHotkeys("shift+[", () => {
    if (!canHandleEvent(true))
      return;
    app.moveToBack();
  }, void 0, [app]);
  useHotkeys("shift+]", () => {
    if (!canHandleEvent(true))
      return;
    app.moveToFront();
  }, void 0, [app]);
  useHotkeys("ctrl+shift+backspace,\u2318+shift+backspace", (e11) => {
    if (!canHandleEvent())
      return;
    if (app.settings.isDebugMode) {
      app.resetDocument();
    }
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+l,alt+ctrl+l", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: "start" });
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+t,alt+ctrl+t", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: "middle" });
    e11.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+r,alt+ctrl+r", (e11) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: "end" });
    e11.preventDefault();
  }, void 0, [app]);
}
var TldrawContext = React272.createContext({});
function useTldrawApp() {
  const context = React272.useContext(TldrawContext);
  return context;
}
var styles2 = /* @__PURE__ */ new Map();
var UID = `Tldraw-fonts`;
var WEBFONT_URL = "https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Crimson+Pro&display=block";
var CSS = `
@import url('');
`;
function useStylesheet() {
  React282.useLayoutEffect(() => {
    if (styles2.get(UID))
      return;
    const style = document.createElement("style");
    style.innerHTML = `@import url('${WEBFONT_URL}');`;
    style.setAttribute("id", UID);
    document.head.appendChild(style);
    styles2.set(UID, style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
        styles2.delete(UID);
      }
    };
  }, [UID, CSS]);
}
function useFileSystemHandlers() {
  const app = useTldrawApp();
  const onNewProject = React292.useCallback((e11) => __async2(this, null, function* () {
    var _a2, _b;
    if (e11 && app.callbacks.onOpenProject)
      e11.preventDefault();
    (_b = (_a2 = app.callbacks).onNewProject) == null ? void 0 : _b.call(_a2, app);
  }), [app]);
  const onSaveProject = React292.useCallback((e11) => {
    var _a2, _b;
    if (e11 && app.callbacks.onOpenProject)
      e11.preventDefault();
    (_b = (_a2 = app.callbacks).onSaveProject) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const onSaveProjectAs = React292.useCallback((e11) => {
    var _a2, _b;
    if (e11 && app.callbacks.onOpenProject)
      e11.preventDefault();
    (_b = (_a2 = app.callbacks).onSaveProjectAs) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const onOpenProject = React292.useCallback((e11) => __async2(this, null, function* () {
    var _a2, _b;
    if (e11 && app.callbacks.onOpenProject)
      e11.preventDefault();
    (_b = (_a2 = app.callbacks).onOpenProject) == null ? void 0 : _b.call(_a2, app);
  }), [app]);
  const onOpenMedia = React292.useCallback((e11) => __async2(this, null, function* () {
    var _a2, _b;
    if (e11 && app.callbacks.onOpenMedia)
      e11.preventDefault();
    (_b = (_a2 = app.callbacks).onOpenMedia) == null ? void 0 : _b.call(_a2, app);
  }), [app]);
  return {
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject,
    onOpenMedia
  };
}
function useFileSystem() {
  const promptSaveBeforeChange = React302.useCallback((app) => __async2(this, null, function* () {
    if (app.isDirty) {
      if (app.fileSystemHandle) {
        if (window.confirm("Do you want to save changes to your current project?")) {
          yield app.saveProject();
        }
      } else {
        if (window.confirm("Do you want to save your current project?")) {
          yield app.saveProject();
        }
      }
    }
  }), []);
  const onNewProject = React302.useCallback((app) => __async2(this, null, function* () {
    if (window.confirm("Do you want to create a new project?")) {
      yield promptSaveBeforeChange(app);
      app.newProject();
    }
  }), [promptSaveBeforeChange]);
  const onSaveProject = React302.useCallback((app) => {
    app.saveProject();
  }, []);
  const onSaveProjectAs = React302.useCallback((app) => {
    app.saveProjectAs();
  }, []);
  const onOpenProject = React302.useCallback((app) => __async2(this, null, function* () {
    yield promptSaveBeforeChange(app);
    app.openProject();
  }), [promptSaveBeforeChange]);
  const onOpenMedia = React302.useCallback((app) => __async2(this, null, function* () {
    var _a2;
    (_a2 = app.openAsset) == null ? void 0 : _a2.call(app);
  }), []);
  return {
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject,
    onOpenMedia
  };
}
var breakpoints = {
  "@initial": "mobile",
  "@micro": "micro",
  "@sm": "small",
  "@md": "medium",
  "@lg": "large"
};
var statusSelector = (s9) => s9.appState.status;
var activeToolSelector = (s9) => s9.appState.activeTool;
function StatusBar() {
  const app = useTldrawApp();
  const status = app.useStore(statusSelector);
  const activeTool = app.useStore(activeToolSelector);
  return /* @__PURE__ */ React312.createElement(StyledStatusBar, {
    bp: breakpoints,
    id: "TD-StatusBar"
  }, /* @__PURE__ */ React312.createElement(StyledSection, null, activeTool, " | ", status));
}
var StyledStatusBar = styled("div", {
  height: 40,
  userSelect: "none",
  borderTop: "1px solid $panelContrast",
  gridArea: "status",
  display: "flex",
  color: "$text",
  justifyContent: "space-between",
  alignItems: "center",
  backgroundColor: "$panel",
  gap: 8,
  fontFamily: "$ui",
  fontSize: "$0",
  padding: "0 16px",
  variants: {
    bp: {
      small: {
        fontSize: "$1"
      }
    }
  }
});
var StyledSection = styled("div", {
  whiteSpace: "nowrap",
  overflow: "hidden"
});
var commandKey = () => Utils.isDarwin() ? "\u2318" : "Ctrl";
function Kbd({
  variant,
  children
}) {
  return /* @__PURE__ */ React323.createElement(StyledKbd, {
    variant
  }, children.split("").map((k4, i8) => {
    return /* @__PURE__ */ React323.createElement("span", {
      key: i8
    }, k4.replace("#", commandKey()));
  }));
}
var StyledKbd = styled("kbd", {
  marginLeft: "$3",
  textShadow: "$2",
  textAlign: "center",
  fontSize: "$0",
  fontFamily: "$ui",
  color: "$text",
  background: "none",
  fontWeight: 400,
  gap: "$1",
  display: "flex",
  alignItems: "center",
  "& > span": {
    padding: "$0",
    borderRadius: "$0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    variant: {
      tooltip: {
        "& > span": {
          color: "$tooltipContrast",
          background: "$overlayContrast",
          boxShadow: "$key",
          width: "20px",
          height: "20px"
        }
      },
      menu: {}
    }
  }
});
var SmallIcon = styled("div", {
  height: "100%",
  borderRadius: "4px",
  marginRight: "1px",
  width: "fit-content",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  color: "currentColor",
  "& svg": {
    height: 16,
    width: 16,
    strokeWidth: 1
  },
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  }
});
var RowButton = React332.forwardRef((_a2, ref) => {
  var _b = _a2, {
    onClick,
    isActive = false,
    isWarning = false,
    hasIndicator = false,
    hasArrow = false,
    disabled = false,
    isSponsor = false,
    variant,
    kbd,
    children
  } = _b, rest = __objRest3(_b, [
    "onClick",
    "isActive",
    "isWarning",
    "hasIndicator",
    "hasArrow",
    "disabled",
    "isSponsor",
    "variant",
    "kbd",
    "children"
  ]);
  return /* @__PURE__ */ React332.createElement(StyledRowButton, __spreadValues4({
    ref,
    bp: breakpoints,
    isWarning,
    isActive,
    isSponsor,
    disabled,
    onClick,
    variant
  }, rest), /* @__PURE__ */ React332.createElement(StyledRowButtonInner, null, children, kbd ? /* @__PURE__ */ React332.createElement(Kbd, {
    variant: "menu"
  }, kbd) : void 0, hasIndicator && /* @__PURE__ */ React332.createElement(ItemIndicator2, {
    dir: "ltr"
  }, /* @__PURE__ */ React332.createElement(SmallIcon, null, /* @__PURE__ */ React332.createElement(CheckIcon, null))), hasArrow && /* @__PURE__ */ React332.createElement(SmallIcon, null, /* @__PURE__ */ React332.createElement(ChevronRightIcon, null))));
});
var StyledRowButtonInner = styled("div", {
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  display: "flex",
  gap: "$1",
  flexDirection: "row",
  alignItems: "center",
  padding: "0 $3",
  justifyContent: "space-between",
  border: "1px solid transparent",
  "& svg": {
    position: "relative",
    stroke: "$overlay",
    strokeWidth: 1,
    zIndex: 1
  }
});
var StyledRowButton = styled("button", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  height: "32px",
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  padding: "0 0",
  "&[data-disabled]": {
    opacity: 0.3
  },
  "&:disabled": {
    opacity: 0.3
  },
  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {
    backgroundColor: "$hover"
  },
  "& a": {
    textDecoration: "none",
    color: "$text"
  },
  variants: {
    bp: {
      mobile: {},
      small: {}
    },
    variant: {
      styleMenu: {
        margin: "$1 0 $1 0"
      },
      wide: {
        gridColumn: "1 / span 4"
      }
    },
    size: {
      icon: {
        padding: "4px ",
        width: "auto"
      }
    },
    isSponsor: {
      true: {
        color: "#eb30a2"
      },
      false: {}
    },
    isWarning: {
      true: {
        color: "$warn"
      }
    },
    isActive: {
      true: {
        backgroundColor: "$hover"
      },
      false: {}
    }
  },
  compoundVariants: [
    {
      isActive: false,
      isSponsor: true,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledRowButtonInner}`]: {
          backgroundColor: "$sponsorContrast",
          border: "1px solid $panel",
          '& *[data-shy="true"]': {
            opacity: 1
          }
        }
      }
    },
    {
      isActive: false,
      isSponsor: false,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledRowButtonInner}`]: {
          backgroundColor: "$hover",
          border: "1px solid $panel",
          '& *[data-shy="true"]': {
            opacity: 1
          }
        }
      }
    }
  ]
});
var MenuContent2 = styled("div", {
  position: "relative",
  overflow: "hidden",
  userSelect: "none",
  display: "flex",
  flexDirection: "column",
  zIndex: 180,
  minWidth: 180,
  pointerEvents: "all",
  backgroundColor: "$panel",
  boxShadow: "$panel",
  padding: "$2 $2",
  borderRadius: "$3",
  font: "$ui",
  variants: {
    size: {
      small: {
        minWidth: 72
      }
    }
  }
});
var isEmptyCanvasSelector = (s9) => {
  return s9.appState.isEmptyCanvas && Object.keys(s9.document.pages[s9.appState.currentPageId].shapes).length > 0;
};
var BackToContent = React342.memo(function BackToContent2() {
  const app = useTldrawApp();
  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector);
  if (!isEmptyCanvas)
    return null;
  return /* @__PURE__ */ React342.createElement(BackToContentContainer, {
    id: "TD-Tools-Back_to_content"
  }, /* @__PURE__ */ React342.createElement(RowButton, {
    onClick: app.zoomToContent
  }, "Back to content"));
});
var BackToContentContainer = styled(MenuContent2, {
  pointerEvents: "all",
  width: "fit-content",
  minWidth: 0,
  gridRow: 1,
  flexGrow: 2,
  display: "block"
});
function Tooltip2({
  children,
  label,
  kbd: kbdProp,
  id,
  side = "top"
}) {
  return /* @__PURE__ */ React352.createElement("span", {
    id
  }, /* @__PURE__ */ React352.createElement(Root7, null, /* @__PURE__ */ React352.createElement(Trigger2, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ React352.createElement("span", null, children)), /* @__PURE__ */ React352.createElement(StyledContent, {
    dir: "ltr",
    side,
    sideOffset: 8
  }, label, kbdProp ? /* @__PURE__ */ React352.createElement(Kbd, {
    variant: "tooltip"
  }, kbdProp) : null, /* @__PURE__ */ React352.createElement(StyledArrow, null))));
}
var StyledContent = styled(Content4, {
  borderRadius: 3,
  padding: "$3 $3 $3 $3",
  fontSize: "$1",
  backgroundColor: "$tooltip",
  color: "$tooltipContrast",
  boxShadow: "$3",
  display: "flex",
  alignItems: "center",
  fontFamily: "$ui",
  userSelect: "none"
});
var StyledArrow = styled(Arrow5, {
  fill: "$tooltip",
  margin: "0 8px"
});
var ToolButton = React362.forwardRef((_a2, ref) => {
  var _b = _a2, {
    onSelect,
    onClick,
    onDoubleClick,
    variant,
    children,
    isToolLocked = false,
    disabled = false,
    isActive = false,
    isSponsor = false,
    onKeyDown,
    id
  } = _b, rest = __objRest3(_b, [
    "onSelect",
    "onClick",
    "onDoubleClick",
    "variant",
    "children",
    "isToolLocked",
    "disabled",
    "isActive",
    "isSponsor",
    "onKeyDown",
    "id"
  ]);
  return /* @__PURE__ */ React362.createElement(StyledToolButton, __spreadValues4({
    ref,
    isActive,
    isSponsor,
    variant,
    onClick,
    disabled,
    onPointerDown: onSelect,
    onDoubleClick,
    onKeyDown,
    bp: breakpoints,
    id
  }, rest), /* @__PURE__ */ React362.createElement(StyledToolButtonInner, null, children), isToolLocked && /* @__PURE__ */ React362.createElement(ToolLockIndicator, null));
});
function ToolButtonWithTooltip(_a2) {
  var _b = _a2, {
    label,
    kbd,
    isLocked
  } = _b, rest = __objRest3(_b, [
    "label",
    "kbd",
    "isLocked"
  ]);
  const app = useTldrawApp();
  const handleDoubleClick = React362.useCallback(() => {
    app.toggleToolLock();
  }, []);
  const handleKeyDown = React362.useCallback((e11) => {
    if (e11.key === " " && app.isForcePanning) {
      e11.preventDefault();
    }
  }, []);
  return /* @__PURE__ */ React362.createElement(Tooltip2, {
    label: label[0].toUpperCase() + label.slice(1),
    kbd
  }, /* @__PURE__ */ React362.createElement(ToolButton, __spreadProps4(__spreadValues4({}, rest), {
    variant: "primary",
    isToolLocked: isLocked && rest.isActive,
    onDoubleClick: handleDoubleClick,
    onKeyDown: handleKeyDown
  })));
}
var StyledToolButtonInner = styled("div", {
  position: "relative",
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontFamily: "$ui",
  color: "inherit",
  userSelect: "none",
  boxSizing: "border-box",
  border: "1px solid transparent"
});
var StyledToolButton = styled("button", {
  position: "relative",
  color: "$text",
  fontSize: "$0",
  background: "none",
  margin: "0",
  padding: "$2",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  cursor: "pointer",
  pointerEvents: "all",
  border: "none",
  height: "40px",
  width: "40px",
  [`&:disabled ${StyledToolButtonInner}`]: {
    opacity: 0.618
  },
  variants: {
    variant: {
      primary: {
        marginTop: "0"
      },
      icon: {
        [`& ${StyledToolButtonInner}`]: {
          display: "grid",
          "& > *": {
            gridRow: 1,
            gridColumn: 1
          }
        }
      },
      text: {
        width: "auto",
        [`& ${StyledToolButtonInner}`]: {
          fontSize: "$1",
          padding: "0 $3",
          gap: "$3"
        }
      },
      circle: {
        padding: "$2",
        [`& ${StyledToolButtonInner}`]: {
          border: "1px solid $panelContrast",
          borderRadius: "100%",
          boxShadow: "$panel"
        },
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 14,
          height: 14
        }
      }
    },
    isSponsor: {
      true: {
        [`${StyledToolButtonInner}`]: {
          backgroundColor: "$sponsorContrast"
        }
      }
    },
    isActive: {
      true: {},
      false: {}
    },
    bp: {
      mobile: {},
      small: {}
    }
  },
  compoundVariants: [
    {
      variant: "primary",
      bp: "mobile",
      css: {
        height: "40px",
        width: "40px",
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 16,
          height: 16
        }
      }
    },
    {
      variant: "primary",
      bp: "small",
      css: {
        height: "44px",
        width: "44px",
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 20,
          height: 20
        }
      }
    },
    {
      isActive: true,
      isSponsor: false,
      css: {
        [`${StyledToolButtonInner}`]: {
          backgroundColor: "$selected",
          color: "$selectedContrast"
        }
      }
    },
    {
      isActive: false,
      isSponsor: false,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover",
          border: "1px solid $panel"
        },
        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});
var ToolLockIndicator = styled("div", {
  position: "absolute",
  width: 10,
  height: 10,
  backgroundColor: "$selected",
  borderRadius: "100%",
  bottom: -2,
  border: "2px solid $panel",
  zIndex: 100
});
var Panel = styled("div", {
  backgroundColor: "$panel",
  display: "flex",
  flexDirection: "row",
  boxShadow: "$panel",
  padding: "$2",
  border: "1px solid $panelContrast",
  gap: 0,
  variants: {
    side: {
      center: {
        borderRadius: "$4"
      },
      left: {
        padding: 0,
        borderTop: 0,
        borderLeft: 0,
        borderTopRightRadius: "$1",
        borderBottomRightRadius: "$3",
        borderBottomLeftRadius: "$1"
      },
      right: {
        padding: 0,
        borderTop: 0,
        borderRight: 0,
        borderTopLeftRadius: "$1",
        borderBottomLeftRadius: "$3",
        borderBottomRightRadius: "$1"
      }
    }
  }
});
function CircleIcon2(props) {
  const _a2 = props, { size = 16 } = _a2, rest = __objRest3(_a2, ["size"]);
  return /* @__PURE__ */ React382.createElement("svg", __spreadValues4({
    width: 24,
    height: 24
  }, rest), /* @__PURE__ */ React382.createElement("circle", {
    cx: 12,
    cy: 12,
    r: size / 2
  }));
}
function DashDashedIcon() {
  return /* @__PURE__ */ React392.createElement("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React392.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeDasharray: 50.26548 * 0.1
  }));
}
var dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`;
function DashDottedIcon() {
  return /* @__PURE__ */ React402.createElement("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React402.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeDasharray: dottedDasharray
  }));
}
function DashDrawIcon() {
  return /* @__PURE__ */ React412.createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "1 1.5 21 22",
    fill: "currentColor",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React412.createElement("path", {
    d: "M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z",
    strokeWidth: "2"
  }));
}
function DashSolidIcon() {
  return /* @__PURE__ */ React422.createElement("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React422.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2,
    strokeLinecap: "round"
  }));
}
function RedoIcon(props) {
  return /* @__PURE__ */ React442.createElement("svg", __spreadValues4({
    width: 32,
    height: 32,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React442.createElement("path", {
    d: "M4.32978 8.5081C4.32978 10.1923 5.70009 11.5625 7.38418 11.5625H8.46539C8.64456 11.5625 8.78975 11.4173 8.78975 11.2382V11.13C8.78975 10.9508 8.64457 10.8057 8.46539 10.8057H7.38418C6.11736 10.8057 5.08662 9.77492 5.08662 8.5081C5.08662 7.24128 6.11736 6.21054 7.38418 6.21054H9.37894L8.00515 7.58433C7.8576 7.73183 7.8576 7.97195 8.00515 8.11944C8.14833 8.26251 8.39751 8.2623 8.54036 8.11944L10.56 6.09971C10.6315 6.02824 10.6709 5.93321 10.6709 5.8321C10.6709 5.73106 10.6315 5.63598 10.56 5.56454L8.54025 3.54472C8.3974 3.40176 8.14801 3.40176 8.00513 3.54472C7.85758 3.69218 7.85758 3.93234 8.00513 4.07979L9.37892 5.45368H7.38418C5.70009 5.45368 4.32978 6.82393 4.32978 8.5081Z"
  }));
}
function TrashIcon(props) {
  return /* @__PURE__ */ React452.createElement("svg", __spreadValues4({
    width: 18,
    height: 18,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React452.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z"
  }), /* @__PURE__ */ React452.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z"
  }), /* @__PURE__ */ React452.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z"
  }));
}
function UndoIcon(props) {
  return /* @__PURE__ */ React462.createElement("svg", __spreadValues4({
    width: 32,
    height: 32,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React462.createElement("path", {
    d: "M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z"
  }));
}
function SizeSmallIcon(props) {
  return /* @__PURE__ */ React472.createElement("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React472.createElement("path", {
    d: "M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z"
  }));
}
function SizeMediumIcon(props) {
  return /* @__PURE__ */ React482.createElement("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React482.createElement("path", {
    d: "M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z"
  }));
}
function SizeLargeIcon(props) {
  return /* @__PURE__ */ React492.createElement("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ React492.createElement("path", {
    d: "M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z"
  }));
}
function EraserIcon() {
  return /* @__PURE__ */ React502.createElement("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React502.createElement("path", {
    d: "M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z",
    stroke: "currentColor"
  }), /* @__PURE__ */ React502.createElement("line", {
    x1: "6.01807",
    y1: "12.5",
    x2: "10.7959",
    y2: "12.5",
    stroke: "currentColor",
    strokeLinecap: "round"
  }), /* @__PURE__ */ React502.createElement("line", {
    x1: "5.50834",
    y1: "5.74606",
    x2: "10.1984",
    y2: "10.4361",
    stroke: "currentColor"
  }));
}
function MultiplayerIcon() {
  return /* @__PURE__ */ React512.createElement("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React512.createElement("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M5.73545 0.0494623C5.93029 -0.0395285 6.15915 -0.00663838 6.32104 0.133622L14.8111 7.48911C14.9804 7.63581 15.0432 7.87091 14.9696 8.08249C14.8959 8.29408 14.7007 8.4394 14.4769 8.44927L11.4564 8.58248L13.2249 12.4682C13.35 12.7431 13.2286 13.0675 12.9537 13.1927L10.9304 14.1145C10.6554 14.2397 10.331 14.1184 10.2057 13.8435L8.43441 9.95846L6.42883 12.0731L7.0482 13.434C7.17335 13.709 7.05195 14.0333 6.77702 14.1586L5.03829 14.9506C4.76335 15.0759 4.43894 14.9546 4.31361 14.6797L2.83886 11.445L1.13458 13.242C0.980476 13.4045 0.742914 13.4566 0.534904 13.3737C0.326893 13.2907 0.19043 13.0894 0.19043 12.8654V3.2218C0.19043 3.0076 0.315424 2.81309 0.510266 2.7241C0.705108 2.63511 0.933961 2.668 1.09586 2.80826L5.41561 6.55076V0.547159C5.41561 0.332956 5.54061 0.138453 5.73545 0.0494623ZM6.74741 10.147L6.50992 10.3974V10.1575V9.0621V8.94669V7.49882V1.74513L13.0561 7.41656L10.5986 7.52495C10.417 7.53296 10.2512 7.63066 10.1562 7.78567C10.1444 7.80505 10.1338 7.825 10.1245 7.84541C10.0596 7.98828 10.0589 8.15342 10.1247 8.2982V8.2982L12.0023 12.4236L10.9745 12.8919L9.09356 8.7663C9.0181 8.60079 8.86531 8.4836 8.68589 8.45361C8.50647 8.42363 8.32389 8.48478 8.19871 8.61676L8.019 8.80624L6.74741 10.147ZM5.41561 9.11037V7.99863L1.28473 4.41977V11.4934L2.60315 10.1033C2.72833 9.97131 2.91091 9.91016 3.09033 9.94014C3.26975 9.97013 3.42254 10.0873 3.498 10.2528L5.08241 13.728L5.82563 13.3895L4.24404 9.91441C4.16873 9.74894 4.18053 9.55687 4.27553 9.40186C4.37052 9.24685 4.53631 9.14915 4.71793 9.14114L5.41561 9.11037Z",
    fill: "currentColor"
  }));
}
function DiscordIcon() {
  return /* @__PURE__ */ React522.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React522.createElement("path", {
    d: "M13.545 2.907a13.227 13.227 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.19 12.19 0 0 0-3.658 0 8.258 8.258 0 0 0-.412-.833.051.051 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019c.308-.42.582-.863.818-1.329a.05.05 0 0 0-.01-.059.051.051 0 0 0-.018-.011 8.875 8.875 0 0 1-1.248-.595.05.05 0 0 1-.02-.066.051.051 0 0 1 .015-.019c.084-.063.168-.129.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.052.052 0 0 1 .053.007c.08.066.164.132.248.195a.051.051 0 0 1-.004.085 8.254 8.254 0 0 1-1.249.594.05.05 0 0 0-.03.03.052.052 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.235 13.235 0 0 0 4.001-2.02.049.049 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034 0 0 0-.02-.019Zm-8.198 7.307c-.789 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612Zm5.316 0c-.788 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612Z"
  }));
}
function LineIcon() {
  return /* @__PURE__ */ React532.createElement("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React532.createElement("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z"
  }));
}
var shapeShapes = [
  "rectangle",
  "ellipse",
  "triangle",
  "line"
];
var shapeShapeIcons = {
  ["rectangle"]: /* @__PURE__ */ React542.createElement(SquareIcon, null),
  ["ellipse"]: /* @__PURE__ */ React542.createElement(CircleIcon, null),
  ["triangle"]: /* @__PURE__ */ React542.createElement(VercelLogoIcon, null),
  ["line"]: /* @__PURE__ */ React542.createElement(LineIcon, null)
};
var statusSelector2 = (s9) => s9.appState.status;
var ShapesMenu = React542.memo(function ShapesMenu2({
  activeTool,
  isToolLocked
}) {
  const app = useTldrawApp();
  const status = app.useStore(statusSelector2);
  const [lastActiveTool, setLastActiveTool] = React542.useState("rectangle");
  React542.useEffect(() => {
    if (shapeShapes.includes(activeTool) && lastActiveTool !== activeTool) {
      setLastActiveTool(activeTool);
    }
  }, [activeTool]);
  const selectShapeTool = React542.useCallback(() => {
    app.selectTool(lastActiveTool);
  }, [activeTool, app]);
  const handleDoubleClick = React542.useCallback(() => {
    app.toggleToolLock();
  }, [app]);
  const handleKeyDown = React542.useCallback((e11) => {
    if (e11.key === " ") {
      if (app.shiftKey) {
        e11.preventDefault();
      }
    }
  }, []);
  const isActive = shapeShapes.includes(activeTool);
  return /* @__PURE__ */ React542.createElement(Root5, {
    dir: "ltr",
    onOpenChange: selectShapeTool
  }, /* @__PURE__ */ React542.createElement(Trigger, {
    dir: "ltr",
    asChild: true,
    id: "TD-PrimaryTools-Shapes"
  }, /* @__PURE__ */ React542.createElement(ToolButton, {
    disabled: isActive && app.shiftKey,
    variant: "primary",
    onDoubleClick: handleDoubleClick,
    isToolLocked: isActive && isToolLocked,
    isActive,
    onKeyDown: handleKeyDown
  }, shapeShapeIcons[lastActiveTool])), /* @__PURE__ */ React542.createElement(Content3, {
    asChild: true,
    dir: "ltr",
    side: "top",
    sideOffset: 12
  }, /* @__PURE__ */ React542.createElement(Panel, {
    side: "center"
  }, shapeShapes.map((shape, i8) => /* @__PURE__ */ React542.createElement(Tooltip2, {
    key: shape,
    label: shape[0].toUpperCase() + shape.slice(1),
    kbd: (4 + i8).toString(),
    id: `TD-PrimaryTools-Shapes-${shape}`
  }, /* @__PURE__ */ React542.createElement(Item3, {
    asChild: true
  }, /* @__PURE__ */ React542.createElement(ToolButton, {
    variant: "primary",
    onClick: () => {
      app.selectTool(shape);
      setLastActiveTool(shape);
    }
  }, shapeShapeIcons[shape])))))));
});
var activeToolSelector2 = (s9) => s9.appState.activeTool;
var toolLockedSelector = (s9) => s9.appState.isToolLocked;
var PrimaryTools = React55.memo(function PrimaryTools2() {
  const app = useTldrawApp();
  const activeTool = app.useStore(activeToolSelector2);
  const isToolLocked = app.useStore(toolLockedSelector);
  const selectSelectTool = React55.useCallback(() => {
    app.selectTool("select");
  }, [app]);
  const selectEraseTool = React55.useCallback(() => {
    app.selectTool("erase");
  }, [app]);
  const selectDrawTool = React55.useCallback(() => {
    app.selectTool("draw");
  }, [app]);
  const selectArrowTool = React55.useCallback(() => {
    app.selectTool("arrow");
  }, [app]);
  const selectTextTool = React55.useCallback(() => {
    app.selectTool("text");
  }, [app]);
  const selectStickyTool = React55.useCallback(() => {
    app.selectTool("sticky");
  }, [app]);
  return /* @__PURE__ */ React55.createElement(Panel, {
    side: "center",
    id: "TD-PrimaryTools"
  }, /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "1",
    label: "select",
    onClick: selectSelectTool,
    isActive: activeTool === "select",
    id: "TD-PrimaryTools-CursorArrow"
  }, /* @__PURE__ */ React55.createElement(CursorArrowIcon, null)), /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "2",
    label: "draw",
    onClick: selectDrawTool,
    isActive: activeTool === "draw",
    id: "TD-PrimaryTools-Pencil"
  }, /* @__PURE__ */ React55.createElement(Pencil1Icon, null)), /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "3",
    label: "eraser",
    onClick: selectEraseTool,
    isActive: activeTool === "erase",
    id: "TD-PrimaryTools-Eraser"
  }, /* @__PURE__ */ React55.createElement(EraserIcon, null)), /* @__PURE__ */ React55.createElement(ShapesMenu, {
    activeTool,
    isToolLocked
  }), /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "8",
    label: "arrow",
    onClick: selectArrowTool,
    isLocked: isToolLocked,
    isActive: activeTool === "arrow",
    id: "TD-PrimaryTools-ArrowTopRight"
  }, /* @__PURE__ */ React55.createElement(ArrowTopRightIcon, null)), /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "9",
    label: "text",
    onClick: selectTextTool,
    isLocked: isToolLocked,
    isActive: activeTool === "text",
    id: "TD-PrimaryTools-Text"
  }, /* @__PURE__ */ React55.createElement(TextIcon, null)), /* @__PURE__ */ React55.createElement(ToolButtonWithTooltip, {
    kbd: "0",
    label: "sticky",
    onClick: selectStickyTool,
    isActive: activeTool === "sticky",
    id: "TD-PrimaryTools-Pencil2"
  }, /* @__PURE__ */ React55.createElement(Pencil2Icon, null)));
});
var DMArrow = styled(Arrow4, { fill: "$panel", bp: breakpoints });
function DMItem(_a2) {
  var _b = _a2, {
    onSelect,
    id
  } = _b, rest = __objRest3(_b, [
    "onSelect",
    "id"
  ]);
  return /* @__PURE__ */ React56.createElement(Item3, {
    dir: "ltr",
    asChild: true,
    onSelect,
    id
  }, /* @__PURE__ */ React56.createElement(RowButton, __spreadValues4({}, rest)));
}
var preventEvent = (e11) => e11.preventDefault();
function DMCheckboxItem({
  checked,
  disabled = false,
  variant,
  onCheckedChange,
  kbd,
  id,
  children
}) {
  return /* @__PURE__ */ React57.createElement(CheckboxItem2, {
    dir: "ltr",
    onSelect: preventEvent,
    onCheckedChange,
    checked,
    disabled,
    asChild: true,
    id
  }, /* @__PURE__ */ React57.createElement(RowButton, {
    kbd,
    variant,
    hasIndicator: true
  }, children));
}
function DMContent({
  sideOffset = 8,
  children,
  align,
  variant,
  id
}) {
  return /* @__PURE__ */ React58.createElement(Content3, {
    dir: "ltr",
    align,
    sideOffset,
    onEscapeKeyDown: stopPropagation,
    asChild: true,
    id
  }, /* @__PURE__ */ React58.createElement(StyledContent2, {
    variant
  }, children));
}
var StyledContent2 = styled(MenuContent2, {
  width: "fit-content",
  height: "fit-content",
  minWidth: 0,
  maxHeight: "75vh",
  overflowY: "auto",
  "& *": {
    boxSizing: "border-box"
  },
  variants: {
    variant: {
      horizontal: {
        flexDirection: "row"
      },
      menu: {
        minWidth: 128
      }
    }
  }
});
var DMDivider = styled(Separator2, {
  backgroundColor: "$hover",
  height: 1,
  marginTop: "$2",
  marginRight: "-$2",
  marginBottom: "$2",
  marginLeft: "-$2"
});
var DMRadioItem = styled(RadioItem2, {
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  variants: {
    isActive: {
      true: {
        backgroundColor: "$selected",
        color: "$panel"
      },
      false: {}
    },
    bp: {
      mobile: {},
      small: {}
    }
  },
  compoundVariants: [
    {
      isActive: false,
      bp: "small",
      css: {
        "&:focus": {
          backgroundColor: "$hover"
        },
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});
function DMSubMenu({
  children,
  size,
  disabled = false,
  label,
  id
}) {
  return /* @__PURE__ */ React59.createElement("span", {
    id
  }, /* @__PURE__ */ React59.createElement(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ React59.createElement(TriggerItem, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ React59.createElement(RowButton, {
    disabled,
    hasArrow: true
  }, label)), /* @__PURE__ */ React59.createElement(Content3, {
    dir: "ltr",
    asChild: true,
    sideOffset: 2,
    alignOffset: -2
  }, /* @__PURE__ */ React59.createElement(MenuContent2, {
    size
  }, children, /* @__PURE__ */ React59.createElement(Arrow4, {
    offset: 13
  })))));
}
function DMTriggerIcon(_a2) {
  var _b = _a2, { id, children } = _b, rest = __objRest3(_b, ["id", "children"]);
  return /* @__PURE__ */ React60.createElement(Trigger, {
    asChild: true,
    id
  }, /* @__PURE__ */ React60.createElement(ToolButton, __spreadValues4({}, rest), children));
}
var Divider = styled("hr", {
  height: 1,
  marginTop: "$1",
  marginRight: "-$0",
  marginBottom: "$1",
  marginLeft: "-$0",
  border: "none",
  borderBottom: "1px solid $hover"
});
var selectedShapesCountSelector = (s9) => s9.document.pageStates[s9.appState.currentPageId].selectedIds.length;
var isAllLockedSelector = (s9) => {
  const page = s9.document.pages[s9.appState.currentPageId];
  const { selectedIds } = s9.document.pageStates[s9.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isLocked);
};
var isAllAspectLockedSelector = (s9) => {
  const page = s9.document.pages[s9.appState.currentPageId];
  const { selectedIds } = s9.document.pageStates[s9.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked);
};
var isAllGroupedSelector = (s9) => {
  const page = s9.document.pages[s9.appState.currentPageId];
  const selectedShapes = s9.document.pageStates[s9.appState.currentPageId].selectedIds.map((id) => page.shapes[id]);
  return selectedShapes.every((shape) => shape.children !== void 0 || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s9.appState.currentPageId);
};
var hasSelectionSelector = (s9) => {
  const { selectedIds } = s9.document.pageStates[s9.appState.currentPageId];
  return selectedIds.length > 0;
};
var hasMultipleSelectionSelector = (s9) => {
  const { selectedIds } = s9.document.pageStates[s9.appState.currentPageId];
  return selectedIds.length > 1;
};
function ActionButton() {
  const app = useTldrawApp();
  const isAllLocked = app.useStore(isAllLockedSelector);
  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector);
  const isAllGrouped = app.useStore(isAllGroupedSelector);
  const hasSelection = app.useStore(hasSelectionSelector);
  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector);
  const selectedShapesCount = app.useStore(selectedShapesCountSelector);
  const hasTwoOrMore = selectedShapesCount > 1;
  const hasThreeOrMore = selectedShapesCount > 2;
  const handleRotate = React61.useCallback(() => {
    app.rotate();
  }, [app]);
  const handleDuplicate = React61.useCallback(() => {
    app.duplicate();
  }, [app]);
  const handleToggleLocked = React61.useCallback(() => {
    app.toggleLocked();
  }, [app]);
  const handleToggleAspectRatio = React61.useCallback(() => {
    app.toggleAspectRatioLocked();
  }, [app]);
  const handleGroup = React61.useCallback(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = React61.useCallback(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = React61.useCallback(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = React61.useCallback(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = React61.useCallback(() => {
    app.moveToFront();
  }, [app]);
  const handleResetAngle = React61.useCallback(() => {
    app.setShapeProps({ rotation: 0 });
  }, [app]);
  const alignTop = React61.useCallback(() => {
    app.align("top");
  }, [app]);
  const alignCenterVertical = React61.useCallback(() => {
    app.align("centerVertical");
  }, [app]);
  const alignBottom = React61.useCallback(() => {
    app.align("bottom");
  }, [app]);
  const stretchVertically = React61.useCallback(() => {
    app.stretch("vertical");
  }, [app]);
  const distributeVertically = React61.useCallback(() => {
    app.distribute("vertical");
  }, [app]);
  const alignLeft = React61.useCallback(() => {
    app.align("left");
  }, [app]);
  const alignCenterHorizontal = React61.useCallback(() => {
    app.align("centerHorizontal");
  }, [app]);
  const alignRight = React61.useCallback(() => {
    app.align("right");
  }, [app]);
  const stretchHorizontally = React61.useCallback(() => {
    app.stretch("horizontal");
  }, [app]);
  const distributeHorizontally = React61.useCallback(() => {
    app.distribute("horizontal");
  }, [app]);
  const handleMenuOpenChange = React61.useCallback((open) => {
    app.setMenuOpen(open);
  }, [app]);
  return /* @__PURE__ */ React61.createElement(Root5, {
    dir: "ltr",
    onOpenChange: handleMenuOpenChange
  }, /* @__PURE__ */ React61.createElement(Trigger, {
    dir: "ltr",
    asChild: true,
    id: "TD-Tools-Dots"
  }, /* @__PURE__ */ React61.createElement(ToolButton, {
    variant: "circle"
  }, /* @__PURE__ */ React61.createElement(DotsHorizontalIcon, null))), /* @__PURE__ */ React61.createElement(DMContent, {
    sideOffset: 16
  }, /* @__PURE__ */ React61.createElement(React61.Fragment, null, /* @__PURE__ */ React61.createElement(ButtonsRow, null, /* @__PURE__ */ React61.createElement(ToolButton, {
    variant: "icon",
    disabled: !hasSelection,
    onClick: handleDuplicate
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Duplicate",
    kbd: `#D`,
    id: "TD-Tools-Copy"
  }, /* @__PURE__ */ React61.createElement(CopyIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleRotate
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Rotate",
    id: "TD-Tools-Rotate"
  }, /* @__PURE__ */ React61.createElement(RotateCounterClockwiseIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleToggleLocked
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Toggle Locked",
    kbd: `#L`,
    id: "TD-Tools-Lock"
  }, isAllLocked ? /* @__PURE__ */ React61.createElement(LockClosedIcon, null) : /* @__PURE__ */ React61.createElement(LockOpen1Icon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleToggleAspectRatio
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Toggle Aspect Ratio Lock",
    id: "TD-Tools-AspectRatio"
  }, isAllAspectLocked ? /* @__PURE__ */ React61.createElement(AspectRatioIcon, null) : /* @__PURE__ */ React61.createElement(BoxIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection || !isAllGrouped && !hasMultipleSelection,
    onClick: handleGroup
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Group",
    kbd: `#G`,
    id: "TD-Tools-Group"
  }, /* @__PURE__ */ React61.createElement(GroupIcon, null)))), /* @__PURE__ */ React61.createElement(ButtonsRow, null, /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveToBack
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Move to Back",
    kbd: `#\u21E7[`,
    id: "TD-Tools-PinBottom"
  }, /* @__PURE__ */ React61.createElement(PinBottomIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveBackward
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Move Backward",
    kbd: `#[`,
    id: "TD-Tools-ArrowDown"
  }, /* @__PURE__ */ React61.createElement(ArrowDownIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveForward
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Move Forward",
    kbd: `#]`,
    id: "TD-Tools-ArrowUp"
  }, /* @__PURE__ */ React61.createElement(ArrowUpIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveToFront
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Move to Front",
    kbd: `#\u21E7]`,
    id: "TD-Tools-PinTop"
  }, /* @__PURE__ */ React61.createElement(PinTopIcon, null))), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasSelection,
    onClick: handleResetAngle
  }, /* @__PURE__ */ React61.createElement(Tooltip2, {
    label: "Reset Angle",
    id: "TD-Tools-ResetAngle"
  }, /* @__PURE__ */ React61.createElement(AngleIcon, null)))), /* @__PURE__ */ React61.createElement(Divider, null), /* @__PURE__ */ React61.createElement(ButtonsRow, null, /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignLeft,
    id: "TD-Tools-AlignLeft"
  }, /* @__PURE__ */ React61.createElement(AlignLeftIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignCenterHorizontal,
    id: "TD-Tools-AlignCenterHorizontal"
  }, /* @__PURE__ */ React61.createElement(AlignCenterHorizontallyIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignRight,
    id: "TD-Tools-AlignRight"
  }, /* @__PURE__ */ React61.createElement(AlignRightIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: stretchHorizontally,
    id: "TD-Tools-StretchHorizontal"
  }, /* @__PURE__ */ React61.createElement(StretchHorizontallyIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasThreeOrMore,
    onClick: distributeHorizontally,
    id: "TD-Tools-SpaceEvenlyHorizontal"
  }, /* @__PURE__ */ React61.createElement(SpaceEvenlyHorizontallyIcon, null))), /* @__PURE__ */ React61.createElement(ButtonsRow, null, /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignTop,
    id: "TD-Tools-AlignTop"
  }, /* @__PURE__ */ React61.createElement(AlignTopIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignCenterVertical,
    id: "TD-Tools-AlignCenterVertical"
  }, /* @__PURE__ */ React61.createElement(AlignCenterVerticallyIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignBottom,
    id: "TD-Tools-AlignBottom"
  }, /* @__PURE__ */ React61.createElement(AlignBottomIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: stretchVertically,
    id: "TD-Tools-tretchVertical"
  }, /* @__PURE__ */ React61.createElement(StretchVerticallyIcon, null)), /* @__PURE__ */ React61.createElement(ToolButton, {
    disabled: !hasThreeOrMore,
    onClick: distributeVertically,
    id: "TD-Tools-SpaceEvenlyVertical"
  }, /* @__PURE__ */ React61.createElement(SpaceEvenlyVerticallyIcon, null))))));
}
var ButtonsRow = styled("div", {
  position: "relative",
  display: "flex",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  outline: "none",
  alignItems: "center",
  justifyContent: "flex-start",
  padding: 0
});
function DeleteButton() {
  const app = useTldrawApp();
  const handleDelete = React622.useCallback(() => {
    app.delete();
  }, [app]);
  const hasSelection = app.useStore((s9) => s9.appState.status === "idle" && s9.document.pageStates[s9.appState.currentPageId].selectedIds.length > 0);
  return /* @__PURE__ */ React622.createElement(Tooltip2, {
    label: "Delete",
    kbd: "\u232B",
    id: "TD-Delete"
  }, /* @__PURE__ */ React622.createElement(ToolButton, {
    variant: "circle",
    disabled: !hasSelection,
    onSelect: handleDelete
  }, /* @__PURE__ */ React622.createElement(TrashIcon, null)));
}
var isDebugModeSelector = (s9) => s9.settings.isDebugMode;
var ToolsPanel = React63.memo(function ToolsPanel2({ onBlur }) {
  const app = useTldrawApp();
  const isDebugMode = app.useStore(isDebugModeSelector);
  return /* @__PURE__ */ React63.createElement(StyledToolsPanelContainer, {
    onBlur
  }, /* @__PURE__ */ React63.createElement(StyledCenterWrap, {
    id: "TD-Tools"
  }, /* @__PURE__ */ React63.createElement(BackToContent, null), /* @__PURE__ */ React63.createElement(StyledPrimaryTools, null, /* @__PURE__ */ React63.createElement(ActionButton, null), /* @__PURE__ */ React63.createElement(PrimaryTools, null), /* @__PURE__ */ React63.createElement(DeleteButton, null))), isDebugMode && /* @__PURE__ */ React63.createElement(StyledStatusWrap, null, /* @__PURE__ */ React63.createElement(StatusBar, null)));
});
var StyledToolsPanelContainer = styled("div", {
  position: "absolute",
  bottom: 0,
  left: 0,
  right: 0,
  width: "100%",
  minWidth: 0,
  maxWidth: "100%",
  display: "grid",
  gridTemplateColumns: "auto auto auto",
  gridTemplateRows: "auto auto",
  justifyContent: "space-between",
  padding: "0",
  gap: "$4",
  zIndex: 200,
  pointerEvents: "none",
  "& > div > *": {
    pointerEvents: "all"
  }
});
var StyledCenterWrap = styled("div", {
  gridRow: 1,
  gridColumn: 2,
  display: "flex",
  width: "fit-content",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  gap: "$4"
});
var StyledStatusWrap = styled("div", {
  gridRow: 2,
  gridColumn: "1 / span 3"
});
var StyledPrimaryTools = styled("div", {
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: "$2"
});
var settingsSelector = (s9) => s9.settings;
function PreferencesMenu() {
  const app = useTldrawApp();
  const settings = app.useStore(settingsSelector);
  const toggleDebugMode = React64.useCallback(() => {
    app.setSetting("isDebugMode", (v6) => !v6);
  }, [app]);
  const toggleDarkMode = React64.useCallback(() => {
    app.setSetting("isDarkMode", (v6) => !v6);
  }, [app]);
  const toggleFocusMode = React64.useCallback(() => {
    app.setSetting("isFocusMode", (v6) => !v6);
  }, [app]);
  const toggleRotateHandle = React64.useCallback(() => {
    app.setSetting("showRotateHandles", (v6) => !v6);
  }, [app]);
  const toggleGrid = React64.useCallback(() => {
    app.setSetting("showGrid", (v6) => !v6);
  }, [app]);
  const toggleBoundShapesHandle = React64.useCallback(() => {
    app.setSetting("showBindingHandles", (v6) => !v6);
  }, [app]);
  const toggleisSnapping = React64.useCallback(() => {
    app.setSetting("isSnapping", (v6) => !v6);
  }, [app]);
  const toggleCloneControls = React64.useCallback(() => {
    app.setSetting("showCloneHandles", (v6) => !v6);
  }, [app]);
  const toggleCadSelectMode = React64.useCallback(() => {
    app.setSetting("isCadSelectMode", (v6) => !v6);
  }, [app]);
  return /* @__PURE__ */ React64.createElement(DMSubMenu, {
    label: "Preferences",
    id: "TD-MenuItem-Preferences"
  }, /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.isDarkMode,
    onCheckedChange: toggleDarkMode,
    kbd: "#\u21E7D",
    id: "TD-MenuItem-Preferences-Dark_Mode"
  }, "Dark Mode"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.isFocusMode,
    onCheckedChange: toggleFocusMode,
    kbd: "#.",
    id: "TD-MenuItem-Preferences-Focus_Mode"
  }, "Focus Mode"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.isDebugMode,
    onCheckedChange: toggleDebugMode,
    id: "TD-MenuItem-Preferences-Debug_Mode"
  }, "Debug Mode"), /* @__PURE__ */ React64.createElement(DMDivider, null), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.showGrid,
    onCheckedChange: toggleGrid,
    kbd: "#\u21E7G",
    id: "TD-MenuItem-Preferences-Grid"
  }, "Show Grid"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.isCadSelectMode,
    onCheckedChange: toggleCadSelectMode,
    id: "TD-MenuItem-Preferences-Cad_Selection"
  }, "Use CAD Selection"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.isSnapping,
    onCheckedChange: toggleisSnapping,
    id: "TD-MenuItem-Preferences-Always_Show_Snaps"
  }, "Always Show Snaps"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.showRotateHandles,
    onCheckedChange: toggleRotateHandle,
    id: "TD-MenuItem-Preferences-Rotate_Handles"
  }, "Rotate Handles"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.showBindingHandles,
    onCheckedChange: toggleBoundShapesHandle,
    id: "TD-MenuItem-Preferences-Binding_Handles"
  }, "Binding Handles"), /* @__PURE__ */ React64.createElement(DMCheckboxItem, {
    checked: settings.showCloneHandles,
    onCheckedChange: toggleCloneControls,
    id: "TD-MenuItem-Preferences-Clone_Handles"
  }, "Clone Handles"));
}
function HeartIcon() {
  return /* @__PURE__ */ React65.createElement("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React65.createElement("path", {
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
  }));
}
var numberOfSelectedIdsSelector = (s9) => {
  return s9.document.pageStates[s9.appState.currentPageId].selectedIds.length;
};
var disableAssetsSelector = (s9) => {
  return s9.appState.disableAssets;
};
var Menu2 = React66.memo(function Menu22({ showSponsorLink, readOnly }) {
  const app = useTldrawApp();
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector);
  const disableAssets = app.useStore(disableAssetsSelector);
  const [_5, setForce] = React66.useState(0);
  React66.useEffect(() => setForce(1), []);
  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs } = useFileSystemHandlers();
  const handleExportPNG = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("png");
  }), [app]);
  const handleExportJPG = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("jpeg");
  }), [app]);
  const handleExportWEBP = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("webp");
  }), [app]);
  const handleExportPDF = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("pdf");
  }), [app]);
  const handleExportSVG = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("svg");
  }), [app]);
  const handleExportJSON = React66.useCallback(() => __async2(this, null, function* () {
    yield app.exportAllShapesAs("json");
  }), [app]);
  const handleSignIn = React66.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = app.callbacks).onSignIn) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const handleSignOut = React66.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = app.callbacks).onSignOut) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const handleCut = React66.useCallback(() => {
    app.cut();
  }, [app]);
  const handleCopy = React66.useCallback(() => {
    app.copy();
  }, [app]);
  const handlePaste = React66.useCallback(() => {
    app.paste();
  }, [app]);
  const handleCopySvg = React66.useCallback(() => {
    app.copySvg();
  }, [app]);
  const handleCopyJson = React66.useCallback(() => {
    app.copyJson();
  }, [app]);
  const handleSelectAll = React66.useCallback(() => {
    app.selectAll();
  }, [app]);
  const handleSelectNone = React66.useCallback(() => {
    app.selectNone();
  }, [app]);
  const handleUploadMedia = React66.useCallback(() => {
    app.openAsset();
  }, [app]);
  const handleZoomTo100 = React66.useCallback(() => {
    app.zoomTo(1);
  }, [app]);
  const showFileMenu = app.callbacks.onNewProject || app.callbacks.onOpenProject || app.callbacks.onSaveProject || app.callbacks.onSaveProjectAs || app.callbacks.onExport;
  const showSignInOutMenu = app.callbacks.onSignIn || app.callbacks.onSignOut || showSponsorLink;
  const hasSelection = numberOfSelectedIds > 0;
  return /* @__PURE__ */ React66.createElement(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ React66.createElement(DMTriggerIcon, {
    isSponsor: showSponsorLink,
    id: "TD-MenuIcon"
  }, /* @__PURE__ */ React66.createElement(HamburgerMenuIcon, null)), /* @__PURE__ */ React66.createElement(DMContent, {
    variant: "menu",
    id: "TD-Menu"
  }, showFileMenu && /* @__PURE__ */ React66.createElement(DMSubMenu, {
    label: "File...",
    id: "TD-MenuItem-File"
  }, app.callbacks.onNewProject && /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: onNewProject,
    kbd: "#N",
    id: "TD-MenuItem-File-New_Project"
  }, "New Project"), app.callbacks.onOpenProject && /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: onOpenProject,
    kbd: "#O",
    id: "TD-MenuItem-File-Open"
  }, "Open..."), app.callbacks.onSaveProject && /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: onSaveProject,
    kbd: "#S",
    id: "TD-MenuItem-File-Save"
  }, "Save"), app.callbacks.onSaveProjectAs && /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: onSaveProjectAs,
    kbd: "#\u21E7S",
    id: "TD-MenuItem-File-Save_As"
  }, "Save As..."), app.callbacks.onExport && /* @__PURE__ */ React66.createElement(React66.Fragment, null, /* @__PURE__ */ React66.createElement(Divider, null), /* @__PURE__ */ React66.createElement(DMSubMenu, {
    label: "Export",
    size: "small",
    id: "TD-MenuItem-File-Export"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleExportPNG,
    id: "TD-MenuItem-File-Export-PNG"
  }, "PNG"), /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleExportJPG,
    id: "TD-MenuItem-File-Export-JPG"
  }, "JPG"), /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleExportWEBP,
    id: "TD-MenuItem-File-Export-WEBP"
  }, "WEBP"), /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleExportSVG,
    id: "TD-MenuItem-File-Export-SVG"
  }, "SVG"), /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleExportJSON,
    id: "TD-MenuItem-File-Export-JSON"
  }, "JSON"))), !disableAssets && /* @__PURE__ */ React66.createElement(React66.Fragment, null, /* @__PURE__ */ React66.createElement(Divider, null), /* @__PURE__ */ React66.createElement(DMItem, {
    onClick: handleUploadMedia,
    kbd: "#U",
    id: "TD-MenuItem-File-Upload_Media"
  }, "Upload Media"))), !readOnly && /* @__PURE__ */ React66.createElement(React66.Fragment, null, /* @__PURE__ */ React66.createElement(DMSubMenu, {
    label: "Edit...",
    id: "TD-MenuItem-Edit"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.undo,
    kbd: "#Z",
    id: "TD-MenuItem-Edit-Undo"
  }, "Undo"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.redo,
    kbd: "#\u21E7Z",
    id: "TD-MenuItem-Edit-Redo"
  }, "Redo"), /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCut,
    kbd: "#X",
    id: "TD-MenuItem-Edit-Cut"
  }, "Cut"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopy,
    kbd: "#C",
    id: "TD-MenuItem-Edit-Copy"
  }, "Copy"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: handlePaste,
    kbd: "#V",
    id: "TD-MenuItem-Edit-Paste"
  }, "Paste"), /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopySvg,
    kbd: "#\u21E7C",
    id: "TD-MenuItem-Edit-Copy_as_SVG"
  }, "Copy as SVG"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopyJson,
    id: "TD-MenuItem-Edit-Copy_as_JSON"
  }, "Copy as JSON"), /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: handleSelectAll,
    kbd: "#A",
    id: "TD-MenuItem-Select_All"
  }, "Select All"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: handleSelectNone,
    id: "TD-MenuItem-Select_None"
  }, "Select None"))), /* @__PURE__ */ React66.createElement(DMSubMenu, {
    label: "View",
    id: "TD-MenuItem-Edit"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomIn,
    kbd: "#+",
    id: "TD-MenuItem-View-ZoomIn"
  }, "Zoom In"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomOut,
    kbd: "#-",
    id: "TD-MenuItem-View-ZoomOut"
  }, "Zoom Out"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: handleZoomTo100,
    kbd: "\u21E7+0",
    id: "TD-MenuItem-View-ZoomTo100"
  }, "Zoom to 100%"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToFit,
    kbd: "\u21E7+1",
    id: "TD-MenuItem-View-ZoomToFit"
  }, "Zoom to Fit"), /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToSelection,
    kbd: "\u21E7+2",
    id: "TD-MenuItem-View-ZoomToSelection"
  }, "Zoom to Selection")), /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ React66.createElement(PreferencesMenu, null), /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ React66.createElement("a", {
    href: "https://github.com/Tldraw/Tldraw",
    target: "_blank",
    rel: "nofollow"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    id: "TD-MenuItem-Github"
  }, "GitHub", /* @__PURE__ */ React66.createElement(SmallIcon, null, /* @__PURE__ */ React66.createElement(GitHubLogoIcon, null)))), /* @__PURE__ */ React66.createElement("a", {
    href: "https://twitter.com/Tldraw",
    target: "_blank",
    rel: "nofollow"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    id: "TD-MenuItem-Twitter"
  }, "Twitter", /* @__PURE__ */ React66.createElement(SmallIcon, null, /* @__PURE__ */ React66.createElement(TwitterLogoIcon, null)))), /* @__PURE__ */ React66.createElement("a", {
    href: "https://discord.gg/SBBEVCA4PG",
    target: "_blank",
    rel: "nofollow"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    id: "TD-MenuItem-Discord"
  }, "Discord", /* @__PURE__ */ React66.createElement(SmallIcon, null, /* @__PURE__ */ React66.createElement(DiscordIcon, null)))), showSponsorLink && /* @__PURE__ */ React66.createElement("a", {
    href: "https://github.com/sponsors/steveruizok",
    target: "_blank",
    rel: "nofollow"
  }, /* @__PURE__ */ React66.createElement(DMItem, {
    isSponsor: true,
    id: "TD-MenuItem-Become_a_Sponsor"
  }, "Become a Sponsor", " ", /* @__PURE__ */ React66.createElement(SmallIcon, null, /* @__PURE__ */ React66.createElement(HeartIcon, null)))), showSignInOutMenu && /* @__PURE__ */ React66.createElement(React66.Fragment, null, /* @__PURE__ */ React66.createElement(DMDivider, {
    dir: "ltr"
  }), " ", app.callbacks.onSignIn && /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: handleSignIn,
    id: "TD-MenuItem-Sign_in"
  }, "Sign In"), app.callbacks.onSignOut && /* @__PURE__ */ React66.createElement(DMItem, {
    onSelect: handleSignOut,
    id: "TD-MenuItem-Sign_out"
  }, "Sign Out", /* @__PURE__ */ React66.createElement(SmallIcon, null, /* @__PURE__ */ React66.createElement(ExitIcon, null))))));
});
var IconButton = styled("button", {
  position: "relative",
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  fontSize: "$0",
  color: "$text",
  cursor: "pointer",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  },
  "&:disabled": {
    opacity: "0.5"
  },
  "& > span": {
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center"
  },
  variants: {
    bp: {
      mobile: {
        backgroundColor: "transparent"
      },
      small: {
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    },
    size: {
      small: {
        height: 32,
        width: 32,
        "& svg:nth-of-type(1)": {
          height: "16px",
          width: "16px"
        }
      },
      medium: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "18px",
          width: "18px"
        }
      },
      large: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "20px",
          width: "20px"
        }
      }
    },
    isActive: {
      true: {
        color: "$selected"
      }
    }
  }
});
var TextField = ({ value, onChange: onChange2, placeholder = "", icon }) => {
  return /* @__PURE__ */ React67.createElement(StyledInputWrapper, null, /* @__PURE__ */ React67.createElement(StyledInput, {
    value,
    onChange: onChange2,
    placeholder
  }), icon ? /* @__PURE__ */ React67.createElement(StyledInputIcon, null, icon) : null);
};
var StyledInputWrapper = styled("div", {
  position: "relative",
  width: "100%",
  height: "min-content"
});
var StyledInput = styled("input", {
  color: "$text",
  border: "none",
  textAlign: "left",
  width: "100%",
  paddingLeft: "$3",
  paddingRight: "$6",
  height: "32px",
  outline: "none",
  fontFamily: "$ui",
  fontSize: "$1",
  "&:focus": {
    backgroundColor: "$hover"
  },
  borderRadius: "$2"
});
var StyledInputIcon = styled(SmallIcon, {
  top: 0,
  right: 0,
  position: "absolute",
  paddingLeft: "$3",
  paddingRight: "$3",
  pointerEvents: "none"
});
var canDeleteSelector = (s9) => {
  return Object.keys(s9.document.pages).length > 1;
};
function PageOptionsDialog({ page, onOpen, onClose }) {
  const app = useTldrawApp();
  const [isOpen, setIsOpen] = React68.useState(false);
  const [pageName, setPageName] = React68.useState(page.name || "Page");
  const canDelete = app.useStore(canDeleteSelector);
  const rInput = React68.useRef(null);
  const handleDuplicate = React68.useCallback(() => {
    app.duplicatePage(page.id);
    onClose == null ? void 0 : onClose();
  }, [app]);
  const handleDelete = React68.useCallback(() => {
    if (window.confirm(`Are you sure you want to delete this page?`)) {
      app.deletePage(page.id);
      onClose == null ? void 0 : onClose();
    }
  }, [app]);
  const handleOpenChange = React68.useCallback((isOpen2) => {
    setIsOpen(isOpen2);
    if (isOpen2) {
      onOpen == null ? void 0 : onOpen();
      return;
    }
  }, [app]);
  const close = React68.useCallback(() => setIsOpen(false), []);
  function stopPropagation2(e11) {
    e11.stopPropagation();
  }
  function handleRename(event) {
    setPageName(event.target.value);
    app.renamePage(page.id, event.target.value || page.name || "Page");
  }
  React68.useEffect(() => {
    if (isOpen) {
      requestAnimationFrame(() => {
        const elm = rInput.current;
        if (elm) {
          elm.focus();
          elm.select();
        }
      });
    }
  }, [isOpen]);
  return /* @__PURE__ */ React68.createElement(Root9, {
    open: isOpen,
    onOpenChange: handleOpenChange
  }, /* @__PURE__ */ React68.createElement(Trigger4, {
    asChild: true,
    "data-shy": "true"
  }, /* @__PURE__ */ React68.createElement(IconButton, {
    bp: breakpoints
  }, /* @__PURE__ */ React68.createElement(SmallIcon, null, /* @__PURE__ */ React68.createElement(MixerVerticalIcon, null)))), /* @__PURE__ */ React68.createElement(Portal3, null, /* @__PURE__ */ React68.createElement(StyledDialogOverlay, {
    onPointerDown: close
  }), /* @__PURE__ */ React68.createElement(StyledDialogContent, {
    dir: "ltr",
    onKeyDown: stopPropagation2,
    onKeyUp: stopPropagation2
  }, /* @__PURE__ */ React68.createElement(TextField, {
    placeholder: "Page name",
    value: pageName,
    onChange: handleRename,
    icon: /* @__PURE__ */ React68.createElement(Pencil1Icon, null)
  }), /* @__PURE__ */ React68.createElement(Divider, null), /* @__PURE__ */ React68.createElement(DialogAction, {
    onSelect: handleDuplicate
  }, "Duplicate"), /* @__PURE__ */ React68.createElement(DialogAction, {
    disabled: !canDelete,
    onSelect: handleDelete
  }, "Delete"), /* @__PURE__ */ React68.createElement(Divider, null), /* @__PURE__ */ React68.createElement(Cancel, {
    asChild: true
  }, /* @__PURE__ */ React68.createElement(RowButton, null, "Cancel")))));
}
var StyledDialogContent = styled(Content6, {
  position: "fixed",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  minWidth: 240,
  maxWidth: "fit-content",
  maxHeight: "85vh",
  marginTop: "-5vh",
  pointerEvents: "all",
  backgroundColor: "$panel",
  padding: "$0",
  borderRadius: "$2",
  font: "$ui",
  "&:focus": {
    outline: "none"
  }
});
var StyledDialogOverlay = styled(Overlay4, {
  backgroundColor: "rgba(0, 0, 0, .15)",
  position: "fixed",
  pointerEvents: "all",
  inset: 0
});
function DialogAction(_a2) {
  var _b = _a2, {
    onSelect
  } = _b, rest = __objRest3(_b, [
    "onSelect"
  ]);
  return /* @__PURE__ */ React68.createElement(Action, {
    asChild: true,
    onClick: onSelect,
    onSelect
  }, /* @__PURE__ */ React68.createElement(RowButton, __spreadValues4({}, rest)));
}
var sortedSelector = (s9) => Object.values(s9.document.pages).sort((a7, b7) => (a7.childIndex || 0) - (b7.childIndex || 0));
var currentPageNameSelector = (s9) => s9.document.pages[s9.appState.currentPageId].name;
var currentPageIdSelector = (s9) => s9.document.pages[s9.appState.currentPageId].id;
function PageMenu() {
  const app = useTldrawApp();
  const rIsOpen = React69.useRef(false);
  const [isOpen, setIsOpen] = React69.useState(false);
  React69.useEffect(() => {
    if (rIsOpen.current !== isOpen) {
      rIsOpen.current = isOpen;
    }
  }, [isOpen]);
  const handleClose = React69.useCallback(() => {
    setIsOpen(false);
  }, [setIsOpen]);
  const handleOpenChange = React69.useCallback((isOpen2) => {
    if (rIsOpen.current !== isOpen2) {
      setIsOpen(isOpen2);
    }
  }, [setIsOpen]);
  const currentPageName = app.useStore(currentPageNameSelector);
  return /* @__PURE__ */ React69.createElement(Root5, {
    dir: "ltr",
    open: isOpen,
    onOpenChange: handleOpenChange
  }, /* @__PURE__ */ React69.createElement(Trigger, {
    dir: "ltr",
    asChild: true,
    id: "TD-Page"
  }, /* @__PURE__ */ React69.createElement(ToolButton, {
    variant: "text"
  }, currentPageName || "Page")), /* @__PURE__ */ React69.createElement(DMContent, {
    variant: "menu",
    align: "start"
  }, isOpen && /* @__PURE__ */ React69.createElement(PageMenuContent, {
    onClose: handleClose
  })));
}
function PageMenuContent({ onClose }) {
  const app = useTldrawApp();
  const sortedPages = app.useStore(sortedSelector);
  const currentPageId = app.useStore(currentPageIdSelector);
  const handleCreatePage = React69.useCallback(() => {
    app.createPage();
  }, [app]);
  const handleChangePage = React69.useCallback((id) => {
    onClose();
    app.changePage(id);
  }, [app]);
  return /* @__PURE__ */ React69.createElement(React69.Fragment, null, /* @__PURE__ */ React69.createElement(RadioGroup2, {
    dir: "ltr",
    value: currentPageId,
    onValueChange: handleChangePage
  }, sortedPages.map((page) => /* @__PURE__ */ React69.createElement(ButtonWithOptions, {
    key: page.id
  }, /* @__PURE__ */ React69.createElement(RadioItem2, {
    title: page.name || "Page",
    value: page.id,
    key: page.id,
    asChild: true
  }, /* @__PURE__ */ React69.createElement(PageButton, null, /* @__PURE__ */ React69.createElement("span", null, page.name || "Page"), /* @__PURE__ */ React69.createElement(ItemIndicator2, null, /* @__PURE__ */ React69.createElement(SmallIcon, null, /* @__PURE__ */ React69.createElement(CheckIcon, null))))), /* @__PURE__ */ React69.createElement(PageOptionsDialog, {
    page,
    onClose
  })))), /* @__PURE__ */ React69.createElement(DMDivider, null), /* @__PURE__ */ React69.createElement(Item3, {
    onSelect: handleCreatePage,
    asChild: true
  }, /* @__PURE__ */ React69.createElement(RowButton, null, /* @__PURE__ */ React69.createElement("span", null, "Create Page"), /* @__PURE__ */ React69.createElement(SmallIcon, null, /* @__PURE__ */ React69.createElement(PlusIcon, null)))));
}
var ButtonWithOptions = styled("div", {
  display: "grid",
  gridTemplateColumns: "1fr auto",
  gridAutoFlow: "column",
  '& > *[data-shy="true"]': {
    opacity: 0
  },
  '&:hover > *[data-shy="true"]': {
    opacity: 1
  }
});
var PageButton = styled(RowButton, {
  minWidth: 128
});
var zoomSelector = (s9) => s9.document.pageStates[s9.appState.currentPageId].camera.zoom;
var ZoomMenu = React70.memo(function ZoomMenu2() {
  const app = useTldrawApp();
  const zoom = app.useStore(zoomSelector);
  return /* @__PURE__ */ React70.createElement(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ React70.createElement(Trigger, {
    dir: "ltr",
    asChild: true,
    id: "TD-Zoom"
  }, /* @__PURE__ */ React70.createElement(FixedWidthToolButton, {
    onDoubleClick: app.resetZoom,
    variant: "text"
  }, Math.round(zoom * 100), "%")), /* @__PURE__ */ React70.createElement(DMContent, {
    align: "end"
  }, /* @__PURE__ */ React70.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomIn,
    kbd: "#+",
    id: "TD-Zoom-Zoom_In"
  }, "Zoom In"), /* @__PURE__ */ React70.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomOut,
    kbd: "#\u2212",
    id: "TD-Zoom-Zoom_Out"
  }, "Zoom Out"), /* @__PURE__ */ React70.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.resetZoom,
    kbd: "\u21E70",
    id: "TD-Zoom-Zoom_To_100%"
  }, "To 100%"), /* @__PURE__ */ React70.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToFit,
    kbd: "\u21E71",
    id: "TD-Zoom-To_Fit"
  }, "To Fit"), /* @__PURE__ */ React70.createElement(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToSelection,
    kbd: "\u21E72",
    id: "TD-Zoom-To_Selection"
  }, "To Selection")));
});
var FixedWidthToolButton = styled(ToolButton, {
  minWidth: 56
});
var currentStyleSelector = (s9) => s9.appState.currentStyle;
var selectedIdsSelector = (s9) => s9.document.pageStates[s9.appState.currentPageId].selectedIds;
var STYLE_KEYS = Object.keys(defaultTextStyle);
var DASH_ICONS = {
  ["draw"]: /* @__PURE__ */ React71.createElement(DashDrawIcon, null),
  ["solid"]: /* @__PURE__ */ React71.createElement(DashSolidIcon, null),
  ["dashed"]: /* @__PURE__ */ React71.createElement(DashDashedIcon, null),
  ["dotted"]: /* @__PURE__ */ React71.createElement(DashDottedIcon, null)
};
var SIZE_ICONS = {
  ["small"]: /* @__PURE__ */ React71.createElement(SizeSmallIcon, null),
  ["medium"]: /* @__PURE__ */ React71.createElement(SizeMediumIcon, null),
  ["large"]: /* @__PURE__ */ React71.createElement(SizeLargeIcon, null)
};
var ALIGN_ICONS = {
  ["start"]: /* @__PURE__ */ React71.createElement(TextAlignLeftIcon, null),
  ["middle"]: /* @__PURE__ */ React71.createElement(TextAlignCenterIcon, null),
  ["end"]: /* @__PURE__ */ React71.createElement(TextAlignRightIcon, null),
  ["justify"]: /* @__PURE__ */ React71.createElement(TextAlignJustifyIcon, null)
};
var themeSelector = (s9) => s9.settings.isDarkMode ? "dark" : "light";
var optionsSelector = (s9) => {
  const { activeTool, currentPageId: pageId } = s9.appState;
  switch (activeTool) {
    case "select": {
      const page = s9.document.pages[pageId];
      let hasText = false;
      let hasLabel = false;
      for (const id of s9.document.pageStates[pageId].selectedIds) {
        if ("text" in page.shapes[id])
          hasText = true;
        if ("label" in page.shapes[id])
          hasLabel = true;
      }
      return hasText ? "text" : hasLabel ? "label" : "";
    }
    case "text": {
      return "text";
    }
    case "rectangle": {
      return "label";
    }
    case "ellipse": {
      return "label";
    }
    case "triangle": {
      return "label";
    }
    case "arrow": {
      return "label";
    }
    case "line": {
      return "label";
    }
  }
  return false;
};
var StyleMenu = React71.memo(function ColorMenu() {
  const app = useTldrawApp();
  const theme = app.useStore(themeSelector);
  const options2 = app.useStore(optionsSelector);
  const currentStyle = app.useStore(currentStyleSelector);
  const selectedIds = app.useStore(selectedIdsSelector);
  const [displayedStyle, setDisplayedStyle] = React71.useState(currentStyle);
  const rDisplayedStyle = React71.useRef(currentStyle);
  React71.useEffect(() => {
    const {
      appState: { currentStyle: currentStyle2 },
      page,
      selectedIds: selectedIds2
    } = app;
    let commonStyle = {};
    if (selectedIds2.length <= 0) {
      commonStyle = currentStyle2;
    } else {
      const overrides = /* @__PURE__ */ new Set([]);
      app.selectedIds.map((id) => page.shapes[id]).forEach((shape) => {
        STYLE_KEYS.forEach((key) => {
          if (overrides.has(key))
            return;
          if (commonStyle[key] === void 0) {
            commonStyle[key] = shape.style[key];
          } else {
            if (commonStyle[key] === shape.style[key])
              return;
            commonStyle[key] = shape.style[key];
            overrides.add(key);
          }
        });
      });
    }
    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {
      rDisplayedStyle.current = commonStyle;
      setDisplayedStyle(commonStyle);
    }
  }, [currentStyle, selectedIds]);
  const handleToggleFilled = React71.useCallback((checked) => {
    app.style({ isFilled: checked });
  }, []);
  const handleDashChange = React71.useCallback((value) => {
    app.style({ dash: value });
  }, []);
  const handleSizeChange = React71.useCallback((value) => {
    app.style({ size: value });
  }, []);
  const handleFontChange = React71.useCallback((value) => {
    app.style({ font: value });
  }, []);
  const handleTextAlignChange = React71.useCallback((value) => {
    app.style({ textAlign: value });
  }, []);
  const handleMenuOpenChange = React71.useCallback((open) => {
    app.setMenuOpen(open);
  }, [app]);
  return /* @__PURE__ */ React71.createElement(Root5, {
    dir: "ltr",
    onOpenChange: handleMenuOpenChange
  }, /* @__PURE__ */ React71.createElement(Trigger, {
    asChild: true,
    id: "TD-Styles"
  }, /* @__PURE__ */ React71.createElement(ToolButton, {
    variant: "text"
  }, "Styles", /* @__PURE__ */ React71.createElement(OverlapIcons, {
    style: {
      color: strokes[theme][displayedStyle.color]
    }
  }, displayedStyle.isFilled && /* @__PURE__ */ React71.createElement(CircleIcon2, {
    size: 16,
    stroke: "none",
    fill: fills[theme][displayedStyle.color]
  }), DASH_ICONS[displayedStyle.dash]))), /* @__PURE__ */ React71.createElement(DMContent, null, /* @__PURE__ */ React71.createElement(StyledRow, {
    variant: "tall",
    id: "TD-Styles-Color-Container"
  }, /* @__PURE__ */ React71.createElement("span", null, "Color"), /* @__PURE__ */ React71.createElement(ColorGrid, null, Object.keys(strokes.light).map((style) => /* @__PURE__ */ React71.createElement(Item3, {
    key: style,
    onSelect: preventEvent,
    asChild: true,
    id: `TD-Styles-Color-Swatch-${style}`
  }, /* @__PURE__ */ React71.createElement(ToolButton, {
    variant: "icon",
    isActive: displayedStyle.color === style,
    onClick: () => app.style({ color: style })
  }, /* @__PURE__ */ React71.createElement(CircleIcon2, {
    size: 18,
    strokeWidth: 2.5,
    fill: displayedStyle.isFilled ? fills.light[style] : "transparent",
    stroke: strokes.light[style]
  })))))), /* @__PURE__ */ React71.createElement(DMCheckboxItem, {
    variant: "styleMenu",
    checked: !!displayedStyle.isFilled,
    onCheckedChange: handleToggleFilled,
    id: "TD-Styles-Fill"
  }, "Fill"), /* @__PURE__ */ React71.createElement(StyledRow, {
    id: "TD-Styles-Dash-Container"
  }, "Dash", /* @__PURE__ */ React71.createElement(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.dash,
    onValueChange: handleDashChange
  }, Object.values(DashStyle).map((style) => /* @__PURE__ */ React71.createElement(DMRadioItem, {
    key: style,
    isActive: style === displayedStyle.dash,
    value: style,
    onSelect: preventEvent,
    bp: breakpoints,
    id: `TD-Styles-Dash-${style}`
  }, DASH_ICONS[style])))), /* @__PURE__ */ React71.createElement(StyledRow, {
    id: "TD-Styles-Size-Container"
  }, "Size", /* @__PURE__ */ React71.createElement(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.size,
    onValueChange: handleSizeChange
  }, Object.values(SizeStyle).map((sizeStyle) => /* @__PURE__ */ React71.createElement(DMRadioItem, {
    key: sizeStyle,
    isActive: sizeStyle === displayedStyle.size,
    value: sizeStyle,
    onSelect: preventEvent,
    bp: breakpoints,
    id: `TD-Styles-Dash-${sizeStyle}`
  }, SIZE_ICONS[sizeStyle])))), (options2 === "text" || options2 === "label") && /* @__PURE__ */ React71.createElement(React71.Fragment, null, /* @__PURE__ */ React71.createElement(Divider, null), /* @__PURE__ */ React71.createElement(StyledRow, {
    id: "TD-Styles-Font-Container"
  }, "Font", /* @__PURE__ */ React71.createElement(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.font,
    onValueChange: handleFontChange
  }, Object.values(FontStyle).map((fontStyle) => /* @__PURE__ */ React71.createElement(DMRadioItem, {
    key: fontStyle,
    isActive: fontStyle === displayedStyle.font,
    value: fontStyle,
    onSelect: preventEvent,
    bp: breakpoints,
    id: `TD-Styles-Font-${fontStyle}`
  }, /* @__PURE__ */ React71.createElement(FontIcon, {
    fontStyle
  }, "Aa"))))), options2 === "text" && /* @__PURE__ */ React71.createElement(StyledRow, {
    id: "TD-Styles-Align-Container"
  }, "Align", /* @__PURE__ */ React71.createElement(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.textAlign,
    onValueChange: handleTextAlignChange
  }, Object.values(AlignStyle).map((style) => /* @__PURE__ */ React71.createElement(DMRadioItem, {
    key: style,
    isActive: style === displayedStyle.textAlign,
    value: style,
    onSelect: preventEvent,
    bp: breakpoints,
    id: `TD-Styles-Align-${style}`
  }, ALIGN_ICONS[style])))))));
});
var ColorGrid = styled("div", {
  display: "grid",
  gridTemplateColumns: "repeat(4, auto)",
  gap: 0
});
var StyledRow = styled("div", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  minHeight: "32px",
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  padding: "$2 0 $2 $3",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  display: "flex",
  gap: "$3",
  flexDirection: "row",
  alignItems: "center",
  justifyContent: "space-between",
  variants: {
    variant: {
      tall: {
        alignItems: "flex-start",
        padding: "0 0 0 $3",
        "& > span": {
          paddingTop: "$4"
        }
      }
    }
  }
});
var StyledGroup = styled(DropdownMenuRadioGroup, {
  display: "flex",
  flexDirection: "row",
  gap: "$1"
});
var OverlapIcons = styled("div", {
  display: "grid",
  "& > *": {
    gridColumn: 1,
    gridRow: 1
  }
});
var FontIcon = styled("div", {
  width: 32,
  height: 32,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontSize: "$3",
  variants: {
    fontStyle: {
      ["script"]: {
        fontFamily: "Caveat Brush"
      },
      ["sans"]: {
        fontFamily: "Recursive"
      },
      ["erif"]: {
        fontFamily: "Georgia"
      },
      ["mono"]: {
        fontFamily: "Recursive Mono"
      }
    }
  }
});
var roomSelector = (state) => state.room;
var MultiplayerMenu = React722.memo(function MultiplayerMenu2() {
  const app = useTldrawApp();
  const room2 = app.useStore(roomSelector);
  const [copied, setCopied] = React722.useState(false);
  const handleCopySelect = React722.useCallback(() => {
    setCopied(true);
    TLDR.copyStringToClipboard(window.location.href);
    setTimeout(() => setCopied(false), 1200);
  }, []);
  const handleCreateMultiplayerRoom = React722.useCallback(() => __async2(this, null, function* () {
    if (app.isDirty) {
      if (app.fileSystemHandle) {
        if (window.confirm("Do you want to save changes to your current project?")) {
          yield app.saveProject();
        }
      } else {
        if (window.confirm("Do you want to save your current project?")) {
          yield app.saveProject();
        }
      }
    } else if (!app.fileSystemHandle) {
      if (window.confirm("Do you want to save your current project?")) {
        yield app.saveProject();
      }
    }
  }), []);
  const handleCopyToMultiplayerRoom = React722.useCallback(() => __async2(this, null, function* () {
    const myHeaders = new Headers({
      "Access-Control-Allow-Origin": "*",
      "Content-Type": "application/json"
    });
    const res = yield fetch("http://tldraw.com/api/create-multiplayer-room", {
      headers: myHeaders,
      method: "POST",
      mode: "cors",
      cache: "no-cache",
      body: JSON.stringify(app.document)
    }).then((res2) => res2.json());
    window.location.href = `http://tldraw.com/r/${res.roomId}`;
  }), []);
  return /* @__PURE__ */ React722.createElement(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ React722.createElement(DMTriggerIcon, {
    id: "TD-MultiplayerMenuIcon"
  }, room2 ? /* @__PURE__ */ React722.createElement(MultiplayerIcon, null) : /* @__PURE__ */ React722.createElement(CursorArrowIcon, null)), /* @__PURE__ */ React722.createElement(DMContent, {
    variant: "menu",
    align: "start",
    id: "TD-MultiplayerMenu"
  }, /* @__PURE__ */ React722.createElement(DMItem, {
    id: "TD-Multiplayer-CopyInviteLink",
    onClick: handleCopySelect,
    disabled: !room2
  }, "Copy Invite Link", /* @__PURE__ */ React722.createElement(SmallIcon, null, copied ? /* @__PURE__ */ React722.createElement(CheckIcon, null) : /* @__PURE__ */ React722.createElement(ClipboardIcon, null))), /* @__PURE__ */ React722.createElement(DMDivider, {
    id: "TD-Multiplayer-CopyInviteLinkDivider"
  }), /* @__PURE__ */ React722.createElement(DMItem, {
    id: "TD-Multiplayer-CreateMultiplayerRoom",
    onClick: handleCreateMultiplayerRoom
  }, /* @__PURE__ */ React722.createElement("a", {
    href: "https://tldraw.com/r"
  }, "Create a Multiplayer Project"))));
});
function TopPanel({
  readOnly,
  showPages,
  showMenu,
  showStyles,
  showZoom,
  showSponsorLink,
  showMultiplayerMenu
}) {
  const app = useTldrawApp();
  return /* @__PURE__ */ React73.createElement(StyledTopPanel, null, (showMenu || showPages) && /* @__PURE__ */ React73.createElement(Panel, {
    side: "left",
    id: "TD-MenuPanel"
  }, showMenu && /* @__PURE__ */ React73.createElement(Menu2, {
    showSponsorLink,
    readOnly
  }), showMultiplayerMenu && /* @__PURE__ */ React73.createElement(MultiplayerMenu, null), showPages && /* @__PURE__ */ React73.createElement(PageMenu, null)), /* @__PURE__ */ React73.createElement(StyledSpacer, null), (showStyles || showZoom) && /* @__PURE__ */ React73.createElement(Panel, {
    side: "right"
  }, showStyles && !readOnly && /* @__PURE__ */ React73.createElement(StyleMenu, null), /* @__PURE__ */ React73.createElement(ToolButton, null, /* @__PURE__ */ React73.createElement(UndoIcon, {
    onClick: app.undo
  })), /* @__PURE__ */ React73.createElement(ToolButton, null, /* @__PURE__ */ React73.createElement(RedoIcon, {
    onClick: app.redo
  })), showZoom && /* @__PURE__ */ React73.createElement(ZoomMenu, null)));
}
var StyledTopPanel = styled("div", {
  width: "100%",
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  display: "flex",
  flexDirection: "row",
  pointerEvents: "none",
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer = styled("div", {
  flexGrow: 2,
  pointerEvents: "none"
});
var numberOfSelectedIdsSelector2 = (s9) => {
  return s9.document.pageStates[s9.appState.currentPageId].selectedIds.length;
};
var isDebugModeSelector2 = (s9) => {
  return s9.settings.isDebugMode;
};
var hasGroupSelectedSelector = (s9) => {
  return s9.document.pageStates[s9.appState.currentPageId].selectedIds.some((id) => s9.document.pages[s9.appState.currentPageId].shapes[id].children !== void 0);
};
var preventDefault = (e11) => e11.stopPropagation();
var ContextMenu2 = ({ onBlur, children }) => {
  return /* @__PURE__ */ React74.createElement(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ React74.createElement(Trigger5, {
    dir: "ltr"
  }, children), /* @__PURE__ */ React74.createElement(InnerMenu, {
    onBlur
  }));
};
var InnerMenu = React74.memo(function InnerMenu2({ onBlur }) {
  const app = useTldrawApp();
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector2);
  const isDebugMode = app.useStore(isDebugModeSelector2);
  const hasGroupSelected = app.useStore(hasGroupSelectedSelector);
  const rContent = React74.useRef(null);
  const handleFlipHorizontal = React74.useCallback(() => {
    app.flipHorizontal();
  }, [app]);
  const handleFlipVertical = React74.useCallback(() => {
    app.flipVertical();
  }, [app]);
  const handleDuplicate = React74.useCallback(() => {
    app.duplicate();
  }, [app]);
  const handleLock = React74.useCallback(() => {
    app.toggleLocked();
  }, [app]);
  const handleGroup = React74.useCallback(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = React74.useCallback(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = React74.useCallback(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = React74.useCallback(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = React74.useCallback(() => {
    app.moveToFront();
  }, [app]);
  const handleDelete = React74.useCallback(() => {
    app.delete();
  }, [app]);
  const handleCopyJson = React74.useCallback(() => {
    app.copyJson();
  }, [app]);
  const handleCut = React74.useCallback(() => {
    app.cut();
  }, [app]);
  const handleCopy = React74.useCallback(() => {
    app.copy();
  }, [app]);
  const handlePaste = React74.useCallback(() => {
    app.paste();
  }, [app]);
  const handleCopySvg = React74.useCallback(() => {
    app.copySvg();
  }, [app]);
  const handleUndo = React74.useCallback(() => {
    app.undo();
  }, [app]);
  const handleRedo = React74.useCallback(() => {
    app.redo();
  }, [app]);
  const handleExportPNG = React74.useCallback(() => __async2(this, null, function* () {
    yield app.exportSelectedShapesAs("png");
  }), [app]);
  const handleExportJPG = React74.useCallback(() => __async2(this, null, function* () {
    yield app.exportSelectedShapesAs("jpeg");
  }), [app]);
  const handleExportWEBP = React74.useCallback(() => __async2(this, null, function* () {
    yield app.exportSelectedShapesAs("webp");
  }), [app]);
  const handleExportSVG = React74.useCallback(() => __async2(this, null, function* () {
    yield app.exportSelectedShapesAs("svg");
  }), [app]);
  const handleExportJSON = React74.useCallback(() => __async2(this, null, function* () {
    yield app.exportSelectedShapesAs("json");
  }), [app]);
  const hasSelection = numberOfSelectedIds > 0;
  const hasTwoOrMore = numberOfSelectedIds > 1;
  const hasThreeOrMore = numberOfSelectedIds > 2;
  return /* @__PURE__ */ React74.createElement(Content7, {
    dir: "ltr",
    ref: rContent,
    onEscapeKeyDown: preventDefault,
    asChild: true,
    tabIndex: -1,
    onBlur
  }, /* @__PURE__ */ React74.createElement(MenuContent2, {
    id: "TD-ContextMenu"
  }, hasSelection ? /* @__PURE__ */ React74.createElement(React74.Fragment, null, /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleDuplicate,
    kbd: "#D",
    id: "TD-ContextMenu-Duplicate"
  }, "Duplicate"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleFlipHorizontal,
    kbd: "\u21E7H",
    id: "TD-ContextMenu-Flip_Horizontal"
  }, "Flip Horizontal"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleFlipVertical,
    kbd: "\u21E7V",
    id: "TD-ContextMenu-Flip_Vertical"
  }, "Flip Vertical"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleLock,
    kbd: "#\u21E7L",
    id: "TD-ContextMenu- Lock_Unlock"
  }, "Lock / Unlock"), (hasTwoOrMore || hasGroupSelected) && /* @__PURE__ */ React74.createElement(Divider, null), hasTwoOrMore && /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleGroup,
    kbd: "#G",
    id: "TD-ContextMenu-Group"
  }, "Group"), hasGroupSelected && /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleGroup,
    kbd: "#G",
    id: "TD-ContextMenu-Ungroup"
  }, "Ungroup"), /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(ContextMenuSubMenu, {
    label: "Move",
    id: "TD-ContextMenu-Move"
  }, /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleMoveToFront,
    kbd: "\u21E7]",
    id: "TD-ContextMenu-Move-To_Front"
  }, "To Front"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleMoveForward,
    kbd: "]",
    id: "TD-ContextMenu-Move-Forward"
  }, "Forward"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleMoveBackward,
    kbd: "[",
    id: "TD-ContextMenu-Move-Backward"
  }, "Backward"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleMoveToBack,
    kbd: "\u21E7[",
    id: "TD-ContextMenu-Move-To_Back"
  }, "To Back")), /* @__PURE__ */ React74.createElement(MoveToPageMenu, null), hasTwoOrMore && /* @__PURE__ */ React74.createElement(AlignDistributeSubMenu, {
    hasTwoOrMore,
    hasThreeOrMore
  }), app.callbacks.onExport ? /* @__PURE__ */ React74.createElement(React74.Fragment, null, /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(ContextMenuSubMenu, {
    label: "Export",
    size: "small",
    id: "TD-ContextMenu-Export"
  }, /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleExportPNG,
    id: "TD-ContextMenu-Export-PNG"
  }, "PNG"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleExportJPG,
    id: "TD-ContextMenu-Export-JPG"
  }, "JPG"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleExportWEBP,
    id: "TD-ContextMenu-Export-WEBP"
  }, "WEBP"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleExportSVG,
    id: "TD-ContextMenu-Export-SVG"
  }, "SVG"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleExportJSON,
    id: "TD-ContextMenu-Export-JSON"
  }, "JSON"), /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCopySvg,
    kbd: "#\u21E7C",
    id: "TD-ContextMenu-Export-Copy_as_SVG"
  }, "Copy as SVG"), isDebugMode && /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCopyJson,
    id: "TD-ContextMenu-Export-Copy_as_JSON"
  }, "Copy as JSON"))) : /* @__PURE__ */ React74.createElement(React74.Fragment, null, /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCopySvg,
    kbd: "#\u21E7C",
    id: "TD-ContextMenu-Export-Copy_as_SVG"
  }, "Copy as SVG"), isDebugMode && /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCopyJson,
    id: "TD-ContextMenu-Export-Copy_as_JSON"
  }, "Copy as JSON")), /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCut,
    kbd: "#X",
    id: "TD-ContextMenu-Cut"
  }, "Cut"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleCopy,
    kbd: "#C",
    id: "TD-ContextMenu-Copy"
  }, "Copy"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handlePaste,
    kbd: "#V",
    id: "TD-ContextMenu-Paste"
  }, "Paste"), /* @__PURE__ */ React74.createElement(Divider, null), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleDelete,
    kbd: "\u232B",
    id: "TD-ContextMenu-Delete"
  }, "Delete")) : /* @__PURE__ */ React74.createElement(React74.Fragment, null, /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handlePaste,
    kbd: "#V",
    id: "TD-ContextMenu-Paste"
  }, "Paste"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleUndo,
    kbd: "#Z",
    id: "TD-ContextMenu-Undo"
  }, "Undo"), /* @__PURE__ */ React74.createElement(CMRowButton, {
    onClick: handleRedo,
    kbd: "#\u21E7Z",
    id: "TD-ContextMenu-Redo"
  }, "Redo"))));
});
function AlignDistributeSubMenu({
  hasThreeOrMore
}) {
  const app = useTldrawApp();
  const alignTop = React74.useCallback(() => {
    app.align("top");
  }, [app]);
  const alignCenterVertical = React74.useCallback(() => {
    app.align("centerVertical");
  }, [app]);
  const alignBottom = React74.useCallback(() => {
    app.align("bottom");
  }, [app]);
  const stretchVertically = React74.useCallback(() => {
    app.stretch("vertical");
  }, [app]);
  const distributeVertically = React74.useCallback(() => {
    app.distribute("vertical");
  }, [app]);
  const alignLeft = React74.useCallback(() => {
    app.align("left");
  }, [app]);
  const alignCenterHorizontal = React74.useCallback(() => {
    app.align("centerHorizontal");
  }, [app]);
  const alignRight = React74.useCallback(() => {
    app.align("right");
  }, [app]);
  const stretchHorizontally = React74.useCallback(() => {
    app.stretch("horizontal");
  }, [app]);
  const distributeHorizontally = React74.useCallback(() => {
    app.distribute("horizontal");
  }, [app]);
  return /* @__PURE__ */ React74.createElement("span", {
    id: "TD-ContextMenu-Align_Duplicate"
  }, /* @__PURE__ */ React74.createElement(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ React74.createElement(CMTriggerButton, {
    isSubmenu: true
  }, "Align / Distribute"), /* @__PURE__ */ React74.createElement(Content7, {
    asChild: true,
    sideOffset: 2,
    alignOffset: -2
  }, /* @__PURE__ */ React74.createElement(StyledGridContent, {
    numberOfSelected: hasThreeOrMore ? "threeOrMore" : "twoOrMore"
  }, /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignLeft,
    id: "TD-ContextMenu-Align_Duplicate-AlignLeft"
  }, /* @__PURE__ */ React74.createElement(AlignLeftIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignCenterHorizontal,
    id: "TD-ContextMenu-Align_Duplicate-AlignCenterHorizontal"
  }, /* @__PURE__ */ React74.createElement(AlignCenterHorizontallyIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignRight,
    id: "TD-ContextMenu-Align_Duplicate-AlignRight"
  }, /* @__PURE__ */ React74.createElement(AlignRightIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: stretchHorizontally,
    id: "TD-ContextMenu-Align_Duplicate-StretchHorizontal"
  }, /* @__PURE__ */ React74.createElement(StretchHorizontallyIcon, null)), hasThreeOrMore && /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: distributeHorizontally,
    id: "TD-ContextMenu-Align_Duplicate-SpaceEvenlyHorizontal"
  }, /* @__PURE__ */ React74.createElement(SpaceEvenlyHorizontallyIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignTop,
    id: "TD-ContextMenu-Align_Duplicate-AlignTop"
  }, /* @__PURE__ */ React74.createElement(AlignTopIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignCenterVertical,
    id: "TD-ContextMenu-Align_Duplicate-AlignCenterVertical"
  }, /* @__PURE__ */ React74.createElement(AlignCenterVerticallyIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: alignBottom,
    id: "TD-ContextMenu-Align_Duplicate-AlignBottom"
  }, /* @__PURE__ */ React74.createElement(AlignBottomIcon, null)), /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: stretchVertically,
    id: "TD-ContextMenu-Align_Duplicate-StretchVertical"
  }, /* @__PURE__ */ React74.createElement(StretchVerticallyIcon, null)), hasThreeOrMore && /* @__PURE__ */ React74.createElement(CMIconButton, {
    onClick: distributeVertically,
    id: "TD-ContextMenu-Align_Duplicate-SpaceEvenlyVertical"
  }, /* @__PURE__ */ React74.createElement(SpaceEvenlyVerticallyIcon, null)), /* @__PURE__ */ React74.createElement(CMArrow, {
    offset: 13
  })))));
}
var StyledGridContent = styled(MenuContent2, {
  display: "grid",
  variants: {
    numberOfSelected: {
      threeOrMore: {
        gridTemplateColumns: "repeat(5, auto)"
      },
      twoOrMore: {
        gridTemplateColumns: "repeat(4, auto)"
      }
    }
  }
});
var currentPageIdSelector2 = (s9) => s9.appState.currentPageId;
var documentPagesSelector = (s9) => s9.document.pages;
function MoveToPageMenu() {
  const app = useTldrawApp();
  const currentPageId = app.useStore(currentPageIdSelector2);
  const documentPages = app.useStore(documentPagesSelector);
  const sorted = Object.values(documentPages).sort((a7, b7) => (a7.childIndex || 0) - (b7.childIndex || 0)).filter((a7) => a7.id !== currentPageId);
  if (sorted.length === 0)
    return null;
  return /* @__PURE__ */ React74.createElement(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ React74.createElement(CMTriggerButton, {
    isSubmenu: true
  }, "Move To Page"), /* @__PURE__ */ React74.createElement(Content7, {
    dir: "ltr",
    sideOffset: 2,
    alignOffset: -2,
    asChild: true
  }, /* @__PURE__ */ React74.createElement(MenuContent2, null, sorted.map(({ id, name }, i8) => /* @__PURE__ */ React74.createElement(CMRowButton, {
    key: id,
    disabled: id === currentPageId,
    onClick: () => app.moveToPage(id)
  }, name || `Page ${i8}`)), /* @__PURE__ */ React74.createElement(CMArrow, {
    offset: 13
  }))));
}
function ContextMenuSubMenu({
  children,
  label,
  size,
  id
}) {
  return /* @__PURE__ */ React74.createElement("span", {
    id
  }, /* @__PURE__ */ React74.createElement(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ React74.createElement(CMTriggerButton, {
    isSubmenu: true
  }, label), /* @__PURE__ */ React74.createElement(Content7, {
    dir: "ltr",
    sideOffset: 2,
    alignOffset: -2,
    asChild: true
  }, /* @__PURE__ */ React74.createElement(MenuContent2, {
    size
  }, children, /* @__PURE__ */ React74.createElement(CMArrow, {
    offset: 13
  })))));
}
var CMArrow = styled(ContextMenuArrow, {
  fill: "$panel"
});
function CMIconButton(_a2) {
  var _b = _a2, { onSelect } = _b, rest = __objRest3(_b, ["onSelect"]);
  return /* @__PURE__ */ React74.createElement(ContextMenuItem, {
    dir: "ltr",
    onSelect,
    asChild: true
  }, /* @__PURE__ */ React74.createElement(ToolButton, __spreadValues4({}, rest)));
}
var CMRowButton = (_a2) => {
  var _b = _a2, { id } = _b, rest = __objRest3(_b, ["id"]);
  return /* @__PURE__ */ React74.createElement(ContextMenuItem, {
    asChild: true,
    id
  }, /* @__PURE__ */ React74.createElement(RowButton, __spreadValues4({}, rest)));
};
var CMTriggerButton = (_a2) => {
  var _b = _a2, { isSubmenu } = _b, rest = __objRest3(_b, ["isSubmenu"]);
  return /* @__PURE__ */ React74.createElement(ContextMenuTriggerItem, {
    asChild: true
  }, /* @__PURE__ */ React74.createElement(RowButton, __spreadValues4({
    hasArrow: isSubmenu
  }, rest)));
};
function FocusButton({ onSelect }) {
  return /* @__PURE__ */ React75.createElement(StyledButtonContainer, null, /* @__PURE__ */ React75.createElement(IconButton, {
    onClick: onSelect
  }, /* @__PURE__ */ React75.createElement(DotFilledIcon, null)));
}
var StyledButtonContainer = styled("div", {
  opacity: 1,
  zIndex: 100,
  backgroundColor: "transparent",
  "& svg": {
    color: "$text"
  },
  "&:hover svg": {
    color: "$text"
  }
});
var loadingSelector = (s9) => s9.appState.isLoading;
function Loading() {
  const app = useTldrawApp();
  const isLoading = app.useStore(loadingSelector);
  return /* @__PURE__ */ React76.createElement(StyledLoadingPanelContainer, {
    hidden: !isLoading
  }, "Loading...");
}
var StyledLoadingPanelContainer = styled("div", {
  position: "absolute",
  top: 0,
  left: "50%",
  transform: `translate(-50%, 0)`,
  borderBottomLeftRadius: "12px",
  borderBottomRightRadius: "12px",
  padding: "8px 16px",
  fontFamily: "var(--fonts-ui)",
  fontSize: "var(--fontSizes-1)",
  boxShadow: "var(--shadows-panel)",
  backgroundColor: "white",
  zIndex: 200,
  pointerEvents: "none",
  "& > div > *": {
    pointerEvents: "all"
  },
  variants: {
    transform: {
      hidden: {
        transform: `translate(-50%, 100%)`
      },
      visible: {
        transform: `translate(-50%, 0%)`
      }
    }
  }
});
function Tldraw({
  id,
  document: document2,
  currentPageId,
  autofocus = true,
  showMenu = true,
  showMultiplayerMenu = true,
  showPages = true,
  showTools = true,
  showZoom = true,
  showStyles = true,
  showUI = true,
  readOnly = false,
  showSponsorLink = false,
  disableAssets = false,
  darkMode = false,
  onMount,
  onChange: onChange2,
  onChangePresence,
  onNewProject,
  onSaveProject,
  onSaveProjectAs,
  onOpenProject,
  onOpenMedia,
  onSignOut,
  onSignIn,
  onUndo,
  onRedo,
  onPersist,
  onPatch,
  onCommand,
  onChangePage,
  onAssetCreate,
  onAssetDelete,
  onExport
}) {
  const [sId, setSId] = React77.useState(id);
  const [app, setApp] = React77.useState(() => {
    const app2 = new TldrawApp(id, {
      onMount,
      onChange: onChange2,
      onChangePresence,
      onNewProject,
      onSaveProject,
      onSaveProjectAs,
      onOpenProject,
      onOpenMedia,
      onSignOut,
      onSignIn,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate
    });
    return app2;
  });
  React77.useLayoutEffect(() => {
    if (id === sId)
      return;
    const newApp = new TldrawApp(id, {
      onMount,
      onChange: onChange2,
      onChangePresence,
      onNewProject,
      onSaveProject,
      onSaveProjectAs,
      onOpenProject,
      onOpenMedia,
      onSignOut,
      onSignIn,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate,
      onExport
    });
    setSId(id);
    setApp(newApp);
  }, [sId, id]);
  React77.useEffect(() => {
    if (!document2)
      return;
    if (document2.id === app.document.id) {
      app.updateDocument(document2);
    } else {
      app.loadDocument(document2);
    }
  }, [document2, app]);
  React77.useEffect(() => {
    app.setDisableAssets(disableAssets);
  }, [app, disableAssets]);
  React77.useEffect(() => {
    if (!currentPageId)
      return;
    app.changePage(currentPageId);
  }, [currentPageId, app]);
  React77.useEffect(() => {
    app.readOnly = readOnly;
  }, [app, readOnly]);
  React77.useEffect(() => {
    if (darkMode !== app.settings.isDarkMode) {
      app.toggleDarkMode();
    }
  }, [app, darkMode]);
  React77.useEffect(() => {
    app.callbacks = {
      onMount,
      onChange: onChange2,
      onChangePresence,
      onNewProject,
      onSaveProject,
      onSaveProjectAs,
      onOpenProject,
      onOpenMedia,
      onSignOut,
      onSignIn,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage,
      onAssetDelete,
      onAssetCreate,
      onExport
    };
  }, [
    onMount,
    onChange2,
    onChangePresence,
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject,
    onOpenMedia,
    onSignOut,
    onSignIn,
    onUndo,
    onRedo,
    onPersist,
    onPatch,
    onCommand,
    onChangePage,
    onAssetDelete,
    onAssetCreate,
    onExport
  ]);
  React77.useLayoutEffect(() => {
    var _a2;
    if (typeof window === "undefined")
      return;
    if (!((_a2 = window.document) == null ? void 0 : _a2.fonts))
      return;
    function refreshBoundingBoxes() {
      app.refreshBoundingBoxes();
    }
    window.document.fonts.addEventListener("loadingdone", refreshBoundingBoxes);
    return () => {
      window.document.fonts.removeEventListener("loadingdone", refreshBoundingBoxes);
    };
  }, [app]);
  return /* @__PURE__ */ React77.createElement(TldrawContext.Provider, {
    value: app
  }, /* @__PURE__ */ React77.createElement(InnerTldraw, {
    key: sId || "Tldraw",
    id: sId,
    autofocus,
    showPages,
    showMenu,
    showMultiplayerMenu,
    showStyles,
    showZoom,
    showTools,
    showUI,
    showSponsorLink,
    readOnly
  }));
}
var InnerTldraw = React77.memo(function InnerTldraw2({
  id,
  autofocus,
  showPages,
  showMenu,
  showMultiplayerMenu,
  showZoom,
  showStyles,
  showTools,
  showSponsorLink,
  readOnly,
  showUI
}) {
  var _a2, _b;
  const app = useTldrawApp();
  const rWrapper = React77.useRef(null);
  const state = app.useStore();
  const { document: document2, settings, appState, room: room2 } = state;
  const isSelecting = state.appState.activeTool === "select";
  const page = document2.pages[appState.currentPageId];
  const pageState = document2.pageStates[page.id];
  const assets = document2.assets;
  const { selectedIds } = pageState;
  const isHideBoundsShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds;
  const isHideResizeHandlesShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles;
  const meta = React77.useMemo(() => {
    return { isDarkMode: settings.isDarkMode };
  }, [settings.isDarkMode]);
  const showDashedBrush = settings.isCadSelectMode ? !appState.selectByContain : appState.selectByContain;
  const theme = React77.useMemo(() => {
    const { selectByContain } = appState;
    const { isDarkMode, isCadSelectMode } = settings;
    if (isDarkMode) {
      const brushBase2 = isCadSelectMode ? selectByContain ? "69, 155, 255" : "105, 209, 73" : "180, 180, 180";
      return {
        brushFill: `rgba(${brushBase2}, ${isCadSelectMode ? 0.08 : 0.05})`,
        brushStroke: `rgba(${brushBase2}, ${isCadSelectMode ? 0.5 : 0.25})`,
        brushDashStroke: `rgba(${brushBase2}, .6)`,
        selected: "rgba(38, 150, 255, 1.000)",
        selectFill: "rgba(38, 150, 255, 0.05)",
        background: "#212529",
        foreground: "#49555f"
      };
    }
    const brushBase = isCadSelectMode ? selectByContain ? "0, 89, 242" : "51, 163, 23" : "0,0,0";
    return {
      brushFill: `rgba(${brushBase}, ${isCadSelectMode ? 0.08 : 0.05})`,
      brushStroke: `rgba(${brushBase}, ${isCadSelectMode ? 0.4 : 0.25})`,
      brushDashStroke: `rgba(${brushBase}, .6)`
    };
  }, [settings.isDarkMode, settings.isCadSelectMode, appState.selectByContain]);
  const isInSession = app.session !== void 0;
  const hideBounds = isInSession && ((_a2 = app.session) == null ? void 0 : _a2.constructor.name) !== "BrushSession" || !isSelecting || isHideBoundsShape || !!pageState.editingId;
  const hideHandles = isInSession || !isSelecting;
  const hideIndicators = isInSession && state.appState.status !== "brushing" || !isSelecting;
  const hideCloneHandles = isInSession || !isSelecting || !settings.showCloneHandles || pageState.camera.zoom < 0.2;
  return /* @__PURE__ */ React77.createElement(StyledLayout, {
    ref: rWrapper,
    tabIndex: -0,
    className: settings.isDarkMode ? dark : ""
  }, /* @__PURE__ */ React77.createElement(Loading, null), /* @__PURE__ */ React77.createElement(OneOff, {
    focusableRef: rWrapper,
    autofocus
  }), /* @__PURE__ */ React77.createElement(ContextMenu2, null, /* @__PURE__ */ React77.createElement(Renderer, {
    id,
    containerRef: rWrapper,
    shapeUtils,
    page,
    pageState,
    assets,
    snapLines: appState.snapLines,
    grid: GRID_SIZE,
    users: room2 == null ? void 0 : room2.users,
    userId: room2 == null ? void 0 : room2.userId,
    theme,
    meta,
    hideBounds,
    hideHandles,
    hideResizeHandles: isHideResizeHandlesShape,
    hideIndicators,
    hideBindingHandles: !settings.showBindingHandles,
    hideCloneHandles,
    hideRotateHandles: !settings.showRotateHandles,
    hideGrid: !settings.showGrid,
    showDashedBrush,
    performanceMode: (_b = app.session) == null ? void 0 : _b.performanceMode,
    onPinchStart: app.onPinchStart,
    onPinchEnd: app.onPinchEnd,
    onPinch: app.onPinch,
    onPan: app.onPan,
    onZoom: app.onZoom,
    onPointerDown: app.onPointerDown,
    onPointerMove: app.onPointerMove,
    onPointerUp: app.onPointerUp,
    onPointCanvas: app.onPointCanvas,
    onDoubleClickCanvas: app.onDoubleClickCanvas,
    onRightPointCanvas: app.onRightPointCanvas,
    onDragCanvas: app.onDragCanvas,
    onReleaseCanvas: app.onReleaseCanvas,
    onPointShape: app.onPointShape,
    onDoubleClickShape: app.onDoubleClickShape,
    onRightPointShape: app.onRightPointShape,
    onDragShape: app.onDragShape,
    onHoverShape: app.onHoverShape,
    onUnhoverShape: app.onUnhoverShape,
    onReleaseShape: app.onReleaseShape,
    onPointBounds: app.onPointBounds,
    onDoubleClickBounds: app.onDoubleClickBounds,
    onRightPointBounds: app.onRightPointBounds,
    onDragBounds: app.onDragBounds,
    onHoverBounds: app.onHoverBounds,
    onUnhoverBounds: app.onUnhoverBounds,
    onReleaseBounds: app.onReleaseBounds,
    onPointBoundsHandle: app.onPointBoundsHandle,
    onDoubleClickBoundsHandle: app.onDoubleClickBoundsHandle,
    onRightPointBoundsHandle: app.onRightPointBoundsHandle,
    onDragBoundsHandle: app.onDragBoundsHandle,
    onHoverBoundsHandle: app.onHoverBoundsHandle,
    onUnhoverBoundsHandle: app.onUnhoverBoundsHandle,
    onReleaseBoundsHandle: app.onReleaseBoundsHandle,
    onPointHandle: app.onPointHandle,
    onDoubleClickHandle: app.onDoubleClickHandle,
    onRightPointHandle: app.onRightPointHandle,
    onDragHandle: app.onDragHandle,
    onHoverHandle: app.onHoverHandle,
    onUnhoverHandle: app.onUnhoverHandle,
    onReleaseHandle: app.onReleaseHandle,
    onError: app.onError,
    onRenderCountChange: app.onRenderCountChange,
    onShapeChange: app.onShapeChange,
    onShapeBlur: app.onShapeBlur,
    onShapeClone: app.onShapeClone,
    onBoundsChange: app.updateBounds,
    onKeyDown: app.onKeyDown,
    onKeyUp: app.onKeyUp,
    onDragOver: app.onDragOver,
    onDrop: app.onDrop
  })), showUI && /* @__PURE__ */ React77.createElement(StyledUI, null, settings.isFocusMode ? /* @__PURE__ */ React77.createElement(FocusButton, {
    onSelect: app.toggleFocusMode
  }) : /* @__PURE__ */ React77.createElement(React77.Fragment, null, /* @__PURE__ */ React77.createElement(TopPanel, {
    readOnly,
    showPages,
    showMenu,
    showMultiplayerMenu,
    showStyles,
    showZoom,
    showSponsorLink
  }), /* @__PURE__ */ React77.createElement(StyledSpacer2, null), showTools && !readOnly && /* @__PURE__ */ React77.createElement(ToolsPanel, null))));
});
var OneOff = React77.memo(function OneOff2({
  focusableRef,
  autofocus
}) {
  useKeyboardShortcuts(focusableRef);
  useStylesheet();
  React77.useEffect(() => {
    var _a2;
    if (autofocus) {
      (_a2 = focusableRef.current) == null ? void 0 : _a2.focus();
    }
  }, [autofocus]);
  return null;
});
var StyledLayout = styled("div", {
  position: "absolute",
  height: "100%",
  width: "100%",
  minHeight: 0,
  minWidth: 0,
  maxHeight: "100%",
  maxWidth: "100%",
  overflow: "hidden",
  boxSizing: "border-box",
  outline: "none",
  "& .tl-container": {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    zIndex: 1
  },
  "& input, textarea, button, select, label, button": {
    webkitTouchCallout: "none",
    webkitUserSelect: "none",
    "-webkit-tap-highlight-color": "transparent",
    "tap-highlight-color": "transparent"
  }
});
var StyledUI = styled("div", {
  position: "absolute",
  top: 0,
  left: 0,
  height: "100%",
  width: "100%",
  padding: "8px 8px 0 8px",
  display: "flex",
  alignItems: "flex-start",
  justifyContent: "flex-start",
  pointerEvents: "none",
  zIndex: 2,
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer2 = styled("div", {
  flexGrow: 2
});

// src/yjs-tldraw/src/hooks/useMultiplayerState.ts
var import_react19 = __toESM(require_react());

// ../../node_modules/@y-presence/client/dist/esm/index.js
var n5 = class {
  constructor(e11) {
    this.listeners = { others: [], users: [], self: [] };
    this.awareness = e11, this.awareness.setLocalState({ id: this.awareness.clientID }), this.awareness.on("change", () => {
      let s9 = this.getOthers();
      this.listeners.others.forEach((t12) => {
        t12(s9);
      });
      let r12 = this.getUsers();
      this.listeners.users.forEach((t12) => {
        t12(r12);
      });
    });
  }
  subscribe(e11, s9) {
    switch (e11) {
      case "users":
      case "others":
        return this.listeners[e11].push(s9), () => this.unsubscribe(e11, s9);
      case "self":
        return this.listeners[e11].push(s9), () => this.unsubscribe(e11, s9);
      default:
        return console.warn("event not recognized"), {};
    }
  }
  unsubscribe(e11, s9) {
    for (let r12 = 0; r12 < this.listeners[e11].length; r12++)
      s9 === this.listeners[e11][r12] && this.listeners[e11].splice(r12, 1);
  }
  setPresence(e11) {
    let s9 = { id: this.awareness.clientID, presence: e11 };
    this.awareness.setLocalState(s9), this.listeners.self.forEach((r12) => {
      r12(s9);
    });
  }
  getSelf() {
    return this.awareness.getLocalState();
  }
  getOthers() {
    return Array.from(this.awareness.getStates().values()).filter((s9) => s9.id !== this.awareness.clientID);
  }
  getUsers() {
    return Array.from(this.awareness.getStates().values());
  }
  destroy() {
    this.awareness.setLocalState(null);
  }
};

// ../../node_modules/lib0/map.js
var create2 = () => /* @__PURE__ */ new Map();
var copy = (m8) => {
  const r12 = create2();
  m8.forEach((v6, k4) => {
    r12.set(k4, v6);
  });
  return r12;
};
var setIfUndefined = (map4, key, createT) => {
  let set5 = map4.get(key);
  if (set5 === void 0) {
    map4.set(key, set5 = createT());
  }
  return set5;
};
var map2 = (m8, f10) => {
  const res = [];
  for (const [key, value] of m8) {
    res.push(f10(value, key));
  }
  return res;
};
var any = (m8, f10) => {
  for (const [key, value] of m8) {
    if (f10(value, key)) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/lib0/set.js
var create3 = () => /* @__PURE__ */ new Set();

// ../../node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i8 = 0; i8 < src.length; i8++) {
    dest.push(src[i8]);
  }
};
var from = Array.from;
var isArray = Array.isArray;

// ../../node_modules/lib0/observable.js
var Observable = class {
  constructor() {
    this._observers = create2();
  }
  on(name, f10) {
    setIfUndefined(this._observers, name, create3).add(f10);
  }
  once(name, f10) {
    const _f = (...args2) => {
      this.off(name, _f);
      f10(...args2);
    };
    this.on(name, _f);
  }
  off(name, f10) {
    const observers2 = this._observers.get(name);
    if (observers2 !== void 0) {
      observers2.delete(f10);
      if (observers2.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  emit(name, args2) {
    return from((this._observers.get(name) || create2()).values()).forEach((f10) => f10(...args2));
  }
  destroy() {
    this._observers = create2();
  }
};

// ../../node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a7, b7) => a7 < b7 ? a7 : b7;
var max = (a7, b7) => a7 > b7 ? a7 : b7;
var isNaN2 = Number.isNaN;
var pow = Math.pow;
var isNegativeZero = (n6) => n6 !== 0 ? n6 < 0 : 1 / n6 < 0;

// ../../node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var toLowerCase = (s9) => s9.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s9) => s9.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s9, separator) => trimLeft(s9.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var utf8TextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// ../../node_modules/lib0/conditions.js
var undefinedToNull = (v6) => v6 === void 0 ? null : v6;

// ../../node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e11) {
}
var varStorage = _localStorage;
var onChange = (eventHandler2) => usePolyfill || addEventListener("storage", eventHandler2);

// ../../node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
var isBrowser3 = typeof window !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create2();
      const pargs = process.argv;
      let currParamName = null;
      for (let i8 = 0; i8 < pargs.length; i8++) {
        const parg = pargs[i8];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create2();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create2();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");

// ../../node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// ../../node_modules/lib0/decoding.js
var Decoder = class {
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let len = 0;
  while (true) {
    const r12 = decoder.arr[decoder.pos++];
    num = num | (r12 & BITS7) << len;
    len += 7;
    if (r12 < BIT8) {
      return num >>> 0;
    }
    if (len > 53) {
      throw new Error("Integer out of range!");
    }
  }
};
var readVarInt = (decoder) => {
  let r12 = decoder.arr[decoder.pos++];
  let num = r12 & BITS6;
  let len = 6;
  const sign = (r12 & BIT7) > 0 ? -1 : 1;
  if ((r12 & BIT8) === 0) {
    return sign * num;
  }
  while (true) {
    r12 = decoder.arr[decoder.pos++];
    num = num | (r12 & BITS7) << len;
    len += 7;
    if (r12 < BIT8) {
      return sign * (num >>> 0);
    }
    if (len > 53) {
      throw new Error("Integer out of range!");
    }
  }
};
var readVarString = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(null, bytes);
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => readFromDataView(decoder, 8).getBigInt64(0, false);
var readAnyLookupTable = [
  (decoder) => void 0,
  (decoder) => null,
  readVarInt,
  readFloat32,
  readFloat64,
  readBigInt64,
  (decoder) => false,
  (decoder) => true,
  readVarString,
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i8 = 0; i8 < len; i8++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i8 = 0; i8 < len; i8++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return this.s;
  }
};
var UintOptRleDecoder = class extends Decoder {
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return this.s;
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = diff >> 1;
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// ../../node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s9 = "";
  for (let i8 = 0; i8 < bytes.byteLength; i8++) {
    s9 += fromCharCode(bytes[i8]);
  }
  return btoa(s9);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s9) => {
  const a7 = atob(s9);
  const bytes = createUint8ArrayFromLen(a7.length);
  for (let i8 = 0; i8 < a7.length; i8++) {
    bytes[i8] = a7.charCodeAt(i8);
  }
  return bytes;
};
var fromBase64Node = (s9) => {
  const buf = Buffer.from(s9, "base64");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser3 ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser3 ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// ../../node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// ../../node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i8 = 0; i8 < encoder.bufs.length; i8++) {
    len += encoder.bufs[i8].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i8 = 0; i8 < encoder.bufs.length; i8++) {
    const d7 = encoder.bufs[i8];
    uint8arr.set(d7, curPos);
    curPos += d7.length;
  }
  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num >>>= 7;
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num >>>= 6;
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num >>>= 7;
  }
};
var writeVarString = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i8 = 0; i8 < len; i8++) {
    write(encoder, encodedString.codePointAt(i8));
  }
};
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => writeOnDataView(encoder, 8).setBigInt64(0, num, false);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (data instanceof Array) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i8 = 0; i8 < data.length; i8++) {
          writeAny(encoder, data[i8]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i8 = 0; i8 < keys2.length; i8++) {
          const key = keys2[i8];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v6);
      this.s = v6;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v6;
    }
  }
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  write(v6) {
    if (this.diff === v6 - this.s) {
      this.s = v6;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v6 - this.s;
      this.s = v6;
    }
  }
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// ../../node_modules/isomorphic.js/browser.mjs
var performance2 = typeof window === "undefined" ? null : typeof window.performance !== "undefined" && window.performance || null;
var isoCrypto = typeof crypto === "undefined" ? null : crypto;
var cryptoRandomBuffer = isoCrypto !== null ? (len) => {
  const buf = new ArrayBuffer(len);
  const arr = new Uint8Array(buf);
  isoCrypto.getRandomValues(arr);
  return buf;
} : (len) => {
  const buf = new ArrayBuffer(len);
  const arr = new Uint8Array(buf);
  for (let i8 = 0; i8 < len; i8++) {
    arr[i8] = Math.ceil(Math.random() * 4294967295 >>> 0);
  }
  return buf;
};

// ../../node_modules/lib0/random.js
var uint32 = () => new Uint32Array(cryptoRandomBuffer(4))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(/[018]/g, (c8) => (c8 ^ uint32() & 15 >> c8 / 4).toString(16));

// ../../node_modules/lib0/time.js
var getUnixTime = Date.now;

// ../../node_modules/lib0/promise.js
var create4 = (f10) => new Promise(f10);

// ../../node_modules/lib0/error.js
var create5 = (s9) => new Error(s9);
var methodUnimplemented = () => {
  throw create5("Method unimplemented");
};
var unexpectedCase = () => {
  throw create5("Unexpected case");
};

// ../../node_modules/lib0/object.js
var keys = Object.keys;
var map3 = (obj, f10) => {
  const results = [];
  for (const key in obj) {
    results.push(f10(obj[key], key));
  }
  return results;
};
var length2 = (obj) => keys(obj).length;
var every = (obj, f10) => {
  for (const key in obj) {
    if (!f10(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a7, b7) => a7 === b7 || length2(a7) === length2(b7) && every(a7, (val, key) => (val !== void 0 || hasProperty(b7, key)) && b7[key] === val);

// ../../node_modules/lib0/function.js
var callAll = (fs, args2, i8 = 0) => {
  try {
    for (; i8 < fs.length; i8++) {
      fs[i8](...args2);
    }
  } finally {
    if (i8 < fs.length) {
      callAll(fs, args2, i8 + 1);
    }
  }
};
var equalityStrict = (a7, b7) => a7 === b7;
var equalityDeep = (a7, b7) => {
  if (a7 == null || b7 == null) {
    return equalityStrict(a7, b7);
  }
  if (a7.constructor !== b7.constructor) {
    return false;
  }
  if (a7 === b7) {
    return true;
  }
  switch (a7.constructor) {
    case ArrayBuffer:
      a7 = new Uint8Array(a7);
      b7 = new Uint8Array(b7);
    case Uint8Array: {
      if (a7.byteLength !== b7.byteLength) {
        return false;
      }
      for (let i8 = 0; i8 < a7.length; i8++) {
        if (a7[i8] !== b7[i8]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a7.size !== b7.size) {
        return false;
      }
      for (const value of a7) {
        if (!b7.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a7.size !== b7.size) {
        return false;
      }
      for (const key of a7.keys()) {
        if (!b7.has(key) || !equalityDeep(a7.get(key), b7.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a7) !== length2(b7)) {
        return false;
      }
      for (const key in a7) {
        if (!hasProperty(a7, key) || !equalityDeep(a7[key], b7[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a7.length !== b7.length) {
        return false;
      }
      for (let i8 = 0; i8 < a7.length; i8++) {
        if (!equalityDeep(a7[i8], b7[i8])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};

// ../../node_modules/lib0/symbol.js
var create6 = Symbol;

// ../../node_modules/lib0/pair.js
var Pair = class {
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create7 = (left, right) => new Pair(left, right);

// ../../node_modules/lib0/dom.js
var doc = typeof document !== "undefined" ? document : {};
var domParser = typeof DOMParser !== "undefined" ? new DOMParser() : null;
var mapToStyleString = (m8) => map2(m8, (value, key) => `${key}:${value};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// ../../node_modules/lib0/logging.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var _browserStyleMap = {
  [BOLD]: create7("font-weight", "bold"),
  [UNBOLD]: create7("font-weight", "normal"),
  [BLUE]: create7("color", "blue"),
  [GREEN]: create7("color", "green"),
  [GREY]: create7("color", "grey"),
  [RED]: create7("color", "red"),
  [PURPLE]: create7("color", "purple"),
  [ORANGE]: create7("color", "orange"),
  [UNCOLOR]: create7("color", "black")
};
var _nodeStyleMap = {
  [BOLD]: "\x1B[1m",
  [UNBOLD]: "\x1B[2m",
  [BLUE]: "\x1B[34m",
  [GREEN]: "\x1B[32m",
  [GREY]: "\x1B[37m",
  [RED]: "\x1B[31m",
  [PURPLE]: "\x1B[35m",
  [ORANGE]: "\x1B[38;5;208m",
  [UNCOLOR]: "\x1B[0m"
};
var computeBrowserLoggingArgs = (args2) => {
  const strBuilder = [];
  const styles3 = [];
  const currentStyle = create2();
  let logArgs = [];
  let i8 = 0;
  for (; i8 < args2.length; i8++) {
    const arg = args2[i8];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i8 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles3.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i8 > 0) {
    logArgs = styles3;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i8 < args2.length; i8++) {
    const arg = args2[i8];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeNodeLoggingArgs = (args2) => {
  const strBuilder = [];
  const logArgs = [];
  let i8 = 0;
  for (; i8 < args2.length; i8++) {
    const arg = args2[i8];
    const style = _nodeStyleMap[arg];
    if (style !== void 0) {
      strBuilder.push(style);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        strBuilder.push(arg);
      } else {
        break;
      }
    }
  }
  if (i8 > 0) {
    strBuilder.push("\x1B[0m");
    logArgs.push(strBuilder.join(""));
  }
  for (; i8 < args2.length; i8++) {
    const arg = args2[i8];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = /* @__PURE__ */ new Set();
var lastLoggingTime = getUnixTime();

// ../../node_modules/lib0/iterator.js
var createIterator = (next) => ({
  [Symbol.iterator]() {
    return this;
  },
  next
});
var iteratorFilter = (iterator, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// ../../node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction2, ds, f10) => ds.clients.forEach((deletes, clientid) => {
  const structs = transaction2.doc.store.clients.get(clientid);
  for (let i8 = 0; i8 < deletes.length; i8++) {
    const del = deletes[i8];
    iterateStructs(transaction2, structs, del.clock, del.len, f10);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id) => {
  const dis = ds.clients.get(id.client);
  return dis !== void 0 && findIndexDS(dis, id.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a7, b7) => a7.clock - b7.clock);
    let i8, j4;
    for (i8 = 1, j4 = 1; i8 < dels.length; i8++) {
      const left = dels[j4 - 1];
      const right = dels[i8];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j4 < i8) {
          dels[j4] = right;
        }
        j4++;
      }
    }
    dels.length = j4;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i8 = dssI + 1; i8 < dss.length; i8++) {
          appendTo(dels, dss[i8].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length3) => {
  setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length3));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i8 = 0; i8 < structs.length; i8++) {
      const struct = structs[i8];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i8 + 1 < structs.length) {
          for (let next = structs[i8 + 1]; i8 + 1 < structs.length && next.deleted; next = structs[++i8 + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  ds.clients.forEach((dsitems, client) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i8 = 0; i8 < len; i8++) {
      const item = dsitems[i8];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i8 = 0; i8 < numClients; i8++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => []);
      for (let i9 = 0; i9 < numberOfDeletes; i9++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction2, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i8 = 0; i8 < numClients; i8++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i9 = 0; i9 < numberOfDeletes; i9++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index2 = findIndexSS(structs, clock);
        let struct = structs[index2];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index2 + 1, 0, splitItem(transaction2, struct, clock - struct.id.clock));
          index2++;
        }
        while (index2 < structs.length) {
          struct = structs[index2++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index2, 0, splitItem(transaction2, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction2);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends Observable {
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
  }
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(item.parent.doc, (transaction2) => {
        transaction2.subdocsLoaded.add(this);
      }, null, true);
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Array.from(this.subdocs).map((doc3) => doc3.guid));
  }
  transact(f10, origin = null) {
    transact(this, f10, origin);
  }
  get(name, TypeConstructor = AbstractType) {
    const type = setIfUndefined(this.share, name, () => {
      const t12 = new TypeConstructor();
      t12._integrate(this, null);
      return t12;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t12 = new TypeConstructor();
        t12._map = type._map;
        type._map.forEach((n6) => {
          for (; n6 !== null; n6 = n6.left) {
            n6.parent = t12;
          }
        });
        t12._start = type._start;
        for (let n6 = t12._start; n6 !== null; n6 = n6.right) {
          n6.parent = t12;
        }
        t12._length = type._length;
        this.share.set(name, t12);
        t12._integrate(this, null);
        return t12;
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return type;
  }
  getArray(name = "") {
    return this.get(name, YArray);
  }
  getText(name = "") {
    return this.get(name, YText);
  }
  getMap(name = "") {
    return this.get(name, YMap);
  }
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  toJSON() {
    const doc3 = {};
    this.share.forEach((value, key) => {
      doc3[key] = value.toJSON();
    });
    return doc3;
  }
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = item.content;
      content.doc = new Doc(__spreadProps(__spreadValues({ guid: this.guid }, content.opts), { shouldLoad: false }));
      content.doc._item = item;
      transact(item.parent.doc, (transaction2) => {
        const doc3 = content.doc;
        if (!item.deleted) {
          transaction2.subdocsAdded.add(doc3);
        }
        transaction2.subdocsRemoved.add(this);
      }, null, true);
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
  on(eventName, f10) {
    super.on(eventName, f10);
  }
  off(eventName, f10) {
    super.off(eventName, f10);
  }
};
var DSDecoderV1 = class {
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  readClient() {
    return readVarUint(this.restDecoder);
  }
  readInfo() {
    return readUint8(this.restDecoder);
  }
  readString() {
    return readVarString(this.restDecoder);
  }
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  readLen() {
    return readVarUint(this.restDecoder);
  }
  readAny() {
    return readAny(this.restDecoder);
  }
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  readClient() {
    return this.clientDecoder.read();
  }
  readInfo() {
    return this.infoDecoder.read();
  }
  readString() {
    return this.stringDecoder.read();
  }
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  readLen() {
    return this.lenDecoder.read();
  }
  readAny() {
    return readAny(this.restDecoder);
  }
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  readJSON() {
    return readAny(this.restDecoder);
  }
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  writeLeftID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  writeRightID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  writeString(s9) {
    writeVarString(this.restEncoder, s9);
  }
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  writeLeftID(id) {
    this.clientEncoder.write(id.client);
    this.leftClockEncoder.write(id.clock);
  }
  writeRightID(id) {
    this.clientEncoder.write(id.client);
    this.rightClockEncoder.write(id.clock);
  }
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  writeString(s9) {
    this.stringEncoder.write(s9);
  }
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(this.keyClock++);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i8 = startNewStructs + 1; i8 < structs.length; i8++) {
    structs[i8].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  Array.from(sm.entries()).sort((a7, b7) => b7[0] - a7[0]).forEach(([client, clock]) => {
    writeStructs(encoder, store.clients.get(client), client, clock);
  });
};
var readClientsStructRefs = (decoder, doc3) => {
  const clientRefs = create2();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i8 = 0; i8 < numOfStateUpdates; i8++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i9 = 0; i9 < numberOfStructs; i9++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i9] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i9] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item4(createID(client, clock), null, (info & BIT8) === BIT8 ? decoder.readLeftID() : null, null, (info & BIT7) === BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc3.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null, readItemContent(decoder, info));
          refs[i9] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction2, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a7, b7) => a7 - b7);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null && stack.length === 0) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = curStructsTarget.refs[curStructsTarget.i++];
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c8) => c8 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction2, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(missing) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(missing, getState(store, missing));
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction2, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction2) => writeClientsStructs(encoder, transaction2.doc.store, transaction2.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction2) => {
  transaction2.local = false;
  let retry = false;
  const doc3 = transaction2.doc;
  const store = doc3.store;
  const ss = readClientsStructRefs(structDecoder, doc3);
  const restStructs = integrateStructs(transaction2, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction2, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction2, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = store.pendingStructs.update;
    store.pendingStructs = null;
    applyUpdateV2(transaction2.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc3, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc3.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc3.store));
};
var encodeStateAsUpdateV2 = (doc3, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc3, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc3.store.pendingDs) {
    updates.push(doc3.store.pendingDs);
  }
  if (doc3.store.pendingStructs) {
    updates.push(diffUpdateV2(doc3.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i8) => i8 === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc3, encodedTargetStateVector) => encodeStateAsUpdateV2(doc3, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i8 = 0; i8 < ssLength; i8++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  Array.from(sv.entries()).sort((a7, b7) => b7[0] - a7[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc3) => writeStateVector(encoder, getStateVector(doc3.store));
var encodeStateVectorV2 = (doc3, encoder = new DSEncoderV2()) => {
  if (doc3 instanceof Map) {
    writeStateVector(encoder, doc3);
  } else {
    writeDocumentStateVector(encoder, doc3);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc3) => encodeStateVectorV2(doc3, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler2, f10) => eventHandler2.l.push(f10);
var removeEventHandlerListener = (eventHandler2, f10) => {
  const l9 = eventHandler2.l;
  const len = l9.length;
  eventHandler2.l = l9.filter((g6) => f10 !== g6);
  if (len === eventHandler2.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler2, arg0, arg1) => callAll(eventHandler2.l, [arg0, arg1]);
var ID = class {
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a7, b7) => a7 === b7 || a7 !== null && b7 !== null && a7.client === b7.client && a7.clock === b7.clock;
var createID = (client, clock) => new ID(client, clock);
var writeID = (encoder, id) => {
  writeVarUint(encoder, id.client);
  writeVarUint(encoder, id.clock);
};
var readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = child.parent._item;
  }
  return false;
};
var lengthExceeded = create5("Length exceeded!");
var ListIterator = class {
  constructor(type) {
    this.type = type;
    this.index = 0;
    this.rel = 0;
    this.nextItem = type._start;
    this.reachedEnd = type._start === null;
    this.currMove = null;
    this.currMoveStart = null;
    this.currMoveEnd = null;
    this.movedStack = [];
  }
  clone() {
    const iter = new ListIterator(this.type);
    iter.index = this.index;
    iter.rel = this.rel;
    iter.nextItem = this.nextItem;
    iter.reachedEnd = this.reachedEnd;
    iter.currMove = this.currMove;
    iter.currMoveStart = this.currMoveStart;
    iter.currMoveEnd = this.currMoveEnd;
    iter.movedStack = this.movedStack.slice();
    return iter;
  }
  get left() {
    if (this.reachedEnd) {
      return this.nextItem;
    } else {
      return this.nextItem && this.nextItem.left;
    }
  }
  get right() {
    if (this.reachedEnd) {
      return null;
    } else {
      return this.nextItem;
    }
  }
  moveTo(tr, index2) {
    const diff = index2 - this.index;
    if (diff > 0) {
      this.forward(tr, diff);
    } else if (diff < 0) {
      this.backward(tr, -diff);
    }
  }
  forward(tr, len) {
    if (this.index + len > this.type._length) {
      throw lengthExceeded;
    }
    let item = this.nextItem;
    this.index += len;
    if (this.rel) {
      len += this.rel;
      this.rel = 0;
    }
    while ((!this.reachedEnd || this.currMove !== null) && (len > 0 || len === 0 && item && (!item.countable || item.deleted || item === this.currMoveEnd || this.reachedEnd && this.currMoveEnd === null || item.moved !== this.currMove))) {
      if (item === this.currMoveEnd || this.currMoveEnd === null && this.reachedEnd && this.currMove) {
        item = this.currMove;
        const { start, end, move } = this.movedStack.pop() || { start: null, end: null, move: null };
        this.currMove = move;
        this.currMoveStart = start;
        this.currMoveEnd = end;
        this.reachedEnd = false;
      } else if (item === null) {
        break;
      } else if (item.countable && !item.deleted && item.moved === this.currMove && len > 0) {
        len -= item.length;
        if (len < 0) {
          this.rel = item.length + len;
          len = 0;
          break;
        }
      } else if (item.content.constructor === ContentMove && item.moved === this.currMove) {
        if (this.currMove) {
          this.movedStack.push({ start: this.currMoveStart, end: this.currMoveEnd, move: this.currMove });
        }
        const { start, end } = getMovedCoords(item.content, tr);
        this.currMove = item;
        this.currMoveStart = start;
        this.currMoveEnd = end;
        item = start;
        continue;
      }
      if (item.right) {
        item = item.right;
      } else {
        this.reachedEnd = true;
      }
    }
    this.index -= len;
    this.nextItem = item;
    return this;
  }
  reduceMoves(tr) {
    let item = this.nextItem;
    if (item !== null) {
      while (item === this.currMoveStart) {
        item = this.currMove;
        const { start, end, move } = this.movedStack.pop() || { start: null, end: null, move: null };
        this.currMove = move;
        this.currMoveStart = start;
        this.currMoveEnd = end;
      }
      this.nextItem = item;
    }
  }
  backward(tr, len) {
    if (this.index - len < 0) {
      throw lengthExceeded;
    }
    this.index -= len;
    if (this.reachedEnd) {
      const nextItem = this.nextItem;
      this.rel = nextItem.countable && !nextItem.deleted ? nextItem.length : 0;
      this.reachedEnd = false;
    }
    if (this.rel >= len) {
      this.rel -= len;
      return this;
    }
    let item = this.nextItem && this.nextItem.left;
    if (this.rel) {
      len -= this.rel;
      this.rel = 0;
    }
    while (item && len > 0) {
      if (item.countable && !item.deleted && item.moved === this.currMove) {
        len -= item.length;
        if (len < 0) {
          this.rel = -len;
          len = 0;
        }
        if (len === 0) {
          break;
        }
      } else if (item.content.constructor === ContentMove && item.moved === this.currMove) {
        if (this.currMove) {
          this.movedStack.push({ start: this.currMoveStart, end: this.currMoveEnd, move: this.currMove });
        }
        const { start, end } = getMovedCoords(item.content, tr);
        this.currMove = item;
        this.currMoveStart = start;
        this.currMoveEnd = end;
        item = start;
        continue;
      }
      if (item === this.currMoveStart) {
        item = this.currMove;
        const { start, end, move } = this.movedStack.pop() || { start: null, end: null, move: null };
        this.currMove = move;
        this.currMoveStart = start;
        this.currMoveEnd = end;
      }
      item = item.left;
    }
    this.nextItem = item;
    return this;
  }
  _slice(tr, len, value, slice, concat) {
    this.index += len;
    while (len > 0 && !this.reachedEnd) {
      while (this.nextItem && this.nextItem.countable && !this.reachedEnd && len > 0 && this.nextItem !== this.currMoveEnd) {
        if (!this.nextItem.deleted && this.nextItem.moved === this.currMove) {
          const item = this.nextItem;
          const slicedContent = slice(item.content, this.rel, len);
          len -= slicedContent.length;
          value = concat(value, slicedContent);
          if (item.length !== slicedContent.length) {
            if (this.rel + slicedContent.length === item.length) {
              this.rel = 0;
            } else {
              this.rel += slicedContent.length;
              continue;
            }
          }
        }
        if (this.nextItem.right) {
          this.nextItem = this.nextItem.right;
        } else {
          this.reachedEnd = true;
        }
      }
      if (this.nextItem && (!this.reachedEnd || this.currMove !== null) && len > 0) {
        this.forward(tr, 0);
      }
    }
    if (len < 0) {
      this.index -= len;
    }
    return value;
  }
  delete(tr, len) {
    const startLength = len;
    const sm = this.type._searchMarker;
    let item = this.nextItem;
    while (len > 0) {
      while (item && !item.deleted && item.countable && !this.reachedEnd && len > 0 && item.moved === this.currMove && item !== this.currMoveEnd) {
        if (this.rel > 0) {
          item = getItemCleanStart(tr, createID(item.id.client, item.id.clock + this.rel));
          this.rel = 0;
        }
        if (len < item.length) {
          getItemCleanStart(tr, createID(item.id.client, item.id.clock + len));
        }
        len -= item.length;
        item.delete(tr);
        if (item.right) {
          item = item.right;
        } else {
          this.reachedEnd = true;
        }
      }
      if (len > 0) {
        this.nextItem = item;
        this.forward(tr, 0);
        item = this.nextItem;
      }
    }
    this.nextItem = item;
    if (sm) {
      updateMarkerChanges(sm, this.index, -startLength + len, this);
    }
  }
  _splitRel(tr) {
    if (this.rel > 0) {
      const itemid = this.nextItem.id;
      this.nextItem = getItemCleanStart(tr, createID(itemid.client, itemid.clock + this.rel));
      this.rel = 0;
    }
  }
  insertContents(tr, content) {
    this.reduceMoves(tr);
    this._splitRel(tr);
    const parent = this.type;
    const store = tr.doc.store;
    const ownClientId = tr.doc.clientID;
    const right = this.right;
    let left = this.left;
    content.forEach((c8) => {
      left = new Item4(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, c8);
      left.integrate(tr, 0);
    });
    if (right === null) {
      this.nextItem = left;
      this.reachedEnd = true;
    } else {
      this.nextItem = right;
    }
  }
  insertMove(tr, start, end) {
    this.insertContents(tr, [new ContentMove(start, end, -1)]);
    const sm = this.type._searchMarker;
    if (sm)
      sm.length = 0;
  }
  insertArrayValue(tr, values) {
    this._splitRel(tr);
    const sm = this.type._searchMarker;
    const contents = [];
    let jsonContent = [];
    const packJsonContent = () => {
      if (jsonContent.length > 0) {
        contents.push(new ContentAny(jsonContent));
        jsonContent = [];
      }
    };
    values.forEach((c8) => {
      if (c8 === null) {
        jsonContent.push(c8);
      } else {
        switch (c8.constructor) {
          case Number:
          case Object:
          case Boolean:
          case Array:
          case String:
            jsonContent.push(c8);
            break;
          default:
            packJsonContent();
            switch (c8.constructor) {
              case Uint8Array:
              case ArrayBuffer:
                contents.push(new ContentBinary(new Uint8Array(c8)));
                break;
              case Doc:
                contents.push(new ContentDoc(c8));
                break;
              default:
                if (c8 instanceof AbstractType) {
                  contents.push(new ContentType(c8));
                } else {
                  throw new Error("Unexpected content type in insert operation");
                }
            }
        }
      }
    });
    packJsonContent();
    this.insertContents(tr, contents);
    this.index += values.length;
    if (sm) {
      updateMarkerChanges(sm, this.index - values.length, values.length, this);
    }
  }
  slice(tr, len) {
    return this._slice(tr, len, [], sliceArrayContent, concatArrayContent);
  }
  forEach(tr, f10) {
    for (const val of this.values(tr)) {
      f10(val, this.index, this.type);
    }
  }
  map(tr, f10) {
    const arr = new Array(this.type._length - this.index);
    let i8 = 0;
    for (const val of this.values(tr)) {
      arr[i8++] = f10(val, this.index, this.type);
    }
    return arr;
  }
  values(tr) {
    return {
      [Symbol.iterator]() {
        return this;
      },
      next: () => {
        if (this.reachedEnd || this.index === this.type._length) {
          return { done: true };
        }
        const [value] = this.slice(tr, 1);
        return {
          done: false,
          value
        };
      }
    };
  }
};
var sliceArrayContent = (itemcontent, start, len) => {
  const content = itemcontent.getContent();
  return content.length <= len && start === 0 ? content : content.slice(start, start + len);
};
var concatArrayContent = (content, added) => {
  content.push(...added);
  return content;
};
var RelativePosition = class {
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
  clone() {
    return new RelativePosition(this.type, this.tname, this.item, this.assoc);
  }
};
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index2, assoc = 0) => {
  if (assoc < 0) {
    if (index2 === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index2--;
  }
  return transact(type.doc, (tr) => useSearchMarker(tr, type, index2, (walker) => {
    if (walker.reachedEnd) {
      const item = assoc < 0 ? walker.nextItem.lastId : null;
      return createRelativePosition(type, item, assoc);
    } else {
      const id = walker.nextItem.id;
      return createRelativePosition(type, createID(id.client, id.clock + walker.rel), assoc);
    }
  }));
};
var writeRelativePosition = (encoder, rpos) => {
  const { type, tname, item, assoc } = rpos;
  if (item !== null) {
    writeVarUint(encoder, 0);
    writeID(encoder, item);
  } else if (tname !== null) {
    writeUint8(encoder, 1);
    writeVarString(encoder, tname);
  } else if (type !== null) {
    writeUint8(encoder, 2);
    writeID(encoder, type);
  } else {
    throw unexpectedCase();
  }
  writeVarInt(encoder, assoc);
  return encoder;
};
var encodeRelativePosition = (rpos) => {
  const encoder = createEncoder();
  writeRelativePosition(encoder, rpos);
  return toUint8Array(encoder);
};
var readRelativePosition = (decoder) => {
  let type = null;
  let tname = null;
  let itemID = null;
  switch (readVarUint(decoder)) {
    case 0:
      itemID = readID(decoder);
      break;
    case 1:
      tname = readVarString(decoder);
      break;
    case 2: {
      type = readID(decoder);
    }
  }
  const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;
  return new RelativePosition(type, tname, itemID, assoc);
};
var decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));
var Snapshot = class {
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction2, snapshot) => {
  const meta = setIfUndefined(transaction2.meta, splitSnapshotAffectedStructs, create3);
  const store = transaction2.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction2, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction2, snapshot.ds, (item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id) => {
  const structs = store.clients.get(id.client);
  return structs[findIndexSS(structs, id.clock)];
};
var getItem = find;
var findIndexCleanStart = (transaction2, structs, clock) => {
  const index2 = findIndexSS(structs, clock);
  const struct = structs[index2];
  if (struct.id.clock < clock && struct instanceof Item4) {
    structs.splice(index2 + 1, 0, splitItem(transaction2, struct, clock - struct.id.clock));
    return index2 + 1;
  }
  return index2;
};
var getItemCleanStart = (transaction2, id) => {
  const structs = transaction2.doc.store.clients.get(id.client);
  return structs[findIndexCleanStart(transaction2, structs, id.clock)];
};
var getItemCleanEnd = (transaction2, id) => {
  const structs = transaction2.doc.store.clients.get(id.client);
  const index2 = findIndexSS(structs, id.clock);
  const struct = structs[index2];
  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index2 + 1, 0, splitItem(transaction2, struct, id.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = store.clients.get(struct.id.client);
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction2, structs, clockStart, len, f10) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index2 = findIndexCleanStart(transaction2, structs, clockStart);
  let struct;
  do {
    struct = structs[index2++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction2, structs, clockEnd);
    }
    f10(struct);
  } while (index2 < structs.length && structs[index2].id.clock < clockEnd);
};
var Transaction = class {
  constructor(doc3, origin, local) {
    this.doc = doc3;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc3.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this.prevMoved = /* @__PURE__ */ new Map();
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction2) => {
  if (transaction2.deleteSet.clients.size === 0 && !any(transaction2.afterState, (clock, client) => transaction2.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction2.deleteSet);
  writeStructsFromTransaction(encoder, transaction2);
  writeDeleteSet(encoder, transaction2.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction2, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction2.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction2.changed, type, create3).add(parentSub);
  }
};
var tryToMergeWithLeft = (structs, pos) => {
  const left = structs[pos - 1];
  const right = structs[pos];
  if (left.deleted === right.deleted && left.constructor === right.constructor) {
    if (left.mergeWith(right)) {
      structs.splice(pos, 1);
      if (right instanceof Item4 && right.parentSub !== null && right.parent._map.get(right.parentSub) === right) {
        right.parent._map.set(right.parentSub, left);
      }
    }
  }
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = store.clients.get(client);
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item4 && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = store.clients.get(client);
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[--si]) {
        tryToMergeWithLeft(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i8) => {
  if (i8 < transactionCleanups.length) {
    const transaction2 = transactionCleanups[i8];
    const doc3 = transaction2.doc;
    const store = doc3.store;
    const ds = transaction2.deleteSet;
    const mergeStructs = transaction2._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction2.afterState = getStateVector(transaction2.doc.store);
      doc3._transaction = null;
      doc3.emit("beforeObserverCalls", [transaction2, doc3]);
      const fs = [];
      transaction2.changed.forEach((subs, itemtype) => fs.push(() => {
        if (itemtype._item === null || !itemtype._item.deleted) {
          itemtype._callObserver(transaction2, subs);
        }
      }));
      fs.push(() => {
        transaction2.changedParentTypes.forEach((events, type) => fs.push(() => {
          if (type._item === null || !type._item.deleted) {
            events = events.filter((event) => event.target._item === null || !event.target._item.deleted);
            events.forEach((event) => {
              event.currentTarget = type;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction2);
          }
        }));
        fs.push(() => doc3.emit("afterTransaction", [transaction2, doc3]));
      });
      callAll(fs, []);
    } finally {
      if (doc3.gc) {
        tryGcDeleteSet(ds, store, doc3.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction2.afterState.forEach((clock, client) => {
        const beforeClock = transaction2.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = store.clients.get(client);
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i9 = structs.length - 1; i9 >= firstChangePos; i9--) {
            tryToMergeWithLeft(structs, i9);
          }
        }
      });
      for (let i9 = 0; i9 < mergeStructs.length; i9++) {
        const { client, clock } = mergeStructs[i9].id;
        const structs = store.clients.get(client);
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          tryToMergeWithLeft(structs, replacedStructPos + 1);
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLeft(structs, replacedStructPos);
        }
      }
      if (!transaction2.local && transaction2.afterState.get(doc3.clientID) !== transaction2.beforeState.get(doc3.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc3.clientID = generateNewClientId();
      }
      doc3.emit("afterTransactionCleanup", [transaction2, doc3]);
      if (doc3._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction2);
        if (hasContent2) {
          doc3.emit("update", [encoder.toUint8Array(), transaction2.origin, doc3, transaction2]);
        }
      }
      if (doc3._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction2);
        if (hasContent2) {
          doc3.emit("updateV2", [encoder.toUint8Array(), transaction2.origin, doc3, transaction2]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction2;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc3.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc3.collectionid;
          }
          doc3.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc3.subdocs.delete(subdoc));
        doc3.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc3, transaction2]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i8 + 1) {
        doc3._transactionCleanups = [];
        doc3.emit("afterAllTransactions", [doc3, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i8 + 1);
      }
    }
  }
};
var transact = (doc3, f10, origin = null, local = true) => {
  const transactionCleanups = doc3._transactionCleanups;
  let initialCall = false;
  if (doc3._transaction === null) {
    initialCall = true;
    doc3._transaction = new Transaction(doc3, origin, local);
    transactionCleanups.push(doc3._transaction);
    if (transactionCleanups.length === 1) {
      doc3.emit("beforeAllTransactions", [doc3]);
    }
    doc3.emit("beforeTransaction", [doc3._transaction, doc3]);
  }
  let res;
  try {
    res = f10(doc3._transaction);
  } finally {
    if (initialCall && transactionCleanups[0] === doc3._transaction) {
      cleanupTransactions(transactionCleanups, 0);
    }
  }
  return res;
};
var StackItem = class {
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var popStackItem = (undoManager2, stack, eventType) => {
  let result = null;
  let _tr = null;
  const doc3 = undoManager2.doc;
  const scope = undoManager2.scope;
  transact(doc3, (transaction2) => {
    while (stack.length > 0 && result === null) {
      const store = doc3.store;
      const stackItem = stack.pop();
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction2, stackItem.insertions, (struct) => {
        if (struct instanceof Item4) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction2, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type) => isParentOf(type, struct))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction2, stackItem.deletions, (struct) => {
        if (struct instanceof Item4 && scope.some((type) => isParentOf(type, struct)) && !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction2, struct, itemsToRedo, itemsToDelete) !== null || performedChange;
      });
      for (let i8 = itemsToDelete.length - 1; i8 >= 0; i8--) {
        const item = itemsToDelete[i8];
        if (undoManager2.deleteFilter(item)) {
          item.delete(transaction2);
          performedChange = true;
        }
      }
      result = performedChange ? stackItem : null;
    }
    transaction2.changed.forEach((subProps, type) => {
      if (subProps.has(null) && type._searchMarker) {
        type._searchMarker.length = 0;
      }
    });
    _tr = transaction2;
  }, undoManager2);
  if (result != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager2.emit("stack-item-popped", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager2]);
  }
  return result;
};
var UndoManager = class extends Observable {
  constructor(typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = /* @__PURE__ */ new Set([null]) } = {}) {
    super();
    this.scope = typeScope instanceof Array ? typeScope : [typeScope];
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.doc = this.scope[0].doc;
    this.lastChange = 0;
    this.doc.on("afterTransaction", (transaction2) => {
      if (!this.scope.some((type) => transaction2.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction2.origin) && (!transaction2.origin || !this.trackedOrigins.has(transaction2.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.redoStack = [];
      }
      const insertions = new DeleteSet();
      transaction2.afterState.forEach((endClock, client) => {
        const startClock = transaction2.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction2.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction2.deleteSet, insertions));
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(transaction2, transaction2.deleteSet, (item) => {
        if (item instanceof Item4 && this.scope.some((type) => isParentOf(type, item))) {
          keepItem(item, true);
        }
      });
      this.emit("stack-item-added", [{ stackItem: stack[stack.length - 1], origin: transaction2.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction2.changedParentTypes }, this]);
    });
  }
  clear() {
    this.doc.transact((transaction2) => {
      const clearItem = (stackItem) => {
        iterateDeletedStructs(transaction2, stackItem.deletions, (item) => {
          if (item instanceof Item4 && this.scope.some((type) => isParentOf(type, item))) {
            keepItem(item, false);
          }
        });
      };
      this.undoStack.forEach(clearItem);
      this.redoStack.forEach(clearItem);
    });
    this.undoStack = [];
    this.redoStack = [];
  }
  stopCapturing() {
    this.lastChange = 0;
  }
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i8 = 0; i8 < numOfStateUpdates; i8++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i9 = 0; i9 < numberOfStructs; i9++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item4(createID(client, clock), null, (info & BIT8) === BIT8 ? decoder.readLeftID() : null, null, (info & BIT7) === BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null, readItemContent(decoder, info));
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = left;
    const { client, clock } = leftItem.id;
    return new Item4(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort((dec1, dec2) => {
      if (dec1.curr.id.client === dec2.curr.id.client) {
        const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
        if (clockDiff === 0) {
          return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
        } else {
          return clockDiff;
        }
      } else {
        return dec2.curr.id.client - dec1.curr.id.client;
      }
    });
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = currDecoder.curr.id.client;
    if (currWrite !== null) {
      let curr = currDecoder.curr;
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || curr.id.client !== firstClient || iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(curr)) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: currDecoder.curr, offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i8 = 0; i8 < lazyWriter.clientStructs.length; i8++) {
    const partStructs = lazyWriter.clientStructs[i8];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, curr, 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, UpdateDecoderV2, UpdateEncoderV1);
var YEvent = class {
  constructor(target, transaction2) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction2;
    this._changes = null;
    this._keys = null;
    this._delta = null;
  }
  get path() {
    return getPathTo(this.currentTarget, this.target);
  }
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  get keys() {
    if (this._keys === null) {
      const keys2 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = this.transaction.changed.get(target);
      changed.forEach((key) => {
        if (key !== null) {
          const item = target._map.get(key);
          let action2;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action2 = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action2 = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action2 = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action2 = "delete";
              oldValue = last(item.content.getContent());
            } else {
              return;
            }
          }
          keys2.set(key, { action: action2, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  get delta() {
    return this.changes.delta;
  }
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      this.transaction.doc.transact((tr) => {
        const target = this.target;
        const added = create3();
        const deleted = create3();
        const delta = [];
        changes = {
          added,
          deleted,
          delta,
          keys: this.keys
        };
        const changed = this.transaction.changed.get(target);
        if (changed.has(null)) {
          const movedStack = [];
          let currMove = null;
          let currMoveIsNew = false;
          let currMoveEnd = null;
          let lastOp = null;
          const packOp = () => {
            if (lastOp) {
              delta.push(lastOp);
            }
          };
          for (let item = target._start; ; ) {
            if (item === currMoveEnd && currMove) {
              item = currMove;
              const { end, move, isNew } = movedStack.pop() || { end: null, move: null, isNew: false };
              currMoveIsNew = isNew;
              currMoveEnd = end;
              currMove = move;
            } else if (item === null) {
              break;
            } else if (item.content.constructor === ContentMove) {
              if (item.moved === currMove) {
                movedStack.push({ end: currMoveEnd, move: currMove, isNew: currMoveIsNew });
                const { start, end } = getMovedCoords(item.content, tr);
                currMove = item;
                currMoveEnd = end;
                currMoveIsNew = this.adds(item);
                item = start;
                continue;
              }
            } else if (item.moved !== currMove) {
              if (!currMoveIsNew && item.countable && item.moved && !this.adds(item) && this.adds(item.moved) && (this.transaction.prevMoved.get(item) || null) === currMove) {
                if (lastOp === null || lastOp.delete === void 0) {
                  packOp();
                  lastOp = { delete: 0 };
                }
                lastOp.delete += item.length;
              }
            } else if (item.deleted) {
              if (!currMoveIsNew && this.deletes(item) && !this.adds(item)) {
                if (lastOp === null || lastOp.delete === void 0) {
                  packOp();
                  lastOp = { delete: 0 };
                }
                lastOp.delete += item.length;
                deleted.add(item);
              }
            } else {
              if (currMoveIsNew || this.adds(item)) {
                if (lastOp === null || lastOp.insert === void 0) {
                  packOp();
                  lastOp = { insert: [] };
                }
                lastOp.insert = lastOp.insert.concat(item.content.getContent());
                added.add(item);
              } else {
                if (lastOp === null || lastOp.retain === void 0) {
                  packOp();
                  lastOp = { retain: 0 };
                }
                lastOp.retain += item.length;
              }
            }
            item = item.right;
          }
          if (lastOp !== null && lastOp.retain === void 0) {
            packOp();
          }
        }
        this._changes = changes;
      });
    }
    return changes;
  }
};
var getPathTo = (parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i8 = 0;
      let c8 = child._item.parent._start;
      while (c8 !== child._item && c8 !== null) {
        if (!c8.deleted) {
          i8++;
        }
        c8 = c8.right;
      }
      path.unshift(i8);
    }
    child = child._item.parent;
  }
  return path;
};
var maxSearchMarker = 80;
var useSearchMarker = (tr, yarray, index2, f10) => {
  const searchMarker = yarray._searchMarker;
  if (searchMarker === null || yarray._start === null || index2 < 5) {
    return f10(new ListIterator(yarray).forward(tr, index2));
  }
  if (searchMarker.length === 0) {
    const sm2 = new ListIterator(yarray).forward(tr, index2);
    searchMarker.push(sm2);
    if (sm2.nextItem)
      sm2.nextItem.marker = true;
  }
  const sm = searchMarker.reduce((a7, b7, arrayIndex) => abs(index2 - a7.index) < abs(index2 - b7.index) ? a7 : b7);
  const newIsCheaper = abs(sm.index - index2) > index2;
  const createFreshMarker = searchMarker.length < maxSearchMarker && (abs(sm.index - index2) > 5 || newIsCheaper);
  const fsm = createFreshMarker ? newIsCheaper ? new ListIterator(yarray) : sm.clone() : sm;
  const prevItem = sm.nextItem;
  if (createFreshMarker) {
    searchMarker.push(fsm);
  }
  const diff = fsm.index - index2;
  if (diff > 0) {
    fsm.backward(tr, diff);
  } else {
    fsm.forward(tr, -diff);
  }
  const result = f10(fsm);
  if (fsm.reachedEnd) {
    fsm.reachedEnd = false;
    const nextItem = fsm.nextItem;
    if (nextItem.countable && !nextItem.deleted) {
      fsm.index -= nextItem.length;
    }
    fsm.rel = 0;
  }
  if (!createFreshMarker) {
    prevItem.marker = false;
  }
  const fsmItem = fsm.nextItem;
  if (fsmItem) {
    if (fsmItem.marker) {
      searchMarker.splice(searchMarker.findIndex((m8) => m8 === fsm), 1);
    } else {
      fsmItem.marker = true;
    }
  }
  return result;
};
var updateMarkerChanges = (searchMarker, index2, len, origSearchMarker) => {
  for (let i8 = searchMarker.length - 1; i8 >= 0; i8--) {
    const marker = searchMarker[i8];
    if (marker !== origSearchMarker) {
      if (len > 0 && index2 === marker.index) {
        searchMarker.splice(i8, 1);
        if (marker.nextItem)
          marker.nextItem.marker = false;
        continue;
      }
      if (index2 < marker.index) {
        marker.index = max(index2, marker.index + len);
      }
    }
  }
};
var callTypeObservers = (type, transaction2, event) => {
  const changedType = type;
  const changedParentTypes = transaction2.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction2);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
    this.meta = /* @__PURE__ */ new Map();
  }
  get parent() {
    return this._item ? this._item.parent : null;
  }
  _integrate(y5, item) {
    this.doc = y5;
    this._item = item;
  }
  _copy() {
    throw methodUnimplemented();
  }
  clone() {
    throw methodUnimplemented();
  }
  _write(encoder) {
  }
  get _first() {
    let n6 = this._start;
    while (n6 !== null && n6.deleted) {
      n6 = n6.right;
    }
    return n6;
  }
  _callObserver(transaction2, parentSubs) {
    if (!transaction2.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  observe(f10) {
    addEventHandlerListener(this._eH, f10);
  }
  observeDeep(f10) {
    addEventHandlerListener(this._dEH, f10);
  }
  unobserve(f10) {
    removeEventHandlerListener(this._eH, f10);
  }
  unobserveDeep(f10) {
    removeEventHandlerListener(this._dEH, f10);
  }
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n6 = type._start;
  while (n6 !== null && len > 0) {
    if (n6.countable && !n6.deleted) {
      const c8 = n6.content.getContent();
      if (c8.length <= start) {
        start -= c8.length;
      } else {
        for (let i8 = start; i8 < c8.length && len > 0; i8++) {
          cs.push(c8[i8]);
          len--;
        }
        start = 0;
      }
    }
    n6 = n6.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  const cs = [];
  let n6 = type._start;
  while (n6 !== null) {
    if (n6.countable && !n6.deleted) {
      const c8 = n6.content.getContent();
      for (let i8 = 0; i8 < c8.length; i8++) {
        cs.push(c8[i8]);
      }
    }
    n6 = n6.right;
  }
  return cs;
};
var typeListForEach = (type, f10) => {
  let index2 = 0;
  let n6 = type._start;
  while (n6 !== null) {
    if (n6.countable && !n6.deleted) {
      const c8 = n6.content.getContent();
      for (let i8 = 0; i8 < c8.length; i8++) {
        f10(c8[i8], index2++, type);
      }
    }
    n6 = n6.right;
  }
};
var typeListMap = (type, f10) => {
  const result = [];
  typeListForEach(type, (c8, i8) => {
    result.push(f10(c8, i8, type));
  });
  return result;
};
var typeListInsertGenericsAfter = (transaction2, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  const store = doc3.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item4(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction2, 0);
      jsonContent = [];
    }
  };
  content.forEach((c8) => {
    if (c8 === null) {
      jsonContent.push(c8);
    } else {
      switch (c8.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c8);
          break;
        default:
          packJsonContent();
          switch (c8.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item4(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(c8)));
              left.integrate(transaction2, 0);
              break;
            case Doc:
              left = new Item4(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(c8));
              left.integrate(transaction2, 0);
              break;
            default:
              if (c8 instanceof AbstractType) {
                left = new Item4(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c8));
                left.integrate(transaction2, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var typeMapDelete = (transaction2, parent, key) => {
  const c8 = parent._map.get(key);
  if (c8 !== void 0) {
    c8.delete(transaction2);
  }
};
var typeMapSet = (transaction2, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(value);
        break;
      case Doc:
        content = new ContentDoc(value);
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item4(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction2, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var createMapIterator = (map4) => iteratorFilter(map4.entries(), (entry) => !entry[1].deleted);
var YArrayEvent = class extends YEvent {
  constructor(yarray, transaction2) {
    super(yarray, transaction2);
    this._transaction = transaction2;
  }
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  static from(items) {
    const a7 = new YArray();
    a7.push(items);
    return a7;
  }
  _integrate(y5, item) {
    super._integrate(y5, item);
    this.insert(0, this._prelimContent);
    this._prelimContent = null;
  }
  _copy() {
    return new YArray();
  }
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map((el) => el instanceof AbstractType ? el.clone() : el));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  _callObserver(transaction2, parentSubs) {
    super._callObserver(transaction2, parentSubs);
    callTypeObservers(this, transaction2, new YArrayEvent(this, transaction2));
  }
  insert(index2, content) {
    if (content.length > 0) {
      if (this.doc !== null) {
        transact(this.doc, (transaction2) => {
          useSearchMarker(transaction2, this, index2, (walker) => walker.insertArrayValue(transaction2, content));
        });
      } else {
        this._prelimContent.splice(index2, 0, ...content);
      }
    }
  }
  move(index2, target) {
    if (index2 === target || index2 + 1 === target || index2 >= this.length) {
      return;
    }
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        const left = createRelativePositionFromTypeIndex(this, index2, 1);
        const right = left.clone();
        right.assoc = -1;
        useSearchMarker(transaction2, this, target, (walker) => {
          walker.insertMove(transaction2, left, right);
        });
      });
    } else {
      const content = this._prelimContent.splice(index2, 1);
      this._prelimContent.splice(target, 0, ...content);
    }
  }
  moveRange(start, end, target, assocStart = 1, assocEnd = -1) {
    if (start <= target && target <= end) {
      return;
    }
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        const left = createRelativePositionFromTypeIndex(this, start, assocStart);
        const right = createRelativePositionFromTypeIndex(this, end + 1, assocEnd);
        useSearchMarker(transaction2, this, target, (walker) => {
          walker.insertMove(transaction2, left, right);
        });
      });
    } else {
      const content = this._prelimContent.splice(start, end - start + 1);
      this._prelimContent.splice(target, 0, ...content);
    }
  }
  push(content) {
    this.insert(this.length, content);
  }
  unshift(content) {
    this.insert(0, content);
  }
  delete(index2, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        useSearchMarker(transaction2, this, index2, (walker) => walker.delete(transaction2, length3));
      });
    } else {
      this._prelimContent.splice(index2, length3);
    }
  }
  get(index2) {
    return transact(this.doc, (transaction2) => useSearchMarker(transaction2, this, index2, (walker) => walker.slice(transaction2, 1)[0]));
  }
  toArray() {
    return transact(this.doc, (tr) => new ListIterator(this).slice(tr, this.length));
  }
  slice(start = 0, end = this.length) {
    return transact(this.doc, (transaction2) => useSearchMarker(transaction2, this, start, (walker) => walker.slice(transaction2, end < 0 ? this.length + end - start : end - start)));
  }
  toJSON() {
    return this.map((c8) => c8 instanceof AbstractType ? c8.toJSON() : c8);
  }
  map(f10) {
    return transact(this.doc, (tr) => new ListIterator(this).map(tr, f10));
  }
  forEach(f10) {
    return transact(this.doc, (tr) => new ListIterator(this).forEach(tr, f10));
  }
  [Symbol.iterator]() {
    return this.toArray().values();
  }
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (decoder) => new YArray();
var YMapEvent = class extends YEvent {
  constructor(ymap, transaction2, subs) {
    super(ymap, transaction2);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  _integrate(y5, item) {
    super._integrate(y5, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  _copy() {
    return new YMap();
  }
  clone() {
    const map4 = new YMap();
    this.forEach((value, key) => {
      map4.set(key, value instanceof AbstractType ? value.clone() : value);
    });
    return map4;
  }
  _callObserver(transaction2, parentSubs) {
    callTypeObservers(this, transaction2, new YMapEvent(this, transaction2, parentSubs));
  }
  toJSON() {
    const map4 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v6 = item.content.getContent()[item.length - 1];
        map4[key] = v6 instanceof AbstractType ? v6.toJSON() : v6;
      }
    });
    return map4;
  }
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  keys() {
    return iteratorMap(createMapIterator(this._map), (v6) => v6[0]);
  }
  values() {
    return iteratorMap(createMapIterator(this._map), (v6) => v6[1].content.getContent()[v6[1].length - 1]);
  }
  entries() {
    return iteratorMap(createMapIterator(this._map), (v6) => [v6[0], v6[1].content.getContent()[v6[1].length - 1]]);
  }
  forEach(f10) {
    const map4 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f10(item.content.getContent()[item.length - 1], key, this);
      }
    });
    return map4;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapDelete(transaction2, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapSet(transaction2, this, key, value);
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  get(key) {
    return typeMapGet(this, key);
  }
  has(key) {
    return typeMapHas(this, key);
  }
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        this.forEach(function(value, key, map4) {
          typeMapDelete(transaction2, map4, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (decoder) => new YMap();
var equalAttrs = (a7, b7) => a7 === b7 || typeof a7 === "object" && typeof b7 === "object" && a7 && b7 && equalFlat(a7, b7);
var ItemTextListPosition = class {
  constructor(left, right, index2, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index2;
    this.currentAttributes = currentAttributes;
  }
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(this.currentAttributes, this.right.content);
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction2, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(pos.currentAttributes, pos.right.content);
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction2, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction2, parent, index2) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  if (parent._searchMarker) {
    return useSearchMarker(transaction2, parent, index2, (listIter) => {
      let left, right;
      if (listIter.rel > 0) {
        const nextItem = listIter.nextItem;
        if (listIter.rel === nextItem.length) {
          left = nextItem;
          right = left.right;
        } else {
          const structs = transaction2.doc.store.clients.get(nextItem.id.client);
          const after = structs[findIndexCleanStart(transaction2, structs, nextItem.id.clock + listIter.rel)];
          listIter.nextItem = after;
          listIter.rel = 0;
          left = listIter.left;
          right = listIter.right;
        }
      } else {
        left = listIter.left;
        right = listIter.right;
      }
      return new ItemTextListPosition(left, right, index2, currentAttributes);
    });
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction2, pos, index2);
  }
};
var insertNegatedAttributes = (transaction2, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(currPos.right.content.key), currPos.right.content.value))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(currPos.right.content.key);
    }
    currPos.forward();
  }
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item4(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction2, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[currPos.right.content.key] || null, currPos.right.content.value))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction2, parent, currPos, attributes) => {
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) || null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item4(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction2, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction2, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction2, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(text2) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index: index2 } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength(), null);
  }
  right = new Item4(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction2, 0);
  currPos.right = right;
  currPos.index = index2;
  currPos.forward();
  insertNegatedAttributes(transaction2, parent, currPos, negatedAttributes);
};
var formatText = (transaction2, parent, currPos, length3, attributes) => {
  const doc3 = transaction2.doc;
  const ownClientId = doc3.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction2, parent, currPos, attributes);
  while (length3 > 0 && currPos.right !== null) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value } = currPos.right.content;
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value)) {
              negatedAttributes.delete(key);
            } else {
              negatedAttributes.set(key, value);
            }
            currPos.right.delete(transaction2);
          }
          break;
        }
        default:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction2, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item4(createID(ownClientId, getState(doc3.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction2, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction2, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction2, start, end, startAttributes, endAttributes) => {
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      updateCurrentAttributes(endAttributes, end.content);
    }
    end = end.right;
  }
  let cleanups = 0;
  while (start !== end) {
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = content;
          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {
            start.delete(transaction2);
            cleanups++;
          }
          break;
        }
      }
    }
    start = start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction2, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = item.content.key;
      if (attrs.has(key)) {
        item.delete(transaction2);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(type.doc, (transaction2) => {
    let start = type._start;
    let end = type._start;
    let startAttributes = create2();
    const currentAttributes = copy(startAttributes);
    while (end) {
      if (end.deleted === false) {
        switch (end.content.constructor) {
          case ContentFormat:
            updateCurrentAttributes(currentAttributes, end.content);
            break;
          default:
            res += cleanupFormattingGap(transaction2, start, end, startAttributes, currentAttributes);
            startAttributes = copy(currentAttributes);
            start = end;
            break;
        }
      }
      end = end.right;
    }
  });
  return res;
};
var deleteText = (transaction2, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction2, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction2);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction2, start, currPos.right, startAttrs, copy(currPos.currentAttributes));
  }
  const parent = (currPos.left || currPos.right).parent;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3, null);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  constructor(ytext, transaction2, subs) {
    super(ytext, transaction2);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return this._changes;
  }
  get delta() {
    if (this._delta === null) {
      const y5 = this.target.doc;
      const delta = [];
      transact(y5, (transaction2) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action2 = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action2 !== null) {
            let op;
            switch (action2) {
              case "delete":
                op = { delete: deleteLen };
                deleteLen = 0;
                break;
              case "insert":
                op = { insert };
                if (currentAttributes.size > 0) {
                  op.attributes = {};
                  currentAttributes.forEach((value, key) => {
                    if (value !== null) {
                      op.attributes[key] = value;
                    }
                  });
                }
                insert = "";
                break;
              case "retain":
                op = { retain };
                if (Object.keys(attributes).length > 0) {
                  op.attributes = {};
                  for (const key in attributes) {
                    op.attributes[key] = attributes[key];
                  }
                }
                retain = 0;
                break;
            }
            delta.push(op);
            action2 = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action2 = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action2 !== "delete") {
                  addOp();
                  action2 = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action2 !== "retain") {
                  addOp();
                  action2 = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action2 !== "insert") {
                    addOp();
                    action2 = "insert";
                  }
                  insert += item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action2 !== "delete") {
                  addOp();
                  action2 = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action2 !== "retain") {
                  addOp();
                  action2 = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = item.content;
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value)) {
                    if (action2 === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) || null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else {
                    item.delete(transaction2);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) || null;
                if (!equalAttrs(curVal, value)) {
                  if (action2 === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action2 === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else {
                    item.delete(transaction2);
                  }
                }
              }
              if (!item.deleted) {
                if (action2 === "insert") {
                  addOp();
                }
                updateCurrentAttributes(currentAttributes, item.content);
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return this._delta;
  }
};
var YText = class extends AbstractType {
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
  }
  get length() {
    return this._length;
  }
  _integrate(y5, item) {
    super._integrate(y5, item);
    try {
      this._pending.forEach((f10) => f10());
    } catch (e11) {
      console.error(e11);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  clone() {
    const text2 = new YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  _callObserver(transaction2, parentSubs) {
    super._callObserver(transaction2, parentSubs);
    const event = new YTextEvent(this, transaction2, parentSubs);
    const doc3 = transaction2.doc;
    callTypeObservers(this, transaction2, event);
    if (!transaction2.local) {
      let foundFormattingItem = false;
      for (const [client, afterClock] of transaction2.afterState.entries()) {
        const clock = transaction2.beforeState.get(client) || 0;
        if (afterClock === clock) {
          continue;
        }
        iterateStructs(transaction2, doc3.store.clients.get(client), clock, afterClock, (item) => {
          if (!item.deleted && item.content.constructor === ContentFormat) {
            foundFormattingItem = true;
          }
        });
        if (foundFormattingItem) {
          break;
        }
      }
      if (!foundFormattingItem) {
        iterateDeletedStructs(transaction2, transaction2.deleteSet, (item) => {
          if (item instanceof GC || foundFormattingItem) {
            return;
          }
          if (item.parent === this && item.content.constructor === ContentFormat) {
            foundFormattingItem = true;
          }
        });
      }
      transact(doc3, (t12) => {
        if (foundFormattingItem) {
          cleanupYTextFormatting(this);
        } else {
          iterateDeletedStructs(t12, t12.deleteSet, (item) => {
            if (item instanceof GC) {
              return;
            }
            if (item.parent === this) {
              cleanupContextlessFormattingGap(t12, item);
            }
          });
        }
      });
    }
  }
  toString() {
    let str = "";
    let n6 = this._start;
    while (n6 !== null) {
      if (!n6.deleted && n6.countable && n6.content.constructor === ContentString) {
        str += n6.content.str;
      }
      n6 = n6.right;
    }
    return str;
  }
  toJSON() {
    return this.toString();
  }
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i8 = 0; i8 < delta.length; i8++) {
          const op = delta[i8];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i8 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction2, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction2, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction2, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc3 = this.doc;
    let str = "";
    let n6 = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    transact(doc3, (transaction2) => {
      if (snapshot) {
        splitSnapshotAffectedStructs(transaction2, snapshot);
      }
      if (prevSnapshot) {
        splitSnapshotAffectedStructs(transaction2, prevSnapshot);
      }
      while (n6 !== null) {
        if (isVisible(n6, snapshot) || prevSnapshot !== void 0 && isVisible(n6, prevSnapshot)) {
          switch (n6.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n6, snapshot)) {
                if (cur === void 0 || cur.user !== n6.id.client || cur.state !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n6.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n6, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n6.id.client || cur.state !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n6.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += n6.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n6.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = {};
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n6, snapshot)) {
                packStr();
                updateCurrentAttributes(currentAttributes, n6.content);
              }
              break;
          }
        }
        n6 = n6.right;
      }
      packStr();
    }, splitSnapshotAffectedStructs);
    return ops;
  }
  insert(index2, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y5 = this.doc;
    if (y5 !== null) {
      transact(y5, (transaction2) => {
        const pos = findPosition(transaction2, this, index2);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v6, k4) => {
            attributes[k4] = v6;
          });
        }
        insertText(transaction2, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index2, text2, attributes));
    }
  }
  insertEmbed(index2, embed, attributes = {}) {
    const y5 = this.doc;
    if (y5 !== null) {
      transact(y5, (transaction2) => {
        const pos = findPosition(transaction2, this, index2);
        insertText(transaction2, this, pos, embed, attributes);
      });
    } else {
      this._pending.push(() => this.insertEmbed(index2, embed, attributes));
    }
  }
  delete(index2, length3) {
    if (length3 === 0) {
      return;
    }
    const y5 = this.doc;
    if (y5 !== null) {
      transact(y5, (transaction2) => {
        deleteText(transaction2, findPosition(transaction2, this, index2), length3);
      });
    } else {
      this._pending.push(() => this.delete(index2, length3));
    }
  }
  format(index2, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y5 = this.doc;
    if (y5 !== null) {
      transact(y5, (transaction2) => {
        const pos = findPosition(transaction2, this, index2);
        if (pos.right === null) {
          return;
        }
        formatText(transaction2, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index2, length3, attributes));
    }
  }
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapDelete(transaction2, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapSet(transaction2, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  getAttribute(attributeName) {
    return typeMapGet(this, attributeName);
  }
  getAttributes(snapshot) {
    return typeMapGetAll(this);
  }
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (decoder) => new YText();
var YXmlTreeWalker = class {
  constructor(root, f10 = () => true) {
    this._filter = f10;
    this._root = root;
    this._currentNode = root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let n6 = this._currentNode;
    let type = n6 && n6.content && n6.content.type;
    if (n6 !== null && (!this._firstCall || n6.deleted || !this._filter(type))) {
      do {
        type = n6.content.type;
        if (!n6.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n6 = type._start;
        } else {
          while (n6 !== null) {
            if (n6.right !== null) {
              n6 = n6.right;
              break;
            } else if (n6.parent === this._root) {
              n6 = null;
            } else {
              n6 = n6.parent._item;
            }
          }
        }
      } while (n6 !== null && (n6.deleted || !this._filter(n6.content.type)));
    }
    this._firstCall = false;
    if (n6 === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n6;
    return { value: n6.content.type, done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  _integrate(y5, item) {
    super._integrate(y5, item);
    this.insert(0, this._prelimContent);
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  querySelectorAll(query) {
    query = query.toUpperCase();
    return Array.from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  _callObserver(transaction2, parentSubs) {
    callTypeObservers(this, transaction2, new YXmlEvent(this, parentSubs, transaction2));
  }
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  toJSON() {
    return this.toString();
  }
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  insert(index2, content) {
    if (this.doc !== null) {
      return transact(this.doc, (transaction2) => useSearchMarker(transaction2, this, index2, (walker) => walker.insertArrayValue(transaction2, content)));
    } else {
      this._prelimContent.splice(index2, 0, ...content);
    }
  }
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction2, this, refItem, content);
      });
    } else {
      const pc = this._prelimContent;
      const index2 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index2 === 0 && ref !== null) {
        throw create5("Reference item not found");
      }
      pc.splice(index2, 0, ...content);
    }
  }
  delete(index2, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => useSearchMarker(transaction2, this, index2, (walker) => walker.delete(transaction2, length3)));
    } else {
      this._prelimContent.splice(index2, length3);
    }
  }
  toArray() {
    return typeListToArray(this);
  }
  push(content) {
    this.insert(this.length, content);
  }
  unshift(content) {
    this.insert(0, content);
  }
  get(index2) {
    return transact(this.doc, (transaction2) => useSearchMarker(transaction2, this, index2, (walker) => walker.slice(transaction2, 1)[0]));
  }
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  get nextSibling() {
    const n6 = this._item ? this._item.next : null;
    return n6 ? n6.content.type : null;
  }
  get prevSibling() {
    const n6 = this._item ? this._item.prev : null;
    return n6 ? n6.content.type : null;
  }
  _integrate(y5, item) {
    super._integrate(y5, item);
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      el.setAttribute(key, attrs[key]);
    }
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i8 = 0; i8 < keysLen; i8++) {
      const key = keys2[i8];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapDelete(transaction2, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction2) => {
        typeMapSet(transaction2, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  getAttribute(attributeName) {
    return typeMapGet(this, attributeName);
  }
  hasAttribute(attributeName) {
    return typeMapHas(this, attributeName);
  }
  getAttributes(snapshot) {
    return typeMapGetAll(this);
  }
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      dom.setAttribute(key, attrs[key]);
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  constructor(target, subs, transaction2) {
    super(target, transaction2);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  _copy() {
    return new YXmlHook(this.hookName);
  }
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class extends YText {
  get nextSibling() {
    const n6 = this._item ? this._item.next : null;
    return n6 ? n6.content.type : null;
  }
  get prevSibling() {
    const n6 = this._item ? this._item.prev : null;
    return n6 ? n6.content.type : null;
  }
  _copy() {
    return new YXmlText();
  }
  clone() {
    const text2 = new YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a7, b7) => a7.key < b7.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a7, b7) => a7.nodeName < b7.nodeName ? -1 : 1);
      let str = "";
      for (let i8 = 0; i8 < nestedNodes.length; i8++) {
        const node = nestedNodes[i8];
        str += `<${node.nodeName}`;
        for (let j4 = 0; j4 < node.attrs.length; j4++) {
          const attr = node.attrs[j4];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i8 = nestedNodes.length - 1; i8 >= 0; i8--) {
        str += `</${nestedNodes[i8].nodeName}>`;
      }
      return str;
    }).join("");
  }
  toJSON() {
    return this.toString();
  }
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  constructor(id, length3) {
    this.id = id;
    this.length = length3;
  }
  get deleted() {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  integrate(transaction2, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  integrate(transaction2, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction2.doc.store, this);
  }
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  getMissing(transaction2, store) {
    return null;
  }
};
var ContentBinary = class {
  constructor(content) {
    this.content = content;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.content];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentBinary(this.content);
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class {
  constructor(len) {
    this.len = len;
  }
  getLength() {
    return this.len;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return false;
  }
  copy() {
    return new ContentDeleted(this.len);
  }
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  integrate(transaction2, item) {
    addToDeleteSet(transaction2.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc(__spreadProps(__spreadValues({ guid }, opts), { shouldLoad: opts.shouldLoad || opts.autoLoad || false }));
var ContentDoc = class {
  constructor(doc3) {
    if (doc3._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc3;
    const opts = {};
    this.opts = opts;
    if (!doc3.gc) {
      opts.gc = false;
    }
    if (doc3.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc3.meta !== null) {
      opts.meta = doc3.meta;
    }
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.doc];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
    this.doc._item = item;
    transaction2.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction2.subdocsLoaded.add(this.doc);
    }
  }
  delete(transaction2) {
    if (transaction2.subdocsAdded.has(this.doc)) {
      transaction2.subdocsAdded.delete(this.doc);
    } else {
      transaction2.subdocsRemoved.add(this.doc);
    }
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class {
  constructor(embed) {
    this.embed = embed;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.embed];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentEmbed(this.embed);
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return false;
  }
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
    item.parent._searchMarker = null;
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readString(), decoder.readJSON());
var ContentJSON = class {
  constructor(arr) {
    this.arr = arr;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentJSON(this.arr);
  }
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  integrate(transaction2, item) {
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i8 = offset; i8 < len; i8++) {
      const c8 = this.arr[i8];
      encoder.writeString(c8 === void 0 ? "undefined" : JSON.stringify(c8));
    }
  }
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i8 = 0; i8 < len; i8++) {
    const c8 = decoder.readString();
    if (c8 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c8));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  constructor(arr) {
    this.arr = arr;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentAny(this.arr);
  }
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  integrate(transaction2, item) {
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i8 = offset; i8 < len; i8++) {
      const c8 = this.arr[i8];
      encoder.writeAny(c8);
    }
  }
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i8 = 0; i8 < len; i8++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  constructor(str) {
    this.str = str;
  }
  getLength() {
    return this.str.length;
  }
  getContent() {
    return this.str.split("");
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentString(this.str);
  }
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  integrate(transaction2, item) {
  }
  delete(transaction2) {
  }
  gc(store) {
  }
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var getMovedCoords = (moved, tr) => {
  let start;
  let end;
  if (moved.start.item) {
    if (moved.start.assoc < 0) {
      start = getItemCleanEnd(tr, moved.start.item);
      start = start.right;
    } else {
      start = getItemCleanStart(tr, moved.start.item);
    }
  } else if (moved.start.tname != null) {
    start = tr.doc.get(moved.start.tname)._start;
  } else if (moved.start.type) {
    start = getItem(tr.doc.store, moved.start.type).content.type._start;
  } else {
    unexpectedCase();
  }
  if (moved.end.item) {
    if (moved.end.assoc < 0) {
      end = getItemCleanEnd(tr, moved.end.item);
      end = end.right;
    } else {
      end = getItemCleanStart(tr, moved.end.item);
    }
  } else {
    end = null;
  }
  return { start, end };
};
var ContentMove = class {
  constructor(start, end, priority) {
    this.start = start;
    this.end = end;
    this.priority = priority;
    this.overrides = /* @__PURE__ */ new Set();
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [null];
  }
  isCountable() {
    return false;
  }
  copy() {
    return new ContentMove(this.start, this.end, this.priority);
  }
  splice(offset) {
    return this;
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
    item.parent._searchMarker = [];
    let { start, end } = getMovedCoords(this, transaction2);
    let maxPriority = 0;
    const adaptPriority = this.priority < 0;
    while (start !== end && start != null) {
      if (!start.deleted) {
        const currMoved = start.moved;
        const nextPrio = currMoved ? currMoved.content.priority : -1;
        if (currMoved === null || adaptPriority || nextPrio < this.priority || currMoved.id.client < item.id.client || currMoved.id.client === item.id.client && currMoved.id.clock < item.id.clock) {
          if (currMoved !== null) {
            this.overrides.add(currMoved);
          }
          maxPriority = max(maxPriority, nextPrio);
          if (start.moved && !transaction2.prevMoved.has(start)) {
            transaction2.prevMoved.set(start, start.moved);
          }
          start.moved = item;
        } else {
          currMoved.content.overrides.add(item);
        }
      }
      start = start.right;
    }
    if (adaptPriority) {
      this.priority = maxPriority + 1;
    }
  }
  delete(transaction2, item) {
    let { start, end } = getMovedCoords(this, transaction2);
    while (start !== end && start != null) {
      if (start.moved === item) {
        start.moved = null;
      }
      start = start.right;
    }
    const reIntegrate = (reIntegrateItem) => {
      const content = reIntegrateItem.content;
      if (reIntegrateItem.deleted) {
        content.overrides.forEach(reIntegrate);
      } else {
        content.integrate(transaction2, reIntegrateItem);
      }
    };
    this.overrides.forEach(reIntegrate);
  }
  gc(store) {
  }
  write(encoder, offset) {
    const isCollapsed = this.isCollapsed();
    writeUint8(encoder.restEncoder, isCollapsed ? 1 : 0);
    encoder.writeBuf(encodeRelativePosition(this.start));
    if (!isCollapsed) {
      encoder.writeBuf(encodeRelativePosition(this.end));
    }
    writeVarUint(encoder.restEncoder, this.priority);
  }
  getRef() {
    return 11;
  }
  isCollapsed() {
    return this.start.item === this.end.item && this.start.item !== null;
  }
};
var readContentMove = (decoder) => {
  const isCollapsed = readUint8(decoder.restDecoder) === 1;
  const start = decodeRelativePosition(decoder.readBuf());
  const end = isCollapsed ? start.clone() : decodeRelativePosition(decoder.readBuf());
  if (isCollapsed) {
    end.assoc = -1;
  }
  return new ContentMove(start, end, readVarUint(decoder.restDecoder));
};
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  constructor(type) {
    this.type = type;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.type];
  }
  isCountable() {
    return true;
  }
  copy() {
    return new ContentType(this.type._copy());
  }
  splice(offset) {
    throw methodUnimplemented();
  }
  mergeWith(right) {
    return false;
  }
  integrate(transaction2, item) {
    this.type._integrate(transaction2.doc, item);
  }
  delete(transaction2) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction2);
      } else {
        transaction2._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction2);
      } else {
        transaction2._mergeStructs.push(item2);
      }
    });
    transaction2.changed.delete(this.type);
  }
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach((item2) => {
      while (item2 !== null) {
        item2.gc(store, true);
        item2 = item2.left;
      }
    });
    this.type._map = /* @__PURE__ */ new Map();
  }
  write(encoder, offset) {
    this.type._write(encoder);
  }
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id) => {
  let nextID = id;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item4);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = item.parent._item;
  }
};
var splitItem = (transaction2, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item4(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction2._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  if (leftItem.moved) {
    const m8 = transaction2.prevMoved.get(leftItem);
    if (m8) {
      transaction2.prevMoved.set(rightItem, m8);
    }
  }
  return rightItem;
};
var redoItem = (transaction2, item, redoitems, itemsToDelete) => {
  const doc3 = transaction2.doc;
  const store = doc3.store;
  const ownClientID = doc3.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction2, redone);
  }
  let parentItem = item.parent._item;
  let left;
  let right;
  if (item.parentSub === null) {
    left = item.left;
    right = item;
  } else {
    left = item;
    while (left.right !== null) {
      left = left.right;
      if (left.id.client !== ownClientID) {
        return null;
      }
    }
    if (left.right !== null) {
      left = item.parent._map.get(item.parentSub);
    }
    right = null;
  }
  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {
    if (!redoitems.has(parentItem) || redoItem(transaction2, parentItem, redoitems, itemsToDelete) === null) {
      return null;
    }
  }
  if (parentItem !== null && parentItem.redone !== null) {
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction2, parentItem.redone);
    }
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction2, leftTrace.redone);
      }
      if (leftTrace !== null && leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction2, rightTrace.redone);
      }
      if (rightTrace !== null && rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
    while (left !== null && left.right !== null && left.right !== right && itemsToDelete.findIndex((d7) => d7 === left.right) >= 0) {
      left = left.right;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item4(nextId, left, left && left.lastId, right, right && right.id, parentItem === null ? item.parent : parentItem.content.type, item.parentSub, item.content.copy());
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction2, 0);
  return redoneItem;
};
var Item4 = class extends AbstractStruct {
  constructor(id, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.moved = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  getMissing(transaction2, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.content.constructor === ContentMove) {
      const c8 = this.content;
      const start = c8.start.item;
      const end = c8.isCollapsed() ? null : c8.end.item;
      if (start && start.clock >= getState(store, start.client)) {
        return start.client;
      }
      if (end && end.clock >= getState(store, end.client)) {
        return end.client;
      }
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction2, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction2, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    }
    if (!this.parent) {
      if (this.left && this.left.constructor === Item4) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item4) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = parentItem.content.type;
      }
    }
    return null;
  }
  integrate(transaction2, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction2, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o11;
        if (left !== null) {
          o11 = left.right;
        } else if (this.parentSub !== null) {
          o11 = this.parent._map.get(this.parentSub) || null;
          while (o11 !== null && o11.left !== null) {
            o11 = o11.left;
          }
        } else {
          o11 = this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o11 !== null && o11 !== this.right) {
          itemsBeforeOrigin.add(o11);
          conflictingItems.add(o11);
          if (compareIDs(this.origin, o11.origin)) {
            if (o11.id.client < this.id.client) {
              left = o11;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o11.rightOrigin)) {
              break;
            }
          } else if (o11.origin !== null && itemsBeforeOrigin.has(getItem(transaction2.doc.store, o11.origin))) {
            if (!conflictingItems.has(getItem(transaction2.doc.store, o11.origin))) {
              left = o11;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o11 = o11.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r12;
        if (this.parentSub !== null) {
          r12 = this.parent._map.get(this.parentSub) || null;
          while (r12 !== null && r12.left !== null) {
            r12 = r12.left;
          }
        } else {
          r12 = this.parent._start;
          this.parent._start = this;
        }
        this.right = r12;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction2);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction2.doc.store, this);
      this.content.integrate(transaction2, this);
      addChangedTypeToTransaction(transaction2, this.parent, this.parentSub);
      if (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) {
        this.delete(transaction2);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction2, 0);
    }
  }
  get next() {
    let n6 = this.right;
    while (n6 !== null && n6.deleted) {
      n6 = n6.right;
    }
    return n6;
  }
  get prev() {
    let n6 = this.left;
    while (n6 !== null && n6.deleted) {
      n6 = n6.left;
    }
    return n6;
  }
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.moved === right.moved && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      if (right.marker) {
        const searchMarker = this.parent._searchMarker;
        if (searchMarker) {
          for (let i8 = searchMarker.length - 1; i8 >= 0; i8--) {
            if (searchMarker[i8].nextItem === right) {
              searchMarker.splice(i8, 1);
            }
          }
        }
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  delete(transaction2) {
    if (!this.deleted) {
      const parent = this.parent;
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction2.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction2, parent, this.parentSub);
      this.content.delete(transaction2, this);
    }
  }
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.moved = null;
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | (rightOrigin === null ? 0 : BIT7) | (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = this.parent;
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  readContentDeleted,
  readContentJSON,
  readContentBinary,
  readContentString,
  readContentEmbed,
  readContentFormat,
  readContentType,
  readContentAny,
  readContentDoc,
  () => {
    unexpectedCase();
  },
  readContentMove
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  integrate(transaction2, offset) {
    unexpectedCase();
  }
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  getMissing(transaction2, store) {
    return null;
  }
};
var glo = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.warn("Yjs was already imported. Importing different versions of Yjs often leads to issues.");
}
glo[importIdentifier] = true;

// ../../node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  constructor(room2) {
    this.room = room2;
    this.onmessage = null;
    onChange((e11) => e11.key === room2 && this.onmessage !== null && this.onmessage({ data: fromBase64(e11.newValue || "") }));
  }
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room2) => setIfUndefined(channels, room2, () => {
  const subs = /* @__PURE__ */ new Set();
  const bc = new BC(room2);
  bc.onmessage = (e11) => subs.forEach((sub) => sub(e11.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room2, f10) => getChannel(room2).subs.add(f10);
var unsubscribe = (room2, f10) => getChannel(room2).subs.delete(f10);
var publish = (room2, data, origin = null) => {
  const c8 = getChannel(room2);
  c8.bc.postMessage(data);
  c8.subs.forEach((sub) => sub(data, origin));
};

// ../../node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc3) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc3);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc3, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc3, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc3) => writeSyncStep2(encoder, doc3, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc3, transactionOrigin) => {
  try {
    applyUpdate(doc3, readVarUint8Array(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc3, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc3);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc3, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc3, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// ../../node_modules/y-protocols/auth.js
var messagePermissionDenied = 0;
var readAuthMessage = (decoder, y5, permissionDeniedHandler2) => {
  switch (readVarUint(decoder)) {
    case messagePermissionDenied:
      permissionDeniedHandler2(y5, readVarString(decoder));
  }
};

// ../../node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  constructor(doc3) {
    super();
    this.doc = doc3;
    this.clientID = doc3.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove2 = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove2.push(clientid);
        }
      });
      if (remove2.length > 0) {
        removeAwarenessStates(this, remove2, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc3.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState(__spreadProps(__spreadValues({}, state), {
        [field]: value
      }));
    }
  }
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness2, clients, origin) => {
  const removed = [];
  for (let i8 = 0; i8 < clients.length; i8++) {
    const clientID = clients[i8];
    if (awareness2.states.has(clientID)) {
      awareness2.states.delete(clientID);
      if (clientID === awareness2.clientID) {
        const curMeta = awareness2.meta.get(clientID);
        awareness2.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness2.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness2.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness2, clients, states = awareness2.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i8 = 0; i8 < len; i8++) {
    const clientID = clients[i8];
    const state = states.get(clientID) || null;
    const clock = awareness2.meta.get(clientID).clock;
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness2, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i8 = 0; i8 < len; i8++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness2.meta.get(clientID);
    const prevState = awareness2.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness2.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness2.clientID && awareness2.getLocalState() != null) {
          clock++;
        } else {
          awareness2.states.delete(clientID);
        }
      } else {
        awareness2.states.set(clientID, state);
      }
      awareness2.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness2.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness2.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// ../../node_modules/lib0/mutex.js
var createMutex = () => {
  let token = true;
  return (f10, g6) => {
    if (token) {
      token = false;
      try {
        f10();
      } finally {
        token = true;
      }
    } else if (g6 !== void 0) {
      g6();
    }
  };
};

// ../../node_modules/lib0/url.js
var encodeQueryParams = (params2) => map3(params2, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&");

// ../../node_modules/y-websocket/src/y-websocket.js
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageAuth = 2;
var messageHandlers = [];
messageHandlers[messageSync] = (encoder, decoder, provider2, emitSynced, messageType) => {
  writeVarUint(encoder, messageSync);
  const syncMessageType = readSyncMessage(decoder, encoder, provider2.doc, provider2);
  if (emitSynced && syncMessageType === messageYjsSyncStep2 && !provider2.synced) {
    provider2.synced = true;
  }
};
messageHandlers[messageQueryAwareness] = (encoder, decoder, provider2, emitSynced, messageType) => {
  writeVarUint(encoder, messageAwareness);
  writeVarUint8Array(encoder, encodeAwarenessUpdate(provider2.awareness, Array.from(provider2.awareness.getStates().keys())));
};
messageHandlers[messageAwareness] = (encoder, decoder, provider2, emitSynced, messageType) => {
  applyAwarenessUpdate(provider2.awareness, readVarUint8Array(decoder), provider2);
};
messageHandlers[messageAuth] = (encoder, decoder, provider2, emitSynced, messageType) => {
  readAuthMessage(decoder, provider2.doc, permissionDeniedHandler);
};
var messageReconnectTimeout = 3e4;
var permissionDeniedHandler = (provider2, reason) => console.warn(`Permission denied to access ${provider2.url}.
${reason}`);
var readMessage = (provider2, buf, emitSynced) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  const messageHandler = provider2.messageHandlers[messageType];
  if (messageHandler) {
    messageHandler(encoder, decoder, provider2, emitSynced, messageType);
  } else {
    console.error("Unable to compute message");
  }
  return encoder;
};
var setupWS = (provider2) => {
  if (provider2.shouldConnect && provider2.ws === null) {
    const websocket = new provider2._WS(provider2.url);
    websocket.binaryType = "arraybuffer";
    provider2.ws = websocket;
    provider2.wsconnecting = true;
    provider2.wsconnected = false;
    provider2.synced = false;
    websocket.onmessage = (event) => {
      provider2.wsLastMessageReceived = getUnixTime();
      const encoder = readMessage(provider2, new Uint8Array(event.data), true);
      if (length(encoder) > 1) {
        websocket.send(toUint8Array(encoder));
      }
    };
    websocket.onerror = (event) => {
      provider2.emit("connection-error", [event, provider2]);
    };
    websocket.onclose = (event) => {
      provider2.emit("connection-close", [event, provider2]);
      provider2.ws = null;
      provider2.wsconnecting = false;
      if (provider2.wsconnected) {
        provider2.wsconnected = false;
        provider2.synced = false;
        removeAwarenessStates(provider2.awareness, Array.from(provider2.awareness.getStates().keys()).filter((client) => client !== provider2.doc.clientID), provider2);
        provider2.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        provider2.wsUnsuccessfulReconnects++;
      }
      setTimeout(setupWS, min(pow(2, provider2.wsUnsuccessfulReconnects) * 100, provider2.maxBackoffTime), provider2);
    };
    websocket.onopen = () => {
      provider2.wsLastMessageReceived = getUnixTime();
      provider2.wsconnecting = false;
      provider2.wsconnected = true;
      provider2.wsUnsuccessfulReconnects = 0;
      provider2.emit("status", [{
        status: "connected"
      }]);
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeSyncStep1(encoder, provider2.doc);
      websocket.send(toUint8Array(encoder));
      if (provider2.awareness.getLocalState() !== null) {
        const encoderAwarenessState = createEncoder();
        writeVarUint(encoderAwarenessState, messageAwareness);
        writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(provider2.awareness, [provider2.doc.clientID]));
        websocket.send(toUint8Array(encoderAwarenessState));
      }
    };
    provider2.emit("status", [{
      status: "connecting"
    }]);
  }
};
var broadcastMessage = (provider2, buf) => {
  if (provider2.wsconnected) {
    provider2.ws.send(buf);
  }
  if (provider2.bcconnected) {
    provider2.mux(() => {
      publish(provider2.bcChannel, buf);
    });
  }
};
var WebsocketProvider = class extends Observable {
  constructor(serverUrl, roomname, doc3, { connect = true, awareness: awareness2 = new Awareness(doc3), params: params2 = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1, maxBackoffTime = 2500 } = {}) {
    super();
    while (serverUrl[serverUrl.length - 1] === "/") {
      serverUrl = serverUrl.slice(0, serverUrl.length - 1);
    }
    const encodedParams = encodeQueryParams(params2);
    this.maxBackoffTime = maxBackoffTime;
    this.bcChannel = serverUrl + "/" + roomname;
    this.url = serverUrl + "/" + roomname + (encodedParams.length === 0 ? "" : "?" + encodedParams);
    this.roomname = roomname;
    this.doc = doc3;
    this._WS = WebSocketPolyfill;
    this.awareness = awareness2;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.bcconnected = false;
    this.wsUnsuccessfulReconnects = 0;
    this.messageHandlers = messageHandlers.slice();
    this.mux = createMutex();
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    if (resyncInterval > 0) {
      this._resyncInterval = setInterval(() => {
        if (this.ws) {
          const encoder = createEncoder();
          writeVarUint(encoder, messageSync);
          writeSyncStep1(encoder, doc3);
          this.ws.send(toUint8Array(encoder));
        }
      }, resyncInterval);
    }
    this._bcSubscriber = (data) => {
      this.mux(() => {
        const encoder = readMessage(this, new Uint8Array(data), false);
        if (length(encoder) > 1) {
          publish(this.bcChannel, toUint8Array(encoder));
        }
      });
    };
    this._updateHandler = (update, origin) => {
      if (origin !== this) {
        const encoder = createEncoder();
        writeVarUint(encoder, messageSync);
        writeUpdate(encoder, update);
        broadcastMessage(this, toUint8Array(encoder));
      }
    };
    this.doc.on("update", this._updateHandler);
    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoder = createEncoder();
      writeVarUint(encoder, messageAwareness);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(awareness2, changedClients));
      broadcastMessage(this, toUint8Array(encoder));
    };
    this._beforeUnloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc3.clientID], "window unload");
    };
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", () => this._beforeUnloadHandler);
    }
    awareness2.on("update", this._awarenessUpdateHandler);
    this._checkInterval = setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout < getUnixTime() - this.wsLastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout / 10);
    if (connect) {
      this.connect();
    }
  }
  get synced() {
    return this._synced;
  }
  set synced(state) {
    if (this._synced !== state) {
      this._synced = state;
      this.emit("synced", [state]);
      this.emit("sync", [state]);
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", () => this._beforeUnloadHandler);
    }
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.doc.off("update", this._updateHandler);
    super.destroy();
  }
  connectBc() {
    if (!this.bcconnected) {
      subscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = true;
    }
    this.mux(() => {
      const encoderSync = createEncoder();
      writeVarUint(encoderSync, messageSync);
      writeSyncStep1(encoderSync, this.doc);
      publish(this.bcChannel, toUint8Array(encoderSync));
      const encoderState = createEncoder();
      writeVarUint(encoderState, messageSync);
      writeSyncStep2(encoderState, this.doc);
      publish(this.bcChannel, toUint8Array(encoderState));
      const encoderAwarenessQuery = createEncoder();
      writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
      publish(this.bcChannel, toUint8Array(encoderAwarenessQuery));
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      publish(this.bcChannel, toUint8Array(encoderAwarenessState));
    });
  }
  disconnectBc() {
    const encoder = createEncoder();
    writeVarUint(encoder, messageAwareness);
    writeVarUint8Array(encoder, encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map()));
    broadcastMessage(this, toUint8Array(encoder));
    if (this.bcconnected) {
      unsubscribe(this.bcChannel, this._bcSubscriber);
      this.bcconnected = false;
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.disconnectBc();
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS(this);
      this.connectBc();
    }
  }
};

// src/yjs-tldraw/src/store.ts
var VERSION = 1;
var doc2 = new Doc();
var roomID = `whiteboard-journey-with-y-tldraw-${VERSION}`;
var provider = new WebsocketProvider("wss://demos.yjs.dev", roomID, doc2, {
  connect: true
});
var awareness = provider.awareness;
var yShapes = doc2.getMap("shapes");
var yBindings = doc2.getMap("bindings");
var undoManager = new UndoManager([yShapes, yBindings]);

// src/yjs-tldraw/src/hooks/useMultiplayerState.ts
var room = new n5(awareness);
function useMultiplayerState(roomId) {
  const [app, setApp] = (0, import_react19.useState)();
  const [loading, setLoading] = (0, import_react19.useState)(true);
  const onMount = (0, import_react19.useCallback)((app2) => {
    const userName = localStorage.getItem("userName");
    app2.loadRoom(roomId, userName === null ? "\uC775\uBA85" : userName);
    app2.pause();
    setApp(app2);
  }, [roomId]);
  const onChangePage = (0, import_react19.useCallback)((app2, shapes, bindings) => {
    undoManager.stopCapturing();
    doc2.transact(() => {
      Object.entries(shapes).forEach(([id, shape]) => {
        if (!shape) {
          yShapes.delete(id);
        } else {
          yShapes.set(shape.id, shape);
        }
      });
      Object.entries(bindings).forEach(([id, binding]) => {
        if (!binding) {
          yBindings.delete(id);
        } else {
          yBindings.set(binding.id, binding);
        }
      });
    });
  }, []);
  const onUndo = (0, import_react19.useCallback)(() => {
    undoManager.undo();
  }, []);
  const onRedo = (0, import_react19.useCallback)(() => {
    undoManager.redo();
  }, []);
  const onChangePresence = (0, import_react19.useCallback)((app2, user) => {
    if (!app2.room)
      return;
    room.setPresence({ id: app2.room.userId, tdUser: user });
  }, []);
  (0, import_react19.useEffect)(() => {
    if (!app || !room)
      return;
    const unsubOthers = room.subscribe("others", (users) => {
      if (!app.room)
        return;
      const ids = users.filter((user) => user.presence).map((user) => user.presence.tdUser.id);
      Object.values(app.room.users).forEach((user) => {
        var _a2;
        if (user && !ids.includes(user.id) && user.id !== ((_a2 = app.room) == null ? void 0 : _a2.userId)) {
          app.removeUser(user.id);
        }
      });
      app.updateUsers(users.filter((user) => user.presence).map((other) => other.presence.tdUser).filter(Boolean));
    });
    return () => {
      unsubOthers();
    };
  }, [app]);
  (0, import_react19.useEffect)(() => {
    if (!app)
      return;
    function handleDisconnect() {
      provider.disconnect();
    }
    window.addEventListener("beforeunload", handleDisconnect);
    function handleChanges() {
      app == null ? void 0 : app.replacePageContent(Object.fromEntries(yShapes.entries()), Object.fromEntries(yBindings.entries()), {});
    }
    function setup() {
      return __async(this, null, function* () {
        yShapes.observeDeep(handleChanges);
        handleChanges();
        setLoading(false);
      });
    }
    setup();
    return () => {
      window.removeEventListener("beforeunload", handleDisconnect);
      yShapes.unobserveDeep(handleChanges);
    };
  }, [app]);
  return {
    onMount,
    onChangePage,
    onUndo,
    onRedo,
    loading,
    onChangePresence
  };
}

// src/yjs-tldraw/src/yjs-tldraw.tsx
function Editor({ roomId }) {
  const fileSystemEvents = useFileSystem();
  const _a2 = useMultiplayerState(roomId), { onMount } = _a2, events = __objRest(_a2, ["onMount"]);
  return /* @__PURE__ */ React78.createElement("div", null, /* @__PURE__ */ React78.createElement(Tldraw, __spreadValues(__spreadValues({
    autofocus: true,
    disableAssets: true,
    showPages: false,
    onMount
  }, fileSystemEvents), events)));
}
function YjsTldraw() {
  React78.useEffect(() => {
    const userName = prompt("\uC774\uB984 \uC785\uB825\uD574\uC8FC\uC138\uC694");
    localStorage.setItem("userName", userName);
  }, []);
  return /* @__PURE__ */ React78.createElement("div", {
    className: "tldraw"
  }, /* @__PURE__ */ React78.createElement(Editor, {
    roomId: roomID
  }));
}

// ../../node_modules/react-router-dom/index.js
var import_react21 = __toESM(require_react());

// ../../node_modules/history/index.js
var r11;
var B3 = r11 || (r11 = {});
B3.Pop = "POP";
B3.Push = "PUSH";
B3.Replace = "REPLACE";
var C5 = false ? function(b7) {
  return Object.freeze(b7);
} : function(b7) {
  return b7;
};
function E6(b7) {
  b7.preventDefault();
  b7.returnValue = "";
}
function F4() {
  var b7 = [];
  return { get length() {
    return b7.length;
  }, push: function(h4) {
    b7.push(h4);
    return function() {
      b7 = b7.filter(function(e11) {
        return e11 !== h4;
      });
    };
  }, call: function(h4) {
    b7.forEach(function(e11) {
      return e11 && e11(h4);
    });
  } };
}
function H3() {
  return Math.random().toString(36).substr(2, 8);
}
function I3(b7) {
  var h4 = b7.pathname;
  h4 = h4 === void 0 ? "/" : h4;
  var e11 = b7.search;
  e11 = e11 === void 0 ? "" : e11;
  b7 = b7.hash;
  b7 = b7 === void 0 ? "" : b7;
  e11 && e11 !== "?" && (h4 += e11.charAt(0) === "?" ? e11 : "?" + e11);
  b7 && b7 !== "#" && (h4 += b7.charAt(0) === "#" ? b7 : "#" + b7);
  return h4;
}
function J3(b7) {
  var h4 = {};
  if (b7) {
    var e11 = b7.indexOf("#");
    0 <= e11 && (h4.hash = b7.substr(e11), b7 = b7.substr(0, e11));
    e11 = b7.indexOf("?");
    0 <= e11 && (h4.search = b7.substr(e11), b7 = b7.substr(0, e11));
    b7 && (h4.pathname = b7);
  }
  return h4;
}
function createHashHistory(b7) {
  function h4() {
    var a7 = J3(m8.location.hash.substr(1)), f10 = a7.pathname, l9 = a7.search;
    a7 = a7.hash;
    var k4 = u4.state || {};
    return [k4.idx, C5({ pathname: f10 === void 0 ? "/" : f10, search: l9 === void 0 ? "" : l9, hash: a7 === void 0 ? "" : a7, state: k4.usr || null, key: k4.key || "default" })];
  }
  function e11() {
    if (t12)
      c8.call(t12), t12 = null;
    else {
      var a7 = r11.Pop, f10 = h4(), l9 = f10[0];
      f10 = f10[1];
      if (c8.length)
        if (l9 != null) {
          var k4 = q3 - l9;
          k4 && (t12 = { action: a7, location: f10, retry: function() {
            p7(-1 * k4);
          } }, p7(k4));
        } else
          false ? D(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
      else
        A3(a7);
    }
  }
  function x6(a7) {
    var f10 = document.querySelector("base"), l9 = "";
    f10 && f10.getAttribute("href") && (f10 = m8.location.href, l9 = f10.indexOf("#"), l9 = l9 === -1 ? f10 : f10.slice(0, l9));
    return l9 + "#" + (typeof a7 === "string" ? a7 : I3(a7));
  }
  function z3(a7, f10) {
    f10 === void 0 && (f10 = null);
    return C5(_extends2({ pathname: d7.pathname, hash: "", search: "" }, typeof a7 === "string" ? J3(a7) : a7, { state: f10, key: H3() }));
  }
  function A3(a7) {
    v6 = a7;
    a7 = h4();
    q3 = a7[0];
    d7 = a7[1];
    g6.call({ action: v6, location: d7 });
  }
  function y5(a7, f10) {
    function l9() {
      y5(a7, f10);
    }
    var k4 = r11.Push, n6 = z3(a7, f10);
    false ? D(n6.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(a7) + ")") : void 0;
    if (!c8.length || (c8.call({ action: k4, location: n6, retry: l9 }), false)) {
      var G4 = [{ usr: n6.state, key: n6.key, idx: q3 + 1 }, x6(n6)];
      n6 = G4[0];
      G4 = G4[1];
      try {
        u4.pushState(n6, "", G4);
      } catch (K3) {
        m8.location.assign(G4);
      }
      A3(k4);
    }
  }
  function w6(a7, f10) {
    function l9() {
      w6(a7, f10);
    }
    var k4 = r11.Replace, n6 = z3(a7, f10);
    false ? D(n6.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(a7) + ")") : void 0;
    c8.length && (c8.call({ action: k4, location: n6, retry: l9 }), 1) || (n6 = [{ usr: n6.state, key: n6.key, idx: q3 }, x6(n6)], u4.replaceState(n6[0], "", n6[1]), A3(k4));
  }
  function p7(a7) {
    u4.go(a7);
  }
  b7 === void 0 && (b7 = {});
  b7 = b7.window;
  var m8 = b7 === void 0 ? document.defaultView : b7, u4 = m8.history, t12 = null;
  m8.addEventListener("popstate", e11);
  m8.addEventListener("hashchange", function() {
    var a7 = h4()[1];
    I3(a7) !== I3(d7) && e11();
  });
  var v6 = r11.Pop;
  b7 = h4();
  var q3 = b7[0], d7 = b7[1], g6 = F4(), c8 = F4();
  q3 == null && (q3 = 0, u4.replaceState(_extends2({}, u4.state, { idx: q3 }), ""));
  return {
    get action() {
      return v6;
    },
    get location() {
      return d7;
    },
    createHref: x6,
    push: y5,
    replace: w6,
    go: p7,
    back: function() {
      p7(-1);
    },
    forward: function() {
      p7(1);
    },
    listen: function(a7) {
      return g6.push(a7);
    },
    block: function(a7) {
      var f10 = c8.push(a7);
      c8.length === 1 && m8.addEventListener("beforeunload", E6);
      return function() {
        f10();
        c8.length || m8.removeEventListener("beforeunload", E6);
      };
    }
  };
}

// ../../node_modules/react-router/index.js
var import_react20 = __toESM(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
var NavigationContext = /* @__PURE__ */ (0, import_react20.createContext)(null);
if (false) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react20.createContext)(null);
if (false) {
  LocationContext.displayName = "Location";
}
if (false) {
  RouteContext.displayName = "Route";
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r11.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? false ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react20.useMemo)(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J3(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location2 = (0, import_react20.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  false ? warning(location2 != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react20.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react20.createElement)(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function useInRouterContext() {
  return (0, import_react20.useContext)(LocationContext) != null;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

// ../../node_modules/react-router-dom/index.js
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window: window2
  } = _ref2;
  let historyRef = (0, import_react21.useRef)();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2
    });
  }
  let history = historyRef.current;
  let [state, setState] = (0, import_react21.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react21.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react21.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (false) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
if (false) {
  Link.displayName = "Link";
}
if (false) {
  NavLink.displayName = "NavLink";
}

// src/index.tsx
import_react_dom3.default.render(/* @__PURE__ */ import_react22.default.createElement(import_react22.default.StrictMode, null, /* @__PURE__ */ import_react22.default.createElement(HashRouter, null, /* @__PURE__ */ import_react22.default.createElement(YjsTldraw, null))), document.getElementById("root"));
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * hotkeys-js v3.8.7
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 * 
 * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * 
 * Licensed under the MIT license.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * String.prototype.replaceAll() polyfill
 * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
 * @author Chris Ferdinandi
 * @license MIT
 */
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// @license  2020 Google LLC. Licensed under the Apache License, Version 2.0.
